import {
  createStore
} from "./chunk-CEVL2VWX.js";
import {
  Dynamic,
  Portal,
  insert,
  isServer,
  memo,
  setAttribute,
  template
} from "./chunk-2IHAWATP.js";
import {
  For,
  Index,
  Match,
  Show,
  Switch,
  __commonJS,
  __toESM,
  batch,
  children,
  createComponent,
  createComputed,
  createContext,
  createEffect,
  createMemo,
  createRenderEffect,
  createSignal,
  createUniqueId,
  mergeProps,
  on,
  onCleanup,
  onMount,
  splitProps,
  untrack,
  useContext
} from "./chunk-NARJ5M2S.js";

// node_modules/lodash.merge/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject2(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size3 = data.size;
      data.set(key, value);
      this.size += data.size == size3 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack2(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack2.prototype.clear = stackClear;
    Stack2.prototype["delete"] = stackDelete;
    Stack2.prototype.get = stackGet;
    Stack2.prototype.has = stackHas;
    Stack2.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject2(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack2());
        if (isObject2(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray2(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject2(objValue) || isFunction2(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject2(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge2 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge2;
  }
});

// node_modules/scroll-lock/dist/scroll-lock.js
var require_scroll_lock = __commonJS({
  "node_modules/scroll-lock/dist/scroll-lock.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory2) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory2();
      else if (typeof define === "function" && define.amd)
        define([], factory2);
      else if (typeof exports === "object")
        exports["scrollLock"] = factory2();
      else
        root["scrollLock"] = factory2();
    })(exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string")
            for (var key in value)
              __webpack_require__.d(ns, key, function(key2) {
                return value[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function getDefault() {
            return module2["default"];
          } : function getModuleExports() {
            return module2;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 0);
      }([
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          var argumentAsArray = function argumentAsArray2(argument) {
            return Array.isArray(argument) ? argument : [argument];
          };
          var isElement3 = function isElement4(target) {
            return target instanceof Node;
          };
          var isElementList = function isElementList2(nodeList) {
            return nodeList instanceof NodeList;
          };
          var eachNode = function eachNode2(nodeList, callback) {
            if (nodeList && callback) {
              nodeList = isElementList(nodeList) ? nodeList : [nodeList];
              for (var i2 = 0; i2 < nodeList.length; i2++) {
                if (callback(nodeList[i2], i2, nodeList.length) === true) {
                  break;
                }
              }
            }
          };
          var throwError = function throwError2(message) {
            return console.error("[scroll-lock] ".concat(message));
          };
          var arrayAsSelector = function arrayAsSelector2(array) {
            if (Array.isArray(array)) {
              var selector = array.join(", ");
              return selector;
            }
          };
          var nodeListAsArray = function nodeListAsArray2(nodeList) {
            var nodes = [];
            eachNode(nodeList, function(node) {
              return nodes.push(node);
            });
            return nodes;
          };
          var findParentBySelector = function findParentBySelector2($el, selector) {
            var self2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            var $root = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : document;
            if (self2 && nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) !== -1) {
              return $el;
            }
            while (($el = $el.parentElement) && nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) === -1) {
              ;
            }
            return $el;
          };
          var elementHasSelector = function elementHasSelector2($el, selector) {
            var $root = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : document;
            var has = nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) !== -1;
            return has;
          };
          var elementHasOverflowHidden = function elementHasOverflowHidden2($el) {
            if ($el) {
              var computedStyle = getComputedStyle($el);
              var overflowIsHidden = computedStyle.overflow === "hidden";
              return overflowIsHidden;
            }
          };
          var elementScrollTopOnStart = function elementScrollTopOnStart2($el) {
            if ($el) {
              if (elementHasOverflowHidden($el)) {
                return true;
              }
              var scrollTop = $el.scrollTop;
              return scrollTop <= 0;
            }
          };
          var elementScrollTopOnEnd = function elementScrollTopOnEnd2($el) {
            if ($el) {
              if (elementHasOverflowHidden($el)) {
                return true;
              }
              var scrollTop = $el.scrollTop;
              var scrollHeight = $el.scrollHeight;
              var scrollTopWithHeight = scrollTop + $el.offsetHeight;
              return scrollTopWithHeight >= scrollHeight;
            }
          };
          var elementScrollLeftOnStart = function elementScrollLeftOnStart2($el) {
            if ($el) {
              if (elementHasOverflowHidden($el)) {
                return true;
              }
              var scrollLeft = $el.scrollLeft;
              return scrollLeft <= 0;
            }
          };
          var elementScrollLeftOnEnd = function elementScrollLeftOnEnd2($el) {
            if ($el) {
              if (elementHasOverflowHidden($el)) {
                return true;
              }
              var scrollLeft = $el.scrollLeft;
              var scrollWidth = $el.scrollWidth;
              var scrollLeftWithWidth = scrollLeft + $el.offsetWidth;
              return scrollLeftWithWidth >= scrollWidth;
            }
          };
          var elementIsScrollableField = function elementIsScrollableField2($el) {
            var selector = 'textarea, [contenteditable="true"]';
            return elementHasSelector($el, selector);
          };
          var elementIsInputRange = function elementIsInputRange2($el) {
            var selector = 'input[type="range"]';
            return elementHasSelector($el, selector);
          };
          __webpack_require__.d(__webpack_exports__, "disablePageScroll", function() {
            return disablePageScroll2;
          });
          __webpack_require__.d(__webpack_exports__, "enablePageScroll", function() {
            return enablePageScroll2;
          });
          __webpack_require__.d(__webpack_exports__, "getScrollState", function() {
            return getScrollState;
          });
          __webpack_require__.d(__webpack_exports__, "clearQueueScrollLocks", function() {
            return clearQueueScrollLocks2;
          });
          __webpack_require__.d(__webpack_exports__, "getTargetScrollBarWidth", function() {
            return scroll_lock_getTargetScrollBarWidth;
          });
          __webpack_require__.d(__webpack_exports__, "getCurrentTargetScrollBarWidth", function() {
            return scroll_lock_getCurrentTargetScrollBarWidth;
          });
          __webpack_require__.d(__webpack_exports__, "getPageScrollBarWidth", function() {
            return getPageScrollBarWidth;
          });
          __webpack_require__.d(__webpack_exports__, "getCurrentPageScrollBarWidth", function() {
            return getCurrentPageScrollBarWidth;
          });
          __webpack_require__.d(__webpack_exports__, "addScrollableTarget", function() {
            return scroll_lock_addScrollableTarget;
          });
          __webpack_require__.d(__webpack_exports__, "removeScrollableTarget", function() {
            return scroll_lock_removeScrollableTarget;
          });
          __webpack_require__.d(__webpack_exports__, "addScrollableSelector", function() {
            return scroll_lock_addScrollableSelector;
          });
          __webpack_require__.d(__webpack_exports__, "removeScrollableSelector", function() {
            return scroll_lock_removeScrollableSelector;
          });
          __webpack_require__.d(__webpack_exports__, "addLockableTarget", function() {
            return scroll_lock_addLockableTarget;
          });
          __webpack_require__.d(__webpack_exports__, "addLockableSelector", function() {
            return scroll_lock_addLockableSelector;
          });
          __webpack_require__.d(__webpack_exports__, "setFillGapMethod", function() {
            return scroll_lock_setFillGapMethod;
          });
          __webpack_require__.d(__webpack_exports__, "addFillGapTarget", function() {
            return scroll_lock_addFillGapTarget;
          });
          __webpack_require__.d(__webpack_exports__, "removeFillGapTarget", function() {
            return scroll_lock_removeFillGapTarget;
          });
          __webpack_require__.d(__webpack_exports__, "addFillGapSelector", function() {
            return scroll_lock_addFillGapSelector;
          });
          __webpack_require__.d(__webpack_exports__, "removeFillGapSelector", function() {
            return scroll_lock_removeFillGapSelector;
          });
          __webpack_require__.d(__webpack_exports__, "refillGaps", function() {
            return refillGaps;
          });
          function _objectSpread(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              var source = arguments[i2] != null ? arguments[i2] : {};
              var ownKeys2 = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === "function") {
                ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                }));
              }
              ownKeys2.forEach(function(key) {
                _defineProperty2(target, key, source[key]);
              });
            }
            return target;
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var FILL_GAP_AVAILABLE_METHODS = ["padding", "margin", "width", "max-width", "none"];
          var TOUCH_DIRECTION_DETECT_OFFSET = 3;
          var state = {
            scroll: true,
            queue: 0,
            scrollableSelectors: ["[data-scroll-lock-scrollable]"],
            lockableSelectors: ["body", "[data-scroll-lock-lockable]"],
            fillGapSelectors: ["body", "[data-scroll-lock-fill-gap]", "[data-scroll-lock-lockable]"],
            fillGapMethod: FILL_GAP_AVAILABLE_METHODS[0],
            startTouchY: 0,
            startTouchX: 0
          };
          var disablePageScroll2 = function disablePageScroll3(target) {
            if (state.queue <= 0) {
              state.scroll = false;
              scroll_lock_hideLockableOverflow();
              fillGaps();
            }
            scroll_lock_addScrollableTarget(target);
            state.queue++;
          };
          var enablePageScroll2 = function enablePageScroll3(target) {
            state.queue > 0 && state.queue--;
            if (state.queue <= 0) {
              state.scroll = true;
              scroll_lock_showLockableOverflow();
              unfillGaps();
            }
            scroll_lock_removeScrollableTarget(target);
          };
          var getScrollState = function getScrollState2() {
            return state.scroll;
          };
          var clearQueueScrollLocks2 = function clearQueueScrollLocks3() {
            state.queue = 0;
          };
          var scroll_lock_getTargetScrollBarWidth = function getTargetScrollBarWidth($target) {
            var onlyExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            if (isElement3($target)) {
              var currentOverflowYProperty = $target.style.overflowY;
              if (onlyExists) {
                if (!getScrollState()) {
                  $target.style.overflowY = $target.getAttribute("data-scroll-lock-saved-overflow-y-property");
                }
              } else {
                $target.style.overflowY = "scroll";
              }
              var width = scroll_lock_getCurrentTargetScrollBarWidth($target);
              $target.style.overflowY = currentOverflowYProperty;
              return width;
            } else {
              return 0;
            }
          };
          var scroll_lock_getCurrentTargetScrollBarWidth = function getCurrentTargetScrollBarWidth($target) {
            if (isElement3($target)) {
              if ($target === document.body) {
                var documentWidth = document.documentElement.clientWidth;
                var windowWidth = window.innerWidth;
                var currentWidth = windowWidth - documentWidth;
                return currentWidth;
              } else {
                var borderLeftWidthCurrentProperty = $target.style.borderLeftWidth;
                var borderRightWidthCurrentProperty = $target.style.borderRightWidth;
                $target.style.borderLeftWidth = "0px";
                $target.style.borderRightWidth = "0px";
                var _currentWidth = $target.offsetWidth - $target.clientWidth;
                $target.style.borderLeftWidth = borderLeftWidthCurrentProperty;
                $target.style.borderRightWidth = borderRightWidthCurrentProperty;
                return _currentWidth;
              }
            } else {
              return 0;
            }
          };
          var getPageScrollBarWidth = function getPageScrollBarWidth2() {
            var onlyExists = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            return scroll_lock_getTargetScrollBarWidth(document.body, onlyExists);
          };
          var getCurrentPageScrollBarWidth = function getCurrentPageScrollBarWidth2() {
            return scroll_lock_getCurrentTargetScrollBarWidth(document.body);
          };
          var scroll_lock_addScrollableTarget = function addScrollableTarget(target) {
            if (target) {
              var targets = argumentAsArray(target);
              targets.map(function($targets) {
                eachNode($targets, function($target) {
                  if (isElement3($target)) {
                    $target.setAttribute("data-scroll-lock-scrollable", "");
                  } else {
                    throwError('"'.concat($target, '" is not a Element.'));
                  }
                });
              });
            }
          };
          var scroll_lock_removeScrollableTarget = function removeScrollableTarget(target) {
            if (target) {
              var targets = argumentAsArray(target);
              targets.map(function($targets) {
                eachNode($targets, function($target) {
                  if (isElement3($target)) {
                    $target.removeAttribute("data-scroll-lock-scrollable");
                  } else {
                    throwError('"'.concat($target, '" is not a Element.'));
                  }
                });
              });
            }
          };
          var scroll_lock_addScrollableSelector = function addScrollableSelector2(selector) {
            if (selector) {
              var selectors = argumentAsArray(selector);
              selectors.map(function(selector2) {
                state.scrollableSelectors.push(selector2);
              });
            }
          };
          var scroll_lock_removeScrollableSelector = function removeScrollableSelector2(selector) {
            if (selector) {
              var selectors = argumentAsArray(selector);
              selectors.map(function(selector2) {
                state.scrollableSelectors = state.scrollableSelectors.filter(function(sSelector) {
                  return sSelector !== selector2;
                });
              });
            }
          };
          var scroll_lock_addLockableTarget = function addLockableTarget(target) {
            if (target) {
              var targets = argumentAsArray(target);
              targets.map(function($targets) {
                eachNode($targets, function($target) {
                  if (isElement3($target)) {
                    $target.setAttribute("data-scroll-lock-lockable", "");
                  } else {
                    throwError('"'.concat($target, '" is not a Element.'));
                  }
                });
              });
              if (!getScrollState()) {
                scroll_lock_hideLockableOverflow();
              }
            }
          };
          var scroll_lock_addLockableSelector = function addLockableSelector(selector) {
            if (selector) {
              var selectors = argumentAsArray(selector);
              selectors.map(function(selector2) {
                state.lockableSelectors.push(selector2);
              });
              if (!getScrollState()) {
                scroll_lock_hideLockableOverflow();
              }
              scroll_lock_addFillGapSelector(selector);
            }
          };
          var scroll_lock_setFillGapMethod = function setFillGapMethod(method) {
            if (method) {
              if (FILL_GAP_AVAILABLE_METHODS.indexOf(method) !== -1) {
                state.fillGapMethod = method;
                refillGaps();
              } else {
                var methods = FILL_GAP_AVAILABLE_METHODS.join(", ");
                throwError('"'.concat(method, '" method is not available!\nAvailable fill gap methods: ').concat(methods, "."));
              }
            }
          };
          var scroll_lock_addFillGapTarget = function addFillGapTarget(target) {
            if (target) {
              var targets = argumentAsArray(target);
              targets.map(function($targets) {
                eachNode($targets, function($target) {
                  if (isElement3($target)) {
                    $target.setAttribute("data-scroll-lock-fill-gap", "");
                    if (!state.scroll) {
                      scroll_lock_fillGapTarget($target);
                    }
                  } else {
                    throwError('"'.concat($target, '" is not a Element.'));
                  }
                });
              });
            }
          };
          var scroll_lock_removeFillGapTarget = function removeFillGapTarget(target) {
            if (target) {
              var targets = argumentAsArray(target);
              targets.map(function($targets) {
                eachNode($targets, function($target) {
                  if (isElement3($target)) {
                    $target.removeAttribute("data-scroll-lock-fill-gap");
                    if (!state.scroll) {
                      scroll_lock_unfillGapTarget($target);
                    }
                  } else {
                    throwError('"'.concat($target, '" is not a Element.'));
                  }
                });
              });
            }
          };
          var scroll_lock_addFillGapSelector = function addFillGapSelector(selector) {
            if (selector) {
              var selectors = argumentAsArray(selector);
              selectors.map(function(selector2) {
                if (state.fillGapSelectors.indexOf(selector2) === -1) {
                  state.fillGapSelectors.push(selector2);
                  if (!state.scroll) {
                    scroll_lock_fillGapSelector(selector2);
                  }
                }
              });
            }
          };
          var scroll_lock_removeFillGapSelector = function removeFillGapSelector(selector) {
            if (selector) {
              var selectors = argumentAsArray(selector);
              selectors.map(function(selector2) {
                state.fillGapSelectors = state.fillGapSelectors.filter(function(fSelector) {
                  return fSelector !== selector2;
                });
                if (!state.scroll) {
                  scroll_lock_unfillGapSelector(selector2);
                }
              });
            }
          };
          var refillGaps = function refillGaps2() {
            if (!state.scroll) {
              fillGaps();
            }
          };
          var scroll_lock_hideLockableOverflow = function hideLockableOverflow() {
            var selector = arrayAsSelector(state.lockableSelectors);
            scroll_lock_hideLockableOverflowSelector(selector);
          };
          var scroll_lock_showLockableOverflow = function showLockableOverflow() {
            var selector = arrayAsSelector(state.lockableSelectors);
            scroll_lock_showLockableOverflowSelector(selector);
          };
          var scroll_lock_hideLockableOverflowSelector = function hideLockableOverflowSelector(selector) {
            var $targets = document.querySelectorAll(selector);
            eachNode($targets, function($target) {
              scroll_lock_hideLockableOverflowTarget($target);
            });
          };
          var scroll_lock_showLockableOverflowSelector = function showLockableOverflowSelector(selector) {
            var $targets = document.querySelectorAll(selector);
            eachNode($targets, function($target) {
              scroll_lock_showLockableOverflowTarget($target);
            });
          };
          var scroll_lock_hideLockableOverflowTarget = function hideLockableOverflowTarget($target) {
            if (isElement3($target) && $target.getAttribute("data-scroll-lock-locked") !== "true") {
              var computedStyle = window.getComputedStyle($target);
              $target.setAttribute("data-scroll-lock-saved-overflow-y-property", computedStyle.overflowY);
              $target.setAttribute("data-scroll-lock-saved-inline-overflow-property", $target.style.overflow);
              $target.setAttribute("data-scroll-lock-saved-inline-overflow-y-property", $target.style.overflowY);
              $target.style.overflow = "hidden";
              $target.setAttribute("data-scroll-lock-locked", "true");
            }
          };
          var scroll_lock_showLockableOverflowTarget = function showLockableOverflowTarget($target) {
            if (isElement3($target) && $target.getAttribute("data-scroll-lock-locked") === "true") {
              $target.style.overflow = $target.getAttribute("data-scroll-lock-saved-inline-overflow-property");
              $target.style.overflowY = $target.getAttribute("data-scroll-lock-saved-inline-overflow-y-property");
              $target.removeAttribute("data-scroll-lock-saved-overflow-property");
              $target.removeAttribute("data-scroll-lock-saved-inline-overflow-property");
              $target.removeAttribute("data-scroll-lock-saved-inline-overflow-y-property");
              $target.removeAttribute("data-scroll-lock-locked");
            }
          };
          var fillGaps = function fillGaps2() {
            state.fillGapSelectors.map(function(selector) {
              scroll_lock_fillGapSelector(selector);
            });
          };
          var unfillGaps = function unfillGaps2() {
            state.fillGapSelectors.map(function(selector) {
              scroll_lock_unfillGapSelector(selector);
            });
          };
          var scroll_lock_fillGapSelector = function fillGapSelector(selector) {
            var $targets = document.querySelectorAll(selector);
            var isLockable = state.lockableSelectors.indexOf(selector) !== -1;
            eachNode($targets, function($target) {
              scroll_lock_fillGapTarget($target, isLockable);
            });
          };
          var scroll_lock_fillGapTarget = function fillGapTarget($target) {
            var isLockable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            if (isElement3($target)) {
              var scrollBarWidth;
              if ($target.getAttribute("data-scroll-lock-lockable") === "" || isLockable) {
                scrollBarWidth = scroll_lock_getTargetScrollBarWidth($target, true);
              } else {
                var $lockableParent = findParentBySelector($target, arrayAsSelector(state.lockableSelectors));
                scrollBarWidth = scroll_lock_getTargetScrollBarWidth($lockableParent, true);
              }
              if ($target.getAttribute("data-scroll-lock-filled-gap") === "true") {
                scroll_lock_unfillGapTarget($target);
              }
              var computedStyle = window.getComputedStyle($target);
              $target.setAttribute("data-scroll-lock-filled-gap", "true");
              $target.setAttribute("data-scroll-lock-current-fill-gap-method", state.fillGapMethod);
              if (state.fillGapMethod === "margin") {
                var currentMargin = parseFloat(computedStyle.marginRight);
                $target.style.marginRight = "".concat(currentMargin + scrollBarWidth, "px");
              } else if (state.fillGapMethod === "width") {
                $target.style.width = "calc(100% - ".concat(scrollBarWidth, "px)");
              } else if (state.fillGapMethod === "max-width") {
                $target.style.maxWidth = "calc(100% - ".concat(scrollBarWidth, "px)");
              } else if (state.fillGapMethod === "padding") {
                var currentPadding = parseFloat(computedStyle.paddingRight);
                $target.style.paddingRight = "".concat(currentPadding + scrollBarWidth, "px");
              }
            }
          };
          var scroll_lock_unfillGapSelector = function unfillGapSelector(selector) {
            var $targets = document.querySelectorAll(selector);
            eachNode($targets, function($target) {
              scroll_lock_unfillGapTarget($target);
            });
          };
          var scroll_lock_unfillGapTarget = function unfillGapTarget($target) {
            if (isElement3($target)) {
              if ($target.getAttribute("data-scroll-lock-filled-gap") === "true") {
                var currentFillGapMethod = $target.getAttribute("data-scroll-lock-current-fill-gap-method");
                $target.removeAttribute("data-scroll-lock-filled-gap");
                $target.removeAttribute("data-scroll-lock-current-fill-gap-method");
                if (currentFillGapMethod === "margin") {
                  $target.style.marginRight = "";
                } else if (currentFillGapMethod === "width") {
                  $target.style.width = "";
                } else if (currentFillGapMethod === "max-width") {
                  $target.style.maxWidth = "";
                } else if (currentFillGapMethod === "padding") {
                  $target.style.paddingRight = "";
                }
              }
            }
          };
          var onResize = function onResize2(e) {
            refillGaps();
          };
          var onTouchStart = function onTouchStart2(e) {
            if (!state.scroll) {
              state.startTouchY = e.touches[0].clientY;
              state.startTouchX = e.touches[0].clientX;
            }
          };
          var scroll_lock_onTouchMove = function onTouchMove(e) {
            if (!state.scroll) {
              var startTouchY = state.startTouchY, startTouchX = state.startTouchX;
              var currentClientY = e.touches[0].clientY;
              var currentClientX = e.touches[0].clientX;
              if (e.touches.length < 2) {
                var selector = arrayAsSelector(state.scrollableSelectors);
                var direction = {
                  up: startTouchY < currentClientY,
                  down: startTouchY > currentClientY,
                  left: startTouchX < currentClientX,
                  right: startTouchX > currentClientX
                };
                var directionWithOffset = {
                  up: startTouchY + TOUCH_DIRECTION_DETECT_OFFSET < currentClientY,
                  down: startTouchY - TOUCH_DIRECTION_DETECT_OFFSET > currentClientY,
                  left: startTouchX + TOUCH_DIRECTION_DETECT_OFFSET < currentClientX,
                  right: startTouchX - TOUCH_DIRECTION_DETECT_OFFSET > currentClientX
                };
                var handle = function handle2($el) {
                  var skip = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  if ($el) {
                    var parentScrollableEl = findParentBySelector($el, selector, false);
                    if (elementIsInputRange($el)) {
                      return false;
                    }
                    if (skip || elementIsScrollableField($el) && findParentBySelector($el, selector) || elementHasSelector($el, selector)) {
                      var prevent = false;
                      if (elementScrollLeftOnStart($el) && elementScrollLeftOnEnd($el)) {
                        if (direction.up && elementScrollTopOnStart($el) || direction.down && elementScrollTopOnEnd($el)) {
                          prevent = true;
                        }
                      } else if (elementScrollTopOnStart($el) && elementScrollTopOnEnd($el)) {
                        if (direction.left && elementScrollLeftOnStart($el) || direction.right && elementScrollLeftOnEnd($el)) {
                          prevent = true;
                        }
                      } else if (directionWithOffset.up && elementScrollTopOnStart($el) || directionWithOffset.down && elementScrollTopOnEnd($el) || directionWithOffset.left && elementScrollLeftOnStart($el) || directionWithOffset.right && elementScrollLeftOnEnd($el)) {
                        prevent = true;
                      }
                      if (prevent) {
                        if (parentScrollableEl) {
                          handle2(parentScrollableEl, true);
                        } else {
                          if (e.cancelable) {
                            e.preventDefault();
                          }
                        }
                      }
                    } else {
                      handle2(parentScrollableEl);
                    }
                  } else {
                    if (e.cancelable) {
                      e.preventDefault();
                    }
                  }
                };
                handle(e.target);
              }
            }
          };
          var onTouchEnd = function onTouchEnd2(e) {
            if (!state.scroll) {
              state.startTouchY = 0;
              state.startTouchX = 0;
            }
          };
          if (typeof window !== "undefined") {
            window.addEventListener("resize", onResize);
          }
          if (typeof document !== "undefined") {
            document.addEventListener("touchstart", onTouchStart);
            document.addEventListener("touchmove", scroll_lock_onTouchMove, {
              passive: false
            });
            document.addEventListener("touchend", onTouchEnd);
          }
          var deprecatedMethods = {
            hide: function hide3(target) {
              throwError('"hide" is deprecated! Use "disablePageScroll" instead. \n https://github.com/FL3NKEY/scroll-lock#disablepagescrollscrollabletarget');
              disablePageScroll2(target);
            },
            show: function show2(target) {
              throwError('"show" is deprecated! Use "enablePageScroll" instead. \n https://github.com/FL3NKEY/scroll-lock#enablepagescrollscrollabletarget');
              enablePageScroll2(target);
            },
            toggle: function toggle(target) {
              throwError('"toggle" is deprecated! Do not use it.');
              if (getScrollState()) {
                disablePageScroll2();
              } else {
                enablePageScroll2(target);
              }
            },
            getState: function getState() {
              throwError('"getState" is deprecated! Use "getScrollState" instead. \n https://github.com/FL3NKEY/scroll-lock#getscrollstate');
              return getScrollState();
            },
            getWidth: function getWidth() {
              throwError('"getWidth" is deprecated! Use "getPageScrollBarWidth" instead. \n https://github.com/FL3NKEY/scroll-lock#getpagescrollbarwidth');
              return getPageScrollBarWidth();
            },
            getCurrentWidth: function getCurrentWidth() {
              throwError('"getCurrentWidth" is deprecated! Use "getCurrentPageScrollBarWidth" instead. \n https://github.com/FL3NKEY/scroll-lock#getcurrentpagescrollbarwidth');
              return getCurrentPageScrollBarWidth();
            },
            setScrollableTargets: function setScrollableTargets(target) {
              throwError('"setScrollableTargets" is deprecated! Use "addScrollableTarget" instead. \n https://github.com/FL3NKEY/scroll-lock#addscrollabletargetscrollabletarget');
              scroll_lock_addScrollableTarget(target);
            },
            setFillGapSelectors: function setFillGapSelectors(selector) {
              throwError('"setFillGapSelectors" is deprecated! Use "addFillGapSelector" instead. \n https://github.com/FL3NKEY/scroll-lock#addfillgapselectorfillgapselector');
              scroll_lock_addFillGapSelector(selector);
            },
            setFillGapTargets: function setFillGapTargets(target) {
              throwError('"setFillGapTargets" is deprecated! Use "addFillGapTarget" instead. \n https://github.com/FL3NKEY/scroll-lock#addfillgaptargetfillgaptarget');
              scroll_lock_addFillGapTarget(target);
            },
            clearQueue: function clearQueue2() {
              throwError('"clearQueue" is deprecated! Use "clearQueueScrollLocks" instead. \n https://github.com/FL3NKEY/scroll-lock#clearqueuescrolllocks');
              clearQueueScrollLocks2();
            }
          };
          var scrollLock = _objectSpread({
            disablePageScroll: disablePageScroll2,
            enablePageScroll: enablePageScroll2,
            getScrollState,
            clearQueueScrollLocks: clearQueueScrollLocks2,
            getTargetScrollBarWidth: scroll_lock_getTargetScrollBarWidth,
            getCurrentTargetScrollBarWidth: scroll_lock_getCurrentTargetScrollBarWidth,
            getPageScrollBarWidth,
            getCurrentPageScrollBarWidth,
            addScrollableSelector: scroll_lock_addScrollableSelector,
            removeScrollableSelector: scroll_lock_removeScrollableSelector,
            addScrollableTarget: scroll_lock_addScrollableTarget,
            removeScrollableTarget: scroll_lock_removeScrollableTarget,
            addLockableSelector: scroll_lock_addLockableSelector,
            addLockableTarget: scroll_lock_addLockableTarget,
            addFillGapSelector: scroll_lock_addFillGapSelector,
            removeFillGapSelector: scroll_lock_removeFillGapSelector,
            addFillGapTarget: scroll_lock_addFillGapTarget,
            removeFillGapTarget: scroll_lock_removeFillGapTarget,
            setFillGapMethod: scroll_lock_setFillGapMethod,
            refillGaps,
            _state: state
          }, deprecatedMethods);
          var scroll_lock = __webpack_exports__["default"] = scrollLock;
        }
      ])["default"];
    });
  }
});

// node_modules/@stitches/core/dist/index.mjs
var t = "colors";
var n = "sizes";
var r = "space";
var i = { gap: r, gridGap: r, columnGap: r, gridColumnGap: r, rowGap: r, gridRowGap: r, inset: r, insetBlock: r, insetBlockEnd: r, insetBlockStart: r, insetInline: r, insetInlineEnd: r, insetInlineStart: r, margin: r, marginTop: r, marginRight: r, marginBottom: r, marginLeft: r, marginBlock: r, marginBlockEnd: r, marginBlockStart: r, marginInline: r, marginInlineEnd: r, marginInlineStart: r, padding: r, paddingTop: r, paddingRight: r, paddingBottom: r, paddingLeft: r, paddingBlock: r, paddingBlockEnd: r, paddingBlockStart: r, paddingInline: r, paddingInlineEnd: r, paddingInlineStart: r, top: r, right: r, bottom: r, left: r, scrollMargin: r, scrollMarginTop: r, scrollMarginRight: r, scrollMarginBottom: r, scrollMarginLeft: r, scrollMarginX: r, scrollMarginY: r, scrollMarginBlock: r, scrollMarginBlockEnd: r, scrollMarginBlockStart: r, scrollMarginInline: r, scrollMarginInlineEnd: r, scrollMarginInlineStart: r, scrollPadding: r, scrollPaddingTop: r, scrollPaddingRight: r, scrollPaddingBottom: r, scrollPaddingLeft: r, scrollPaddingX: r, scrollPaddingY: r, scrollPaddingBlock: r, scrollPaddingBlockEnd: r, scrollPaddingBlockStart: r, scrollPaddingInline: r, scrollPaddingInlineEnd: r, scrollPaddingInlineStart: r, fontSize: "fontSizes", background: t, backgroundColor: t, backgroundImage: t, borderImage: t, border: t, borderBlock: t, borderBlockEnd: t, borderBlockStart: t, borderBottom: t, borderBottomColor: t, borderColor: t, borderInline: t, borderInlineEnd: t, borderInlineStart: t, borderLeft: t, borderLeftColor: t, borderRight: t, borderRightColor: t, borderTop: t, borderTopColor: t, caretColor: t, color: t, columnRuleColor: t, fill: t, outline: t, outlineColor: t, stroke: t, textDecorationColor: t, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: n, minBlockSize: n, maxBlockSize: n, inlineSize: n, minInlineSize: n, maxInlineSize: n, width: n, minWidth: n, maxWidth: n, height: n, minHeight: n, maxHeight: n, flexBasis: n, gridTemplateColumns: n, gridTemplateRows: n, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" };
var o = (e, t2) => "function" == typeof t2 ? { "()": Function.prototype.toString.call(t2) } : t2;
var l = () => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t2, n2, ...r2) => {
    const i2 = ((e2) => JSON.stringify(e2, o))(t2);
    return i2 in e ? e[i2] : e[i2] = n2(t2, ...r2);
  };
};
var s = Symbol.for("sxs.internal");
var a = (e, t2) => Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2));
var c = (e) => {
  for (const t2 in e)
    return true;
  return false;
};
var { hasOwnProperty: d } = Object.prototype;
var g = (e) => e.includes("-") ? e : e.replace(/[A-Z]/g, (e2) => "-" + e2.toLowerCase());
var p = /\s+(?![^()]*\))/;
var u = (e) => (t2) => e(..."string" == typeof t2 ? String(t2).split(p) : [t2]);
var h = { appearance: (e) => ({ WebkitAppearance: e, appearance: e }), backfaceVisibility: (e) => ({ WebkitBackfaceVisibility: e, backfaceVisibility: e }), backdropFilter: (e) => ({ WebkitBackdropFilter: e, backdropFilter: e }), backgroundClip: (e) => ({ WebkitBackgroundClip: e, backgroundClip: e }), boxDecorationBreak: (e) => ({ WebkitBoxDecorationBreak: e, boxDecorationBreak: e }), clipPath: (e) => ({ WebkitClipPath: e, clipPath: e }), content: (e) => ({ content: e.includes('"') || e.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e) ? e : `"${e}"` }), hyphens: (e) => ({ WebkitHyphens: e, hyphens: e }), maskImage: (e) => ({ WebkitMaskImage: e, maskImage: e }), maskSize: (e) => ({ WebkitMaskSize: e, maskSize: e }), tabSize: (e) => ({ MozTabSize: e, tabSize: e }), textSizeAdjust: (e) => ({ WebkitTextSizeAdjust: e, textSizeAdjust: e }), userSelect: (e) => ({ WebkitUserSelect: e, userSelect: e }), marginBlock: u((e, t2) => ({ marginBlockStart: e, marginBlockEnd: t2 || e })), marginInline: u((e, t2) => ({ marginInlineStart: e, marginInlineEnd: t2 || e })), maxSize: u((e, t2) => ({ maxBlockSize: e, maxInlineSize: t2 || e })), minSize: u((e, t2) => ({ minBlockSize: e, minInlineSize: t2 || e })), paddingBlock: u((e, t2) => ({ paddingBlockStart: e, paddingBlockEnd: t2 || e })), paddingInline: u((e, t2) => ({ paddingInlineStart: e, paddingInlineEnd: t2 || e })) };
var f = /([\d.]+)([^]*)/;
var m = (e, t2) => e.length ? e.reduce((e2, n2) => (e2.push(...t2.map((e3) => e3.includes("&") ? e3.replace(/&/g, /[ +>|~]/.test(n2) && /&.*&/.test(e3) ? `:is(${n2})` : n2) : n2 + " " + e3)), e2), []) : t2;
var b = (e, t2) => e in S && "string" == typeof t2 ? t2.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t3, n2, r2, i2) => n2 + ("stretch" === r2 ? `-moz-available${i2};${g(e)}:${n2}-webkit-fill-available` : `-moz-fit-content${i2};${g(e)}:${n2}fit-content`) + i2) : String(t2);
var S = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 };
var k = (e) => e ? e + "-" : "";
var y = (e, t2, n2) => e.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (e2, r2, i2, o2, l2) => "$" == o2 == !!i2 ? e2 : (r2 || "--" == o2 ? "calc(" : "") + "var(--" + ("$" === o2 ? k(t2) + (l2.includes("$") ? "" : k(n2)) + l2.replace(/\$/g, "-") : l2) + ")" + (r2 || "--" == o2 ? "*" + (r2 || "") + (i2 || "1") + ")" : ""));
var B = /\s*,\s*(?![^()]*\))/;
var $ = Object.prototype.toString;
var x = (e, t2, n2, r2, i2) => {
  let o2, l2, s2;
  const a2 = (e2, t3, n3) => {
    let c2, d2;
    const p2 = (e3) => {
      for (c2 in e3) {
        const x2 = 64 === c2.charCodeAt(0), z2 = x2 && Array.isArray(e3[c2]) ? e3[c2] : [e3[c2]];
        for (d2 of z2) {
          const e4 = /[A-Z]/.test(S2 = c2) ? S2 : S2.replace(/-[^]/g, (e5) => e5[1].toUpperCase()), z3 = "object" == typeof d2 && d2 && d2.toString === $ && (!r2.utils[e4] || !t3.length);
          if (e4 in r2.utils && !z3) {
            const t4 = r2.utils[e4];
            if (t4 !== l2) {
              l2 = t4, p2(t4(d2)), l2 = null;
              continue;
            }
          } else if (e4 in h) {
            const t4 = h[e4];
            if (t4 !== s2) {
              s2 = t4, p2(t4(d2)), s2 = null;
              continue;
            }
          }
          if (x2 && (u2 = c2.slice(1) in r2.media ? "@media " + r2.media[c2.slice(1)] : c2, c2 = u2.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (e5, t4, n4, r3, i3, o3) => {
            const l3 = f.test(t4), s3 = 0.0625 * (l3 ? -1 : 1), [a3, c3] = l3 ? [r3, t4] : [t4, r3];
            return "(" + ("=" === n4[0] ? "" : ">" === n4[0] === l3 ? "max-" : "min-") + a3 + ":" + ("=" !== n4[0] && 1 === n4.length ? c3.replace(f, (e6, t5, r4) => Number(t5) + s3 * (">" === n4 ? 1 : -1) + r4) : c3) + (i3 ? ") and (" + (">" === i3[0] ? "min-" : "max-") + a3 + ":" + (1 === i3.length ? o3.replace(f, (e6, t5, n5) => Number(t5) + s3 * (">" === i3 ? -1 : 1) + n5) : o3) : "") + ")";
          })), z3) {
            const e5 = x2 ? n3.concat(c2) : [...n3], r3 = x2 ? [...t3] : m(t3, c2.split(B));
            void 0 !== o2 && i2(I(...o2)), o2 = void 0, a2(d2, r3, e5);
          } else
            void 0 === o2 && (o2 = [[], t3, n3]), c2 = x2 || 36 !== c2.charCodeAt(0) ? c2 : `--${k(r2.prefix)}${c2.slice(1).replace(/\$/g, "-")}`, d2 = z3 ? d2 : "number" == typeof d2 ? d2 && e4 in R ? String(d2) + "px" : String(d2) : y(b(e4, null == d2 ? "" : d2), r2.prefix, r2.themeMap[e4]), o2[0].push(`${x2 ? `${c2} ` : `${g(c2)}:`}${d2}`);
        }
      }
      var u2, S2;
    };
    p2(e2), void 0 !== o2 && i2(I(...o2)), o2 = void 0;
  };
  a2(e, t2, n2);
};
var I = (e, t2, n2) => `${n2.map((e2) => `${e2}{`).join("")}${t2.length ? `${t2.join(",")}{` : ""}${e.join(";")}${t2.length ? "}" : ""}${Array(n2.length ? n2.length + 1 : 0).join("}")}`;
var R = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 };
var z = (e) => String.fromCharCode(e + (e > 25 ? 39 : 97));
var W = (e) => ((e2) => {
  let t2, n2 = "";
  for (t2 = Math.abs(e2); t2 > 52; t2 = t2 / 52 | 0)
    n2 = z(t2 % 52) + n2;
  return z(t2 % 52) + n2;
})(((e2, t2) => {
  let n2 = t2.length;
  for (; n2; )
    e2 = 33 * e2 ^ t2.charCodeAt(--n2);
  return e2;
})(5381, JSON.stringify(e)) >>> 0);
var j = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"];
var E = (e) => {
  if (e.href && !e.href.startsWith(location.origin))
    return false;
  try {
    return !!e.cssRules;
  } catch (e2) {
    return false;
  }
};
var T = (e) => {
  let t2;
  const n2 = () => {
    const { cssRules: e2 } = t2.sheet;
    return [].map.call(e2, (n3, r3) => {
      const { cssText: i2 } = n3;
      let o2 = "";
      if (i2.startsWith("--sxs"))
        return "";
      if (e2[r3 - 1] && (o2 = e2[r3 - 1].cssText).startsWith("--sxs")) {
        if (!n3.cssRules.length)
          return "";
        for (const e3 in t2.rules)
          if (t2.rules[e3].group === n3)
            return `--sxs{--sxs:${[...t2.rules[e3].cache].join(" ")}}${i2}`;
        return n3.cssRules.length ? `${o2}${i2}` : "";
      }
      return i2;
    }).join("");
  }, r2 = () => {
    if (t2) {
      const { rules: e2, sheet: n3 } = t2;
      if (!n3.deleteRule) {
        for (; 3 === Object(Object(n3.cssRules)[0]).type; )
          n3.cssRules.splice(0, 1);
        n3.cssRules = [];
      }
      for (const t3 in e2)
        delete e2[t3];
    }
    const i2 = Object(e).styleSheets || [];
    for (const e2 of i2)
      if (E(e2)) {
        for (let i3 = 0, o3 = e2.cssRules; o3[i3]; ++i3) {
          const l3 = Object(o3[i3]);
          if (1 !== l3.type)
            continue;
          const s2 = Object(o3[i3 + 1]);
          if (4 !== s2.type)
            continue;
          ++i3;
          const { cssText: a2 } = l3;
          if (!a2.startsWith("--sxs"))
            continue;
          const c2 = a2.slice(14, -3).trim().split(/\s+/), d2 = j[c2[0]];
          d2 && (t2 || (t2 = { sheet: e2, reset: r2, rules: {}, toString: n2 }), t2.rules[d2] = { group: s2, index: i3, cache: new Set(c2) });
        }
        if (t2)
          break;
      }
    if (!t2) {
      const i3 = (e2, t3) => ({ type: t3, cssRules: [], insertRule(e3, t4) {
        this.cssRules.splice(t4, 0, i3(e3, { import: 3, undefined: 1 }[(e3.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return "@media{}" === e2 ? `@media{${[].map.call(this.cssRules, (e3) => e3.cssText).join("")}}` : e2;
      } });
      t2 = { sheet: e ? (e.head || e).appendChild(document.createElement("style")).sheet : i3("", "text/css"), rules: {}, reset: r2, toString: n2 };
    }
    const { sheet: o2, rules: l2 } = t2;
    for (let e2 = j.length - 1; e2 >= 0; --e2) {
      const t3 = j[e2];
      if (!l2[t3]) {
        const n3 = j[e2 + 1], r3 = l2[n3] ? l2[n3].index : o2.cssRules.length;
        o2.insertRule("@media{}", r3), o2.insertRule(`--sxs{--sxs:${e2}}`, r3), l2[t3] = { group: o2.cssRules[r3 + 1], index: r3, cache: /* @__PURE__ */ new Set([e2]) };
      }
      v(l2[t3]);
    }
  };
  return r2(), t2;
};
var v = (e) => {
  const t2 = e.group;
  let n2 = t2.cssRules.length;
  e.apply = (e2) => {
    try {
      t2.insertRule(e2, n2), ++n2;
    } catch (e3) {
    }
  };
};
var M = Symbol();
var w = l();
var C = (e, t2) => w(e, () => (...n2) => {
  let r2 = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const t3 of n2)
    if (null != t3)
      if (t3[s]) {
        null == r2.type && (r2.type = t3[s].type);
        for (const e2 of t3[s].composers)
          r2.composers.add(e2);
      } else
        t3.constructor !== Object || t3.$$typeof ? null == r2.type && (r2.type = t3) : r2.composers.add(P(t3, e));
  return null == r2.type && (r2.type = "span"), r2.composers.size || r2.composers.add(["PJLV", {}, [], [], {}, []]), L(e, r2, t2);
});
var P = ({ variants: e, compoundVariants: t2, defaultVariants: n2, ...r2 }, i2) => {
  const o2 = `${k(i2.prefix)}c-${W(r2)}`, l2 = [], s2 = [], a2 = /* @__PURE__ */ Object.create(null), g2 = [];
  for (const e2 in n2)
    a2[e2] = String(n2[e2]);
  if ("object" == typeof e && e)
    for (const t3 in e) {
      p2 = a2, u2 = t3, d.call(p2, u2) || (a2[t3] = "undefined");
      const n3 = e[t3];
      for (const e2 in n3) {
        const r3 = { [t3]: String(e2) };
        "undefined" === String(e2) && g2.push(t3);
        const i3 = n3[e2], o3 = [r3, i3, !c(i3)];
        l2.push(o3);
      }
    }
  var p2, u2;
  if ("object" == typeof t2 && t2)
    for (const e2 of t2) {
      let { css: t3, ...n3 } = e2;
      t3 = "object" == typeof t3 && t3 || {};
      for (const e3 in n3)
        n3[e3] = String(n3[e3]);
      const r3 = [n3, t3, !c(t3)];
      s2.push(r3);
    }
  return [o2, r2, l2, s2, a2, g2];
};
var L = (e, t2, n2) => {
  const [r2, i2, o2, l2] = O(t2.composers), c2 = "function" == typeof t2.type || t2.type.$$typeof ? ((e2) => {
    function t3() {
      for (let n3 = 0; n3 < t3[M].length; n3++) {
        const [r3, i3] = t3[M][n3];
        e2.rules[r3].apply(i3);
      }
      return t3[M] = [], null;
    }
    return t3[M] = [], t3.rules = {}, j.forEach((e3) => t3.rules[e3] = { apply: (n3) => t3[M].push([e3, n3]) }), t3;
  })(n2) : null, d2 = (c2 || n2).rules, g2 = `.${r2}${i2.length > 1 ? `:where(.${i2.slice(1).join(".")})` : ""}`, p2 = (s2) => {
    s2 = "object" == typeof s2 && s2 || D;
    const { css: a2, ...p3 } = s2, u2 = {};
    for (const e2 in o2)
      if (delete p3[e2], e2 in s2) {
        let t3 = s2[e2];
        "object" == typeof t3 && t3 ? u2[e2] = { "@initial": o2[e2], ...t3 } : (t3 = String(t3), u2[e2] = "undefined" !== t3 || l2.has(e2) ? t3 : o2[e2]);
      } else
        u2[e2] = o2[e2];
    const h2 = /* @__PURE__ */ new Set([...i2]);
    for (const [r3, i3, o3, l3] of t2.composers) {
      n2.rules.styled.cache.has(r3) || (n2.rules.styled.cache.add(r3), x(i3, [`.${r3}`], [], e, (e2) => {
        d2.styled.apply(e2);
      }));
      const t3 = A(o3, u2, e.media), s3 = A(l3, u2, e.media, true);
      for (const i4 of t3)
        if (void 0 !== i4)
          for (const [t4, o4, l4] of i4) {
            const i5 = `${r3}-${W(o4)}-${t4}`;
            h2.add(i5);
            const s4 = (l4 ? n2.rules.resonevar : n2.rules.onevar).cache, a3 = l4 ? d2.resonevar : d2.onevar;
            s4.has(i5) || (s4.add(i5), x(o4, [`.${i5}`], [], e, (e2) => {
              a3.apply(e2);
            }));
          }
      for (const t4 of s3)
        if (void 0 !== t4)
          for (const [i4, o4] of t4) {
            const t5 = `${r3}-${W(o4)}-${i4}`;
            h2.add(t5), n2.rules.allvar.cache.has(t5) || (n2.rules.allvar.cache.add(t5), x(o4, [`.${t5}`], [], e, (e2) => {
              d2.allvar.apply(e2);
            }));
          }
    }
    if ("object" == typeof a2 && a2) {
      const t3 = `${r2}-i${W(a2)}-css`;
      h2.add(t3), n2.rules.inline.cache.has(t3) || (n2.rules.inline.cache.add(t3), x(a2, [`.${t3}`], [], e, (e2) => {
        d2.inline.apply(e2);
      }));
    }
    for (const e2 of String(s2.className || "").trim().split(/\s+/))
      e2 && h2.add(e2);
    const f2 = p3.className = [...h2].join(" ");
    return { type: t2.type, className: f2, selector: g2, props: p3, toString: () => f2, deferredInjector: c2 };
  };
  return a(p2, { className: r2, selector: g2, [s]: t2, toString: () => (n2.rules.styled.cache.has(r2) || p2(), r2) });
};
var O = (e) => {
  let t2 = "";
  const n2 = [], r2 = {}, i2 = [];
  for (const [o2, , , , l2, s2] of e) {
    "" === t2 && (t2 = o2), n2.push(o2), i2.push(...s2);
    for (const e2 in l2) {
      const t3 = l2[e2];
      (void 0 === r2[e2] || "undefined" !== t3 || s2.includes(t3)) && (r2[e2] = t3);
    }
  }
  return [t2, n2, r2, new Set(i2)];
};
var A = (e, t2, n2, r2) => {
  const i2 = [];
  e:
    for (let [o2, l2, s2] of e) {
      if (s2)
        continue;
      let e2, a2 = 0, c2 = false;
      for (e2 in o2) {
        const r3 = o2[e2];
        let i3 = t2[e2];
        if (i3 !== r3) {
          if ("object" != typeof i3 || !i3)
            continue e;
          {
            let e3, t3, o3 = 0;
            for (const l3 in i3) {
              if (r3 === String(i3[l3])) {
                if ("@initial" !== l3) {
                  const e4 = l3.slice(1);
                  (t3 = t3 || []).push(e4 in n2 ? n2[e4] : l3.replace(/^@media ?/, "")), c2 = true;
                }
                a2 += o3, e3 = true;
              }
              ++o3;
            }
            if (t3 && t3.length && (l2 = { ["@media " + t3.join(", ")]: l2 }), !e3)
              continue e;
          }
        }
      }
      (i2[a2] = i2[a2] || []).push([r2 ? "cv" : `${e2}-${o2[e2]}`, l2, c2]);
    }
  return i2;
};
var D = {};
var H = l();
var N = (e, t2) => H(e, () => (...n2) => {
  const r2 = () => {
    for (let r3 of n2) {
      r3 = "object" == typeof r3 && r3 || {};
      let n3 = W(r3);
      if (!t2.rules.global.cache.has(n3)) {
        if (t2.rules.global.cache.add(n3), "@import" in r3) {
          let e2 = [].indexOf.call(t2.sheet.cssRules, t2.rules.themed.group) - 1;
          for (let n4 of [].concat(r3["@import"]))
            n4 = n4.includes('"') || n4.includes("'") ? n4 : `"${n4}"`, t2.sheet.insertRule(`@import ${n4};`, e2++);
          delete r3["@import"];
        }
        x(r3, [], [], e, (e2) => {
          t2.rules.global.apply(e2);
        });
      }
    }
    return "";
  };
  return a(r2, { toString: r2 });
});
var V = l();
var G = (e, t2) => V(e, () => (n2) => {
  const r2 = `${k(e.prefix)}k-${W(n2)}`, i2 = () => {
    if (!t2.rules.global.cache.has(r2)) {
      t2.rules.global.cache.add(r2);
      const i3 = [];
      x(n2, [], [], e, (e2) => i3.push(e2));
      const o2 = `@keyframes ${r2}{${i3.join("")}}`;
      t2.rules.global.apply(o2);
    }
    return r2;
  };
  return a(i2, { get name() {
    return i2();
  }, toString: i2 });
});
var F = class {
  constructor(e, t2, n2, r2) {
    this.token = null == e ? "" : String(e), this.value = null == t2 ? "" : String(t2), this.scale = null == n2 ? "" : String(n2), this.prefix = null == r2 ? "" : String(r2);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + k(this.prefix) + k(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
};
var J = l();
var U = (e, t2) => J(e, () => (n2, r2) => {
  r2 = "object" == typeof n2 && n2 || Object(r2);
  const i2 = `.${n2 = (n2 = "string" == typeof n2 ? n2 : "") || `${k(e.prefix)}t-${W(r2)}`}`, o2 = {}, l2 = [];
  for (const t3 in r2) {
    o2[t3] = {};
    for (const n3 in r2[t3]) {
      const i3 = `--${k(e.prefix)}${t3}-${n3}`, s3 = y(String(r2[t3][n3]), e.prefix, t3);
      o2[t3][n3] = new F(n3, s3, t3, e.prefix), l2.push(`${i3}:${s3}`);
    }
  }
  const s2 = () => {
    if (l2.length && !t2.rules.themed.cache.has(n2)) {
      t2.rules.themed.cache.add(n2);
      const i3 = `${r2 === e.theme ? ":root," : ""}.${n2}{${l2.join(";")}}`;
      t2.rules.themed.apply(i3);
    }
    return n2;
  };
  return { ...o2, get className() {
    return s2();
  }, selector: i2, toString: s2 };
});
var Z = l();
var X = (e) => {
  let t2 = false;
  const n2 = Z(e, (e2) => {
    t2 = true;
    const n3 = "prefix" in (e2 = "object" == typeof e2 && e2 || {}) ? String(e2.prefix) : "", r2 = "object" == typeof e2.media && e2.media || {}, o2 = "object" == typeof e2.root ? e2.root || null : globalThis.document || null, l2 = "object" == typeof e2.theme && e2.theme || {}, s2 = { prefix: n3, media: r2, theme: l2, themeMap: "object" == typeof e2.themeMap && e2.themeMap || { ...i }, utils: "object" == typeof e2.utils && e2.utils || {} }, a2 = T(o2), c2 = { css: C(s2, a2), globalCss: N(s2, a2), keyframes: G(s2, a2), createTheme: U(s2, a2), reset() {
      a2.reset(), c2.theme.toString();
    }, theme: {}, sheet: a2, config: s2, prefix: n3, getCssText: a2.toString, toString: a2.toString };
    return String(c2.theme = c2.createTheme(l2)), c2;
  });
  return t2 || n2.reset(), n2;
};

// node_modules/@hope-ui/solid/dist/index.mjs
var import_lodash = __toESM(require_lodash(), 1);

// node_modules/solid-transition-group/dist/solid-transition-group.js
function nextFrame(fn) {
  requestAnimationFrame(() => {
    requestAnimationFrame(fn);
  });
}
var Transition = (props) => {
  let el;
  let first = true;
  const [s1, set1] = createSignal();
  const [s2, set2] = createSignal();
  const resolved = children(() => props.children);
  const name = props.name || "s";
  props = mergeProps({
    name,
    enterActiveClass: name + "-enter-active",
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    exitActiveClass: name + "-exit-active",
    exitClass: name + "-exit",
    exitToClass: name + "-exit-to"
  }, props);
  const {
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onBeforeExit,
    onExit,
    onAfterExit
  } = props;
  function enterTransition(el2, prev) {
    if (!first || props.appear) {
      let endTransition = function(e) {
        if (el2 && (!e || e.target === el2)) {
          el2.removeEventListener("transitionend", endTransition);
          el2.removeEventListener("animationend", endTransition);
          el2.classList.remove(...enterActiveClasses);
          el2.classList.remove(...enterToClasses);
          batch(() => {
            s1() !== el2 && set1(el2);
            s2() === el2 && set2(void 0);
          });
          onAfterEnter && onAfterEnter(el2);
          if (props.mode === "inout")
            exitTransition(el2, prev);
        }
      };
      const enterClasses = props.enterClass.split(" ");
      const enterActiveClasses = props.enterActiveClass.split(" ");
      const enterToClasses = props.enterToClass.split(" ");
      onBeforeEnter && onBeforeEnter(el2);
      el2.classList.add(...enterClasses);
      el2.classList.add(...enterActiveClasses);
      nextFrame(() => {
        el2.classList.remove(...enterClasses);
        el2.classList.add(...enterToClasses);
        onEnter && onEnter(el2, () => endTransition());
        if (!onEnter || onEnter.length < 2) {
          el2.addEventListener("transitionend", endTransition);
          el2.addEventListener("animationend", endTransition);
        }
      });
    }
    prev && !props.mode ? set2(el2) : set1(el2);
  }
  function exitTransition(el2, prev) {
    const exitClasses = props.exitClass.split(" ");
    const exitActiveClasses = props.exitActiveClass.split(" ");
    const exitToClasses = props.exitToClass.split(" ");
    if (!prev.parentNode)
      return endTransition();
    onBeforeExit && onBeforeExit(prev);
    prev.classList.add(...exitClasses);
    prev.classList.add(...exitActiveClasses);
    nextFrame(() => {
      prev.classList.remove(...exitClasses);
      prev.classList.add(...exitToClasses);
    });
    onExit && onExit(prev, () => endTransition());
    if (!onExit || onExit.length < 2) {
      prev.addEventListener("transitionend", endTransition);
      prev.addEventListener("animationend", endTransition);
    }
    function endTransition(e) {
      if (!e || e.target === prev) {
        prev.removeEventListener("transitionend", endTransition);
        prev.removeEventListener("animationend", endTransition);
        prev.classList.remove(...exitActiveClasses);
        prev.classList.remove(...exitToClasses);
        s1() === prev && set1(void 0);
        onAfterExit && onAfterExit(prev);
        if (props.mode === "outin")
          enterTransition(el2, prev);
      }
    }
  }
  createComputed((prev) => {
    el = resolved();
    while (typeof el === "function")
      el = el();
    return untrack(() => {
      if (el && el !== prev) {
        if (props.mode !== "outin")
          enterTransition(el, prev);
        else if (first)
          set1(el);
      }
      if (prev && prev !== el && props.mode !== "inout")
        exitTransition(el, prev);
      first = false;
      return el;
    });
  });
  return [s1, s2];
};
function getRect(element) {
  const {
    top,
    bottom,
    left,
    right,
    width,
    height
  } = element.getBoundingClientRect();
  const parentRect = element.parentNode.getBoundingClientRect();
  return {
    top: top - parentRect.top,
    bottom,
    left: left - parentRect.left,
    right,
    width,
    height
  };
}
var TransitionGroup = (props) => {
  const resolved = children(() => props.children);
  const name = props.name || "s";
  props = mergeProps({
    name,
    enterActiveClass: name + "-enter-active",
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    exitActiveClass: name + "-exit-active",
    exitClass: name + "-exit",
    exitToClass: name + "-exit-to",
    moveClass: name + "-move"
  }, props);
  const {
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onBeforeExit,
    onExit,
    onAfterExit
  } = props;
  const [combined, setCombined] = createSignal();
  let p2 = [];
  let first = true;
  createComputed(() => {
    const c2 = resolved();
    const comb = [...c2];
    const next = new Set(c2);
    const prev = new Set(p2);
    const enterClasses = props.enterClass.split(" ");
    const enterActiveClasses = props.enterActiveClass.split(" ");
    const enterToClasses = props.enterToClass.split(" ");
    const exitClasses = props.exitClass.split(" ");
    const exitActiveClasses = props.exitActiveClass.split(" ");
    const exitToClasses = props.exitToClass.split(" ");
    for (let i2 = 0; i2 < c2.length; i2++) {
      const el = c2[i2];
      if (!first && !prev.has(el)) {
        let endTransition = function(e) {
          if (el && (!e || e.target === el)) {
            el.removeEventListener("transitionend", endTransition);
            el.removeEventListener("animationend", endTransition);
            el.classList.remove(...enterActiveClasses);
            el.classList.remove(...enterToClasses);
            onAfterEnter && onAfterEnter(el);
          }
        };
        onBeforeEnter && onBeforeEnter(el);
        el.classList.add(...enterClasses);
        el.classList.add(...enterActiveClasses);
        nextFrame(() => {
          el.classList.remove(...enterClasses);
          el.classList.add(...enterToClasses);
          onEnter && onEnter(el, () => endTransition());
          if (!onEnter || onEnter.length < 2) {
            el.addEventListener("transitionend", endTransition);
            el.addEventListener("animationend", endTransition);
          }
        });
      }
    }
    for (let i2 = 0; i2 < p2.length; i2++) {
      const old = p2[i2];
      if (!next.has(old) && old.parentNode) {
        let endTransition = function(e) {
          if (!e || e.target === old) {
            old.removeEventListener("transitionend", endTransition);
            old.removeEventListener("animationend", endTransition);
            old.classList.remove(...exitActiveClasses);
            old.classList.remove(...exitToClasses);
            onAfterExit && onAfterExit(old);
            p2 = p2.filter((i3) => i3 !== old);
            setCombined(p2);
          }
        };
        comb.splice(i2, 0, old);
        onBeforeExit && onBeforeExit(old);
        old.classList.add(...exitClasses);
        old.classList.add(...exitActiveClasses);
        nextFrame(() => {
          old.classList.remove(...exitClasses);
          old.classList.add(...exitToClasses);
        });
        onExit && onExit(old, () => endTransition());
        if (!onExit || onExit.length < 2) {
          old.addEventListener("transitionend", endTransition);
          old.addEventListener("animationend", endTransition);
        }
      }
    }
    p2 = comb;
    setCombined(comb);
  });
  createEffect((nodes) => {
    const c2 = combined();
    c2.forEach((child) => {
      let n2;
      if (!(n2 = nodes.get(child))) {
        nodes.set(child, n2 = {
          pos: getRect(child),
          new: !first
        });
      } else if (n2.new) {
        n2.new = false;
        n2.newPos = getRect(child);
      }
      if (n2.new) {
        child.addEventListener("transitionend", () => {
          n2.new = false;
          child.parentNode && (n2.newPos = getRect(child));
        }, {
          once: true
        });
      }
      n2.newPos && (n2.pos = n2.newPos);
      n2.newPos = getRect(child);
    });
    if (first) {
      first = false;
      return nodes;
    }
    c2.forEach((child) => {
      const c3 = nodes.get(child);
      const oldPos = c3.pos;
      const newPos = c3.newPos;
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        c3.moved = true;
        const s2 = child.style;
        s2.transform = `translate(${dx}px,${dy}px)`;
        s2.transitionDuration = "0s";
      }
    });
    document.body.offsetHeight;
    c2.forEach((child) => {
      const c3 = nodes.get(child);
      if (c3.moved) {
        let endTransition = function(e) {
          if (e && e.target !== child || !child.parentNode)
            return;
          if (!e || /transform$/.test(e.propertyName)) {
            child.removeEventListener("transitionend", endTransition);
            child.classList.remove(...moveClasses);
          }
        };
        c3.moved = false;
        const s2 = child.style;
        const moveClasses = props.moveClass.split(" ");
        child.classList.add(...moveClasses);
        s2.transform = s2.transitionDuration = "";
        child.addEventListener("transitionend", endTransition);
      }
    });
    return nodes;
  }, /* @__PURE__ */ new Map());
  return combined;
};

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scope: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
  return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  var nodeRootHost = getRootNode(node).host;
  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
  if (!displayCheck || displayCheck === "full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (nodeIsAttached) {
      return !node.getClientRects().length;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scope;
    var element = isScope ? item.scope : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

// node_modules/focus-trap/dist/focus-trap.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var activeFocusTraps = function() {
  var trapQueue = [];
  return {
    activateTrap: function activateTrap(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }
      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
}();
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e) {
  return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
};
var isTabEvent = function isTabEvent2(e) {
  return e.key === "Tab" || e.keyCode === 9;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i2) {
    if (fn(value)) {
      idx = i2;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var config2 = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true
  }, userOptions);
  var state = {
    containers: [],
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    delayInitialFocusTimer: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config2[configOptionName || optionName];
  };
  var containersContain = function containersContain2(element) {
    return !!(element && state.containers.some(function(container) {
      return container.contains(element);
    }));
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config2[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0) {
      if (containersContain(doc.activeElement)) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.tabbableGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container);
      var focusableNodes = focusable(container);
      if (tabbableNodes.length > 0) {
        return {
          container,
          firstTabbableNode: tabbableNodes[0],
          lastTabbableNode: tabbableNodes[tabbableNodes.length - 1],
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = focusableNodes.findIndex(function(n2) {
              return n2 === node;
            });
            if (forward) {
              return focusableNodes.slice(nodeIdx + 1).find(function(n2) {
                return isTabbable(n2);
              });
            }
            return focusableNodes.slice(0, nodeIdx).reverse().find(function(n2) {
              return isTabbable(n2);
            });
          }
        };
      }
      return void 0;
    }).filter(function(group) {
      return !!group;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config2.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var checkPointerDown = function checkPointerDown2(e) {
    var target = getActualTarget(e);
    if (containersContain(target)) {
      return;
    }
    if (valueOrHandler(config2.clickOutsideDeactivates, e)) {
      trap.deactivate({
        returnFocus: config2.returnFocusOnDeactivate && !isFocusable(target)
      });
      return;
    }
    if (valueOrHandler(config2.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(e) {
    var target = getActualTarget(e);
    var targetContained = containersContain(target);
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      e.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };
  var checkTab = function checkTab2(e) {
    var target = getActualTarget(e);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findIndex(state.tabbableGroups, function(_ref) {
        var container = _ref.container;
        return container.contains(target);
      });
      var containerGroup = containerIndex >= 0 ? state.tabbableGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (e.shiftKey) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (e.shiftKey) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    if (destinationNode) {
      e.preventDefault();
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(e) {
    if (isEscapeEvent(e) && valueOrHandler(config2.escapeDeactivates, e) !== false) {
      e.preventDefault();
      trap.deactivate();
      return;
    }
    if (isTabEvent(e)) {
      checkTab(e);
      return;
    }
  };
  var checkClick = function checkClick2(e) {
    if (valueOrHandler(config2.clickOutsideDeactivates, e)) {
      return;
    }
    var target = getActualTarget(e);
    if (containersContain(target)) {
      return;
    }
    if (valueOrHandler(config2.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trap);
    state.delayInitialFocusTimer = config2.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  trap = {
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      if (onActivate) {
        onActivate();
      }
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        if (onPostActivate) {
          onPostActivate();
        }
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trap);
      var onDeactivate = getOption(deactivateOptions, "onDeactivate");
      var onPostDeactivate = getOption(deactivateOptions, "onPostDeactivate");
      var checkCanReturnFocus = getOption(deactivateOptions, "checkCanReturnFocus");
      if (onDeactivate) {
        onDeactivate();
      }
      var returnFocus = getOption(deactivateOptions, "returnFocus", "returnFocusOnDeactivate");
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          if (onPostDeactivate) {
            onPostDeactivate();
          }
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause() {
      if (state.paused || !state.active) {
        return this;
      }
      state.paused = true;
      removeListeners();
      return this;
    },
    unpause: function unpause() {
      if (!state.paused || !state.active) {
        return this;
      }
      state.paused = false;
      updateTabbableNodes();
      addListeners();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};

// node_modules/@hope-ui/solid/dist/index.mjs
var import_scroll_lock = __toESM(require_scroll_lock(), 1);

// node_modules/@floating-ui/core/dist/floating-ui.core.esm.development.js
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  {
    if (platform2 == null) {
      console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
    }
    if (middleware.filter((_ref) => {
      let {
        name
      } = _ref;
      return name === "autoPlacement" || name === "flip";
    }).length > 1) {
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`", "middleware detected. This will lead to an infinite loop. Ensure only", "one of either has been passed to the `middleware` array."].join(" "));
    }
  }
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let _debug_loop_count_ = 0;
  for (let i2 = 0; i2 < middleware.length; i2++) {
    {
      _debug_loop_count_++;
      if (_debug_loop_count_ > 100) {
        throw new Error(["Floating UI: The middleware lifecycle appears to be", "running in an infinite loop. This is usually caused by a `reset`", "continually being returned without a break condition."].join(" "));
      }
    }
    const {
      name,
      fn
    } = middleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset) {
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding2) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding2
  };
}
function getSideObjectFromPadding(padding2) {
  return typeof padding2 !== "number" ? expandPaddingObject(padding2) : {
    top: padding2,
    right: padding2,
    bottom: padding2,
    left: padding2
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding: padding2 = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding2);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? {
      ...rects.floating,
      x: x2,
      y: y2
    } : rects.reference,
    offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding: padding2 = 0
    } = options != null ? options : {};
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      {
        console.warn("Floating UI: No `element` was passed to the `arrow` middleware.");
      }
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding2);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min3 = paddingObject[minProp];
    const max3 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min3, center, max3);
    return {
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
var sides = ["top", "right", "bottom", "left"];
var allPlacements = sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$map$so;
            const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(_temp) {
  let {
    strategy = "referenceHidden",
    ...detectOverflowOptions
  } = _temp === void 0 ? {} : _temp;
  return {
    name: "hide",
    async fn(middlewareArguments) {
      const {
        rects
      } = middlewareArguments;
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(middlewareArguments, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(middlewareArguments, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
function convertValueToCoords(placement, rects, value, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value({
    ...rects,
    placement
  }) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        platform: platform2,
        elements
      } = middlewareArguments;
      const diffCoords = convertValueToCoords(placement, rects, value, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(middlewareArguments) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = middlewareArguments;
      const {
        apply,
        ...detectOverflowOptions
      } = options;
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const xMin = max(overflow.left, 0);
      const xMax = max(overflow.right, 0);
      const yMin = max(overflow.top, 0);
      const yMax = max(overflow.bottom, 0);
      const dimensions = {
        height: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),
        width: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])
      };
      const prevDimensions = await platform2.getDimensions(elements.floating);
      apply == null ? void 0 : apply({
        ...dimensions,
        ...rects
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
var inline = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "inline",
    options,
    async fn(middlewareArguments) {
      var _await$platform$getCl;
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = middlewareArguments;
      const {
        padding: padding2 = 2,
        x: x2,
        y: y2
      } = options;
      const fallback = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: rects.reference,
        offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
        strategy
      }) : rects.reference);
      const clientRects = (_await$platform$getCl = await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];
      const paddingObject = getSideObjectFromPadding(padding2);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y2 != null) {
          var _clientRects$find;
          return (_clientRects$find = clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;
        }
        if (clientRects.length >= 2) {
          if (getMainAxisFromPlacement(placement) === "x") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === "top";
            const top2 = firstRect.top;
            const bottom2 = lastRect.bottom;
            const left2 = isTop ? firstRect.left : lastRect.left;
            const right2 = isTop ? firstRect.right : lastRect.right;
            const width2 = right2 - left2;
            const height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left";
          const maxRight = max(...clientRects.map((rect) => rect.right));
          const minLeft = min(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.development.js
function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css2 = getComputedStyle$1(element);
  return css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].includes(css2.willChange) || isFirefox && css2.willChange === "filter" || isFirefox && (css2.filter ? css2.filter !== "none" : false);
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  const win = isElement(element) ? getWindow(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x2 = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y2 = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(
    element,
    isOffsetParentAnElement && isScaled(offsetParent),
    strategy === "fixed"
  );
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  if (isHTMLElement(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (["html", "body", "#document"].includes(getNodeName(parentNode))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(getOverflowAncestors(target));
}
function contains(parent, child) {
  const rootNode = child == null ? void 0 : child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent != null && parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element, strategy));
  }
  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingAncestors.filter((clippingAncestors2) => isElement(clippingAncestors2) && contains(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
var platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: (_ref) => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: {
        ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize: _ancestorResize = true,
    elementResize: _elementResize = true,
    animationFrame = false
  } = options;
  let cleanedUp = false;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestorResize = _ancestorResize && !animationFrame;
  const elementResize = _elementResize && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  let observer = null;
  if (elementResize) {
    observer = new ResizeObserver(update2);
    isElement(reference) && observer.observe(reference);
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    if (cleanedUp) {
      return;
    }
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  return () => {
    var _observer;
    cleanedUp = true;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => computePosition(reference, floating, {
  platform,
  ...options
});

// node_modules/@hope-ui/solid/dist/index.mjs
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __DEV__ = false;
function isNumber(value) {
  return typeof value === "number";
}
function isArray(value) {
  return Array.isArray(value);
}
function isObject(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function") && !isArray(value);
}
function isFunction(value) {
  return typeof value === "function";
}
function isNull(value) {
  return value == null;
}
function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}
function isUndefined(value) {
  return typeof value === "undefined" || value === void 0;
}
function noop() {
  return;
}
function cast(value) {
  return value;
}
function mapKeys(prop, mapper) {
  if (isObject(prop)) {
    return Object.keys(prop).reduce((result, key) => {
      result[key] = mapper(prop[key]);
      return result;
    }, {});
  }
  if (prop !== null && prop !== void 0) {
    return mapper(prop);
  }
  return null;
}
function callHandler(handler, event) {
  if (handler) {
    if (isFunction(handler)) {
      handler(event);
    } else {
      handler[0](handler[1], event);
    }
  }
  return event == null ? void 0 : event.defaultPrevented;
}
function chainHandlers(...fns) {
  return function(event) {
    fns.some((fn) => {
      return callHandler(fn, event);
    });
  };
}
function range(count) {
  return Array(count).fill(1).map((_, index) => index + 1);
}
var mockBody = {
  classList: { add: noop, remove: noop }
};
var hasLocalStorageSupport = () => typeof Storage !== "undefined";
var COLOR_MODE_STORAGE_KEY = "hope-ui-color-mode";
var colorModeClassNames = {
  light: "hope-ui-light",
  dark: "hope-ui-dark"
};
function getColorModeFromLocalStorage() {
  if (!hasLocalStorageSupport()) {
    return null;
  }
  try {
    return localStorage.getItem(COLOR_MODE_STORAGE_KEY);
  } catch (error) {
    return null;
  }
}
function saveColorModeToLocalStorage(value) {
  if (!hasLocalStorageSupport()) {
    return;
  }
  try {
    localStorage.setItem(COLOR_MODE_STORAGE_KEY, value);
  } catch (error) {
  }
}
function getDefaultColorMode(fallbackValue) {
  const persistedPreference = getColorModeFromLocalStorage();
  if (persistedPreference) {
    return persistedPreference;
  } else if (fallbackValue === "system") {
    const isSystemDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    return isSystemDark ? "dark" : "light";
  } else {
    return fallbackValue;
  }
}
function getColorModeClassName(isDark) {
  return isDark ? colorModeClassNames.dark : colorModeClassNames.light;
}
function syncBodyColorModeClassName(isDark) {
  const body = isServer ? mockBody : document.body;
  body.classList.add(getColorModeClassName(isDark));
  body.classList.remove(isDark ? colorModeClassNames.light : colorModeClassNames.dark);
}
var space = {
  px: "1px",
  "0_5": "0.125rem",
  "1": "0.25rem",
  "1_5": "0.375rem",
  "2": "0.5rem",
  "2_5": "0.625rem",
  "3": "0.75rem",
  "3_5": "0.875rem",
  "4": "1rem",
  "5": "1.25rem",
  "6": "1.5rem",
  "7": "1.75rem",
  "8": "2rem",
  "9": "2.25rem",
  "10": "2.5rem",
  "12": "3rem",
  "14": "3.5rem",
  "16": "4rem",
  "20": "5rem",
  "24": "6rem",
  "28": "7rem",
  "32": "8rem",
  "36": "9rem",
  "40": "10rem",
  "44": "11rem",
  "48": "12rem",
  "52": "13rem",
  "56": "14rem",
  "60": "15rem",
  "64": "16rem",
  "72": "18rem",
  "80": "20rem",
  "96": "24rem"
};
var sizes = __spreadProps(__spreadValues({}, space), {
  prose: "65ch",
  max: "max-content",
  min: "min-content",
  full: "100%",
  screenW: "100vw",
  screenH: "100vh",
  xs: "20rem",
  sm: "24rem",
  md: "28rem",
  lg: "32rem",
  xl: "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "8xl": "90rem",
  containerSm: "640px",
  containerMd: "768px",
  containerLg: "1024px",
  containerXl: "1280px",
  container2xl: "1536px"
});
var baseMedia = {
  sm: `(min-width: ${sizes.containerSm})`,
  md: `(min-width: ${sizes.containerMd})`,
  lg: `(min-width: ${sizes.containerLg})`,
  xl: `(min-width: ${sizes.containerXl})`,
  "2xl": `(min-width: ${sizes.container2xl})`,
  "reduce-motion": "(prefers-reduced-motion: reduce)",
  light: "(prefers-color-scheme: light)",
  dark: "(prefers-color-scheme: dark)"
};
var background = {
  bg: (value) => ({ background: value }),
  bgColor: (value) => ({ backgroundColor: value })
};
var border = {
  borderX: (value) => ({
    borderLeft: value,
    borderRight: value
  }),
  borderY: (value) => ({
    borderTop: value,
    borderBottom: value
  })
};
var display = {
  d: (value) => ({ display: value })
};
var margin = {
  m: (value) => ({ margin: value }),
  mt: (value) => ({ marginTop: value }),
  mr: (value) => ({ marginRight: value }),
  marginStart: (value) => ({ marginInlineStart: value }),
  ms: (value) => ({ marginInlineStart: value }),
  mb: (value) => ({ marginBottom: value }),
  ml: (value) => ({ marginLeft: value }),
  marginEnd: (value) => ({ marginInlineEnd: value }),
  me: (value) => ({ marginInlineEnd: value }),
  mx: (value) => ({
    marginInlineStart: value,
    marginInlineEnd: value
  }),
  my: (value) => ({ marginTop: value, marginBottom: value }),
  spaceX: (value) => ({
    "& > * + *": {
      marginLeft: value
    }
  }),
  spaceY: (value) => ({
    "& > * + *": {
      marginTop: value
    }
  })
};
var padding = {
  p: (value) => ({ padding: value }),
  pt: (value) => ({ paddingTop: value }),
  pr: (value) => ({ paddingRight: value }),
  paddingStart: (value) => ({ paddingInlineStart: value }),
  ps: (value) => ({ paddingInlineStart: value }),
  pb: (value) => ({ paddingBottom: value }),
  pl: (value) => ({ paddingLeft: value }),
  pe: (value) => ({ paddingInlineEnd: value }),
  paddingEnd: (value) => ({ paddingInlineEnd: value }),
  px: (value) => ({
    paddingInlineStart: value,
    paddingInlineEnd: value
  }),
  py: (value) => ({ paddingTop: value, paddingBottom: value })
};
var position = {
  pos: (value) => ({ position: value })
};
function createGroupSelector(...selectors) {
  return selectors.map((item) => `[role=group]${item} &, [data-group]${item} &, .group${item} &`).join(", ");
}
function createPeerSelector(...selectors) {
  return selectors.map((item) => `[data-peer]${item} ~ &, .peer${item} ~ &`).join(", ");
}
var pseudoSelectors = {
  _hover: (value) => ({
    "&:hover, &[data-hover]": value
  }),
  _active: (value) => ({
    "&:active, &[data-active]": value
  }),
  _focus: (value) => ({
    "&:focus, &[data-focus]": value
  }),
  _highlighted: (value) => ({
    "&[data-highlighted]": value
  }),
  _focusWithin: (value) => ({
    "&:focus-within": value
  }),
  _focusVisible: (value) => ({
    "&:focus-visible": value
  }),
  _disabled: (value) => ({
    "&[disabled], &[aria-disabled=true], &[data-disabled]": value
  }),
  _readOnly: (value) => ({
    "&[aria-readonly=true], &[readonly], &[data-readonly]": value
  }),
  _before: (value) => ({
    "&::before": value
  }),
  _after: (value) => ({
    "&::after": value
  }),
  _empty: (value) => ({
    "&:empty": value
  }),
  _expanded: (value) => ({
    "&[aria-expanded=true], &[data-expanded]": value
  }),
  _checked: (value) => ({
    "&[aria-checked=true], &[data-checked]": value
  }),
  _grabbed: (value) => ({
    "&[aria-grabbed=true], &[data-grabbed]": value
  }),
  _pressed: (value) => ({
    "&[aria-pressed=true], &[data-pressed]": value
  }),
  _invalid: (value) => ({
    "&[aria-invalid=true], &[data-invalid]": value
  }),
  _valid: (value) => ({
    "&[data-valid], &[data-state=valid]": value
  }),
  _loading: (value) => ({
    "&[data-loading], &[aria-busy=true]": value
  }),
  _selected: (value) => ({
    "&[aria-selected=true], &[data-selected]": value
  }),
  _hidden: (value) => ({
    "&[hidden], &[data-hidden]": value
  }),
  _even: (value) => ({
    "&:nth-of-type(even)": value
  }),
  _odd: (value) => ({
    "&:nth-of-type(odd)": value
  }),
  _first: (value) => ({
    "&:first-of-type": value
  }),
  _last: (value) => ({
    "&:last-of-type": value
  }),
  _notFirst: (value) => ({
    "&:not(:first-of-type)": value
  }),
  _notLast: (value) => ({
    "&:not(:last-of-type)": value
  }),
  _visited: (value) => ({
    "&:visited": value
  }),
  _activeLink: (value) => ({
    "&[aria-current=page]": value
  }),
  _activeStep: (value) => ({
    "&[aria-current=step]": value
  }),
  _indeterminate: (value) => ({
    "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]": value
  }),
  _groupHover: (value) => ({
    [createGroupSelector(":hover", "[data-hover]")]: value
  }),
  _peerHover: (value) => ({
    [createPeerSelector(":hover", "[data-hover]")]: value
  }),
  _groupFocus: (value) => ({
    [createGroupSelector(":focus", "[data-focus]")]: value
  }),
  _peerFocus: (value) => ({
    [createPeerSelector(":focus", "[data-focus]")]: value
  }),
  _groupFocusVisible: (value) => ({
    [createGroupSelector(":focus-visible")]: value
  }),
  _peerFocusVisible: (value) => ({
    [createPeerSelector(":focus-visible")]: value
  }),
  _groupActive: (value) => ({
    [createGroupSelector(":active", "[data-active]")]: value
  }),
  _peerActive: (value) => ({
    [createPeerSelector(":active", "[data-active]")]: value
  }),
  _groupSelected: (value) => ({
    [createGroupSelector("[aria-selected=true]", "[data-selected]")]: value
  }),
  _peerSelected: (value) => ({
    [createPeerSelector("[aria-selected=true]", "[data-selected]")]: value
  }),
  _groupDisabled: (value) => ({
    [createGroupSelector(":disabled", "[data-disabled]")]: value
  }),
  _peerDisabled: (value) => ({
    [createPeerSelector(":disabled", "[data-disabled]")]: value
  }),
  _groupInvalid: (value) => ({
    [createGroupSelector(":invalid", "[data-invalid]")]: value
  }),
  _peerInvalid: (value) => ({
    [createPeerSelector(":invalid", "[data-invalid]")]: value
  }),
  _groupChecked: (value) => ({
    [createGroupSelector(":checked", "[data-checked]")]: value
  }),
  _peerChecked: (value) => ({
    [createPeerSelector(":checked", "[data-checked]")]: value
  }),
  _groupFocusWithin: (value) => ({
    [createGroupSelector(":focus-within")]: value
  }),
  _peerFocusWithin: (value) => ({
    [createPeerSelector(":focus-within")]: value
  }),
  _peerPlaceholderShown: (value) => ({
    [createPeerSelector(":placeholder-shown")]: value
  }),
  _placeholder: (value) => ({
    "&::placeholder": value
  }),
  _placeholderShown: (value) => ({
    "&:placeholder-shown": value
  }),
  _fullScreen: (value) => ({
    "&:fullscreen": value
  }),
  _selection: (value) => ({
    "&::selection": value
  }),
  _mediaDark: (value) => ({
    "@media (prefers-color-scheme: dark)": value
  }),
  _mediaReduceMotion: (value) => ({
    "@media (prefers-reduced-motion: reduce)": value
  }),
  _dark: (value) => ({
    ".hope-ui-dark &": value
  }),
  _light: (value) => ({
    ".hope-ui-light &": value
  })
};
var radii$1 = {
  borderTopRadius: (value) => ({
    borderTopLeftRadius: value,
    borderTopRightRadius: value
  }),
  borderRightRadius: (value) => ({
    borderTopRightRadius: value,
    borderBottomRightRadius: value
  }),
  borderStartRadius: (value) => ({
    borderStartStartRadius: value,
    borderEndStartRadius: value
  }),
  borderBottomRadius: (value) => ({
    borderBottomLeftRadius: value,
    borderBottomRightRadius: value
  }),
  borderLeftRadius: (value) => ({
    borderTopLeftRadius: value,
    borderBottomLeftRadius: value
  }),
  borderEndRadius: (value) => ({
    borderStartEndRadius: value,
    borderEndEndRadius: value
  }),
  rounded: (value) => ({
    borderRadius: value
  }),
  roundedTop: (value) => ({
    borderTopLeftRadius: value,
    borderTopRightRadius: value
  }),
  roundedRight: (value) => ({
    borderTopRightRadius: value,
    borderBottomRightRadius: value
  }),
  roundedStart: (value) => ({
    borderStartStartRadius: value,
    borderEndStartRadius: value
  }),
  roundedBottom: (value) => ({
    borderBottomLeftRadius: value,
    borderBottomRightRadius: value
  }),
  roundedLeft: (value) => ({
    borderTopLeftRadius: value,
    borderBottomLeftRadius: value
  }),
  roundedEnd: (value) => ({
    borderStartEndRadius: value,
    borderEndEndRadius: value
  })
};
var shadow = {
  shadow: (value) => ({ boxShadow: value })
};
var size2 = {
  w: (value) => ({ width: value }),
  minW: (value) => ({ minWidth: value }),
  maxW: (value) => ({ maxWidth: value }),
  h: (value) => ({ height: value }),
  minH: (value) => ({ minHeight: value }),
  maxH: (value) => ({ maxHeight: value }),
  boxSize: (value) => ({ width: value, height: value })
};
var typography = {
  noOfLines: (value) => ({
    overflow: "hidden",
    display: "-webkit-box",
    "-webkit-box-orient": "vertical",
    "-webkit-line-clamp": value
  })
};
var utils = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, background), border), display), position), pseudoSelectors), radii$1), margin), padding), shadow), size2), typography);
var blackAlpha = {
  blackAlpha1: "#00000003",
  blackAlpha2: "#00000007",
  blackAlpha3: "#0000000c",
  blackAlpha4: "#00000012",
  blackAlpha5: "#00000017",
  blackAlpha6: "#0000001d",
  blackAlpha7: "#00000024",
  blackAlpha8: "#00000038",
  blackAlpha9: "#00000070",
  blackAlpha10: "#0000007a",
  blackAlpha11: "#00000090",
  blackAlpha12: "#000000e8"
};
var whiteAlpha = {
  whiteAlpha1: "#ffffff00",
  whiteAlpha2: "#ffffff03",
  whiteAlpha3: "#ffffff09",
  whiteAlpha4: "#ffffff0e",
  whiteAlpha5: "#ffffff16",
  whiteAlpha6: "#ffffff20",
  whiteAlpha7: "#ffffff2d",
  whiteAlpha8: "#ffffff3f",
  whiteAlpha9: "#ffffff62",
  whiteAlpha10: "#ffffff72",
  whiteAlpha11: "#ffffff97",
  whiteAlpha12: "#ffffffeb"
};
var commonColors = __spreadValues(__spreadValues({}, blackAlpha), whiteAlpha);
var primary = {
  primary1: "#fafdfe",
  primary2: "#f2fcfd",
  primary3: "#e7f9fb",
  primary4: "#d8f3f6",
  primary5: "#c4eaef",
  primary6: "#aadee6",
  primary7: "#84cdda",
  primary8: "#3db9cf",
  primary9: "#05a2c2",
  primary10: "#0894b3",
  primary11: "#0c7792",
  primary12: "#04313c"
};
var accent = {
  accent1: "#fdfcfe",
  accent2: "#fbfaff",
  accent3: "#f5f2ff",
  accent4: "#ede9fe",
  accent5: "#e4defc",
  accent6: "#d7cff9",
  accent7: "#c4b8f3",
  accent8: "#aa99ec",
  accent9: "#6e56cf",
  accent10: "#644fc1",
  accent11: "#5746af",
  accent12: "#20134b"
};
var neutral = {
  neutral1: "#fbfcfd",
  neutral2: "#f8f9fa",
  neutral3: "#f1f3f5",
  neutral4: "#eceef0",
  neutral5: "#e6e8eb",
  neutral6: "#dfe3e6",
  neutral7: "#d7dbdf",
  neutral8: "#c1c8cd",
  neutral9: "#889096",
  neutral10: "#7e868c",
  neutral11: "#687076",
  neutral12: "#11181c"
};
var success = {
  success1: "#fbfefc",
  success2: "#f2fcf5",
  success3: "#e9f9ee",
  success4: "#ddf3e4",
  success5: "#ccebd7",
  success6: "#b4dfc4",
  success7: "#92ceac",
  success8: "#5bb98c",
  success9: "#30a46c",
  success10: "#299764",
  success11: "#18794e",
  success12: "#153226"
};
var info = {
  info1: "#fbfdff",
  info2: "#f5faff",
  info3: "#edf6ff",
  info4: "#e1f0ff",
  info5: "#cee7fe",
  info6: "#b7d9f8",
  info7: "#96c7f2",
  info8: "#5eb0ef",
  info9: "#0091ff",
  info10: "#0081f1",
  info11: "#006adc",
  info12: "#00254d"
};
var warning = {
  warning1: "#fefdfb",
  warning2: "#fff9ed",
  warning3: "#fff4d5",
  warning4: "#ffecbc",
  warning5: "#ffe3a2",
  warning6: "#ffd386",
  warning7: "#f3ba63",
  warning8: "#ee9d2b",
  warning9: "#ffb224",
  warning10: "#ffa01c",
  warning11: "#ad5700",
  warning12: "#4e2009"
};
var danger = {
  danger1: "#fffcfc",
  danger2: "#fff8f8",
  danger3: "#ffefef",
  danger4: "#ffe5e5",
  danger5: "#fdd8d8",
  danger6: "#f9c6c6",
  danger7: "#f3aeaf",
  danger8: "#eb9091",
  danger9: "#e5484d",
  danger10: "#dc3d43",
  danger11: "#cd2b31",
  danger12: "#381316"
};
var semanticColors = {
  loContrast: "white",
  background: "$loContrast",
  focusRing: "#96c7f2",
  closeButtonHoverBackground: "$blackAlpha4",
  closeButtonActiveBackground: "$blackAlpha5",
  progressStripe: "$whiteAlpha6"
};
var lightColors = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, primary), accent), neutral), success), info), warning), danger), semanticColors);
var primaryDark = {
  primary1: "#07191d",
  primary2: "#061e24",
  primary3: "#072830",
  primary4: "#07303b",
  primary5: "#073844",
  primary6: "#064150",
  primary7: "#045063",
  primary8: "#00647d",
  primary9: "#05a2c2",
  primary10: "#00b1cc",
  primary11: "#00c2d7",
  primary12: "#e1f8fa"
};
var accentDark = {
  accent1: "#17151f",
  accent2: "#1c172b",
  accent3: "#251e40",
  accent4: "#2c2250",
  accent5: "#32275f",
  accent6: "#392c72",
  accent7: "#443592",
  accent8: "#5842c3",
  accent9: "#6e56cf",
  accent10: "#7c66dc",
  accent11: "#9e8cfc",
  accent12: "#f1eefe"
};
var neutralDark = {
  neutral1: "#151718",
  neutral2: "#1a1d1e",
  neutral3: "#202425",
  neutral4: "#26292b",
  neutral5: "#2b2f31",
  neutral6: "#313538",
  neutral7: "#3a3f42",
  neutral8: "#4c5155",
  neutral9: "#697177",
  neutral10: "#787f85",
  neutral11: "#9ba1a6",
  neutral12: "#ecedee"
};
var successDark = {
  success1: "#0d1912",
  success2: "#0c1f17",
  success3: "#0f291e",
  success4: "#113123",
  success5: "#133929",
  success6: "#164430",
  success7: "#1b543a",
  success8: "#236e4a",
  success9: "#30a46c",
  success10: "#3cb179",
  success11: "#4cc38a",
  success12: "#e5fbeb"
};
var infoDark = {
  info1: "#0f1720",
  info2: "#0f1b2d",
  info3: "#10243e",
  info4: "#102a4c",
  info5: "#0f3058",
  info6: "#0d3868",
  info7: "#0a4481",
  info8: "#0954a5",
  info9: "#0091ff",
  info10: "#369eff",
  info11: "#52a9ff",
  info12: "#eaf6ff"
};
var warningDark = {
  warning1: "#1f1300",
  warning2: "#271700",
  warning3: "#341c00",
  warning4: "#3f2200",
  warning5: "#4a2900",
  warning6: "#573300",
  warning7: "#693f05",
  warning8: "#824e00",
  warning9: "#ffb224",
  warning10: "#ffcb47",
  warning11: "#f1a10d",
  warning12: "#fef3dd"
};
var dangerDark = {
  danger1: "#1f1315",
  danger2: "#291415",
  danger3: "#3c181a",
  danger4: "#481a1d",
  danger5: "#541b1f",
  danger6: "#671e22",
  danger7: "#822025",
  danger8: "#aa2429",
  danger9: "#e5484d",
  danger10: "#f2555a",
  danger11: "#ff6369",
  danger12: "#feecee"
};
var semanticDarkColors = {
  loContrast: "$neutral1",
  background: "$loContrast",
  focusRing: "#0a4481",
  closeButtonHoverBackground: "$whiteAlpha4",
  closeButtonActiveBackground: "$whiteAlpha5",
  progressStripe: "$blackAlpha6"
};
var darkColors = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, primaryDark), accentDark), neutralDark), successDark), infoDark), warningDark), dangerDark), semanticDarkColors);
var radii = {
  none: "0",
  xs: "0.125rem",
  sm: "0.25rem",
  md: "0.375rem",
  lg: "0.5rem",
  xl: "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  full: "9999px"
};
var shadows = {
  none: "0 0 #0000",
  xs: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
  sm: "0 1px 3px 0 rgb(0 0 0 / 0.09), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
  md: "0 4px 6px -1px rgb(0 0 0 / 0.09), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
  lg: "0 10px 15px -3px rgb(0 0 0 / 0.09), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
  xl: "0 20px 25px -5px rgb(0 0 0 / 0.09), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
  "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.24)",
  inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.06)",
  outline: "0 0 0 3px $colors$focusRing"
};
var darkShadows = {
  lg: "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
};
var fonts = {
  sans: 'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol","Noto Color Emoji"',
  serif: 'ui-serif, Georgia, Cambria, "Times New Roman", Times, serif',
  mono: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace'
};
var fontSizes = {
  "2xs": "0.625rem",
  xs: "0.75rem",
  sm: "0.875rem",
  base: "1rem",
  lg: "1.125rem",
  xl: "1.25rem",
  "2xl": "1.5rem",
  "3xl": "1.875rem",
  "4xl": "2.25rem",
  "5xl": "3rem",
  "6xl": "3.75rem",
  "7xl": "4.5rem",
  "8xl": "6rem",
  "9xl": "8rem"
};
var fontWeights = {
  hairline: 100,
  thin: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  bold: 700,
  extrabold: 800,
  black: 900
};
var lineHeights = {
  normal: "normal",
  none: 1,
  shorter: 1.25,
  short: 1.375,
  base: 1.5,
  tall: 1.625,
  taller: 2,
  "3": ".75rem",
  "4": "1rem",
  "5": "1.25rem",
  "6": "1.5rem",
  "7": "1.75rem",
  "8": "2rem",
  "9": "2.25rem",
  "10": "2.5rem"
};
var letterSpacings = {
  tighter: "-0.05em",
  tight: "-0.025em",
  normal: "0",
  wide: "0.025em",
  wider: "0.05em",
  widest: "0.1em"
};
var zIndices = {
  hide: -1,
  auto: "auto",
  base: 0,
  docked: 10,
  sticky: 1e3,
  banner: 1100,
  overlay: 1200,
  modal: 1300,
  dropdown: 1400,
  popover: 1500,
  tooltip: 1600,
  skipLink: 1700,
  notification: 1800
};
var baseThemeTokens = {
  colors: __spreadValues(__spreadValues({}, commonColors), lightColors),
  space,
  sizes,
  fonts,
  fontSizes,
  fontWeights,
  letterSpacings,
  lineHeights,
  radii,
  shadows,
  zIndices
};
var baseDarkThemeTokens = {
  colors: darkColors,
  shadows: darkShadows
};
var {
  theme: baseTheme,
  css,
  globalCss,
  config,
  createTheme,
  getCssText,
  keyframes
} = X({
  prefix: "hope",
  themeMap: __spreadProps(__spreadValues({}, i), {
    borderWidth: "sizes",
    borderTopWidth: "sizes",
    borderRightWidth: "sizes",
    borderBottomWidth: "sizes",
    borderLeftWidth: "sizes",
    strokeWidth: "sizes"
  }),
  theme: baseThemeTokens,
  media: baseMedia,
  utils
});
var modalTransitionName = {
  fade: "hope-modal-fade-transition",
  fadeInBottom: "hope-modal-fade-in-bottom-transition",
  scale: "hope-modal-scale-transition"
};
var modalTransitionStyles = globalCss({
  [`.${modalTransitionName.fade}-enter, .${modalTransitionName.fade}-exit-to`]: {
    opacity: 0
  },
  [`.${modalTransitionName.fade}-enter-to, .${modalTransitionName.fade}-exit`]: {
    opacity: 1
  },
  [`.${modalTransitionName.fade}-enter-active`]: {
    transition: "opacity 300ms ease-out"
  },
  [`.${modalTransitionName.fade}-exit-active`]: {
    transition: "opacity 200ms ease-in"
  },
  [`.${modalTransitionName.fadeInBottom}-enter, .${modalTransitionName.fadeInBottom}-exit-to`]: {
    opacity: 0,
    transform: "translateY(16px)"
  },
  [`.${modalTransitionName.fadeInBottom}-enter-to, .${modalTransitionName.fadeInBottom}-exit`]: {
    opacity: 1,
    transform: "translateY(0)"
  },
  [`.${modalTransitionName.fadeInBottom}-enter-active`]: {
    transitionProperty: "opacity, transform",
    transitionDuration: "300ms",
    transitionTimingFunction: "ease-out"
  },
  [`.${modalTransitionName.fadeInBottom}-exit-active`]: {
    transitionProperty: "opacity, transform",
    transitionDuration: "200ms",
    transitionTimingFunction: "ease-in"
  },
  [`.${modalTransitionName.scale}-enter, .${modalTransitionName.scale}-exit-to`]: {
    opacity: 0,
    transform: "scale(0.95)"
  },
  [`.${modalTransitionName.scale}-enter-to, .${modalTransitionName.scale}-exit`]: {
    opacity: 1,
    transform: "scale(1)"
  },
  [`.${modalTransitionName.scale}-enter-active`]: {
    transitionProperty: "opacity, transform",
    transitionDuration: "300ms",
    transitionTimingFunction: "ease-out"
  },
  [`.${modalTransitionName.scale}-exit-active`]: {
    transitionProperty: "opacity, transform",
    transitionDuration: "200ms",
    transitionTimingFunction: "ease-in"
  }
});
var modalOverlayStyles = css({
  zIndex: "$overlay",
  position: "fixed",
  top: 0,
  left: 0,
  width: "100vw",
  height: "100vh",
  backgroundColor: "hsl(0 0% 0% / 65%)"
});
var baseModalContainerStyles = css({
  zIndex: "$modal",
  position: "fixed",
  top: 0,
  left: 0,
  display: "flex",
  width: "100vw",
  height: "100vh",
  "@supports(height: -webkit-fill-available)": {
    height: "-webkit-fill-available"
  },
  outline: "none",
  "&:focus": {
    outline: "none"
  }
});
var modalContainerStyles = css(baseModalContainerStyles, {
  justifyContent: "center",
  variants: {
    centered: {
      true: {
        alignItems: "center"
      },
      false: {
        alignItems: "flex-start"
      }
    },
    scrollBehavior: {
      inside: {
        overflow: "hidden"
      },
      outside: {
        overflow: "auto"
      }
    }
  }
});
var baseDialogStyles = css({
  zIndex: "$modal",
  position: "relative",
  display: "flex",
  flexDirection: "column",
  width: "100%",
  outline: "none",
  boxShadow: "$lg",
  backgroundColor: "$loContrast",
  color: "inherit",
  "&:focus": {
    outline: "none"
  }
});
var modalDialogStyles = css(baseDialogStyles, {
  justifyContent: "center",
  my: "3.75rem",
  borderRadius: "$sm",
  variants: {
    size: {
      xs: {
        maxWidth: "$xs"
      },
      sm: {
        maxWidth: "$sm"
      },
      md: {
        maxWidth: "$md"
      },
      lg: {
        maxWidth: "$lg"
      },
      xl: {
        maxWidth: "$xl"
      },
      "2xl": {
        maxWidth: "$2xl"
      },
      "3xl": {
        maxWidth: "$3xl"
      },
      "4xl": {
        maxWidth: "$4xl"
      },
      "5xl": {
        maxWidth: "$5xl"
      },
      "6xl": {
        maxWidth: "$6xl"
      },
      "7xl": {
        maxWidth: "$7xl"
      },
      "8xl": {
        maxWidth: "$8xl"
      },
      full: {
        maxWidth: "100vw",
        minHeight: "100vh",
        "@supports(min-height: -webkit-fill-available)": {
          minHeight: "-webkit-fill-available"
        },
        my: 0,
        borderRadius: "$none"
      }
    },
    scrollBehavior: {
      inside: {
        maxHeight: "calc(100% - 7.5rem)"
      },
      outside: {
        maxHeight: "none"
      }
    }
  }
});
var modalHeaderStyles = css({
  flex: 0,
  pt: "$5",
  px: "$5",
  pb: "$3",
  fontSize: "$lg",
  fontWeight: "$medium"
});
var modalBodyStyles = css({
  flex: 1,
  px: "$5",
  py: "$2",
  variants: {
    scrollBehavior: {
      inside: {
        overflow: "auto"
      },
      outside: {
        overflow: void 0
      }
    }
  }
});
var modalFooterStyles = css({
  display: "flex",
  alignItems: "center",
  justifyContent: "flex-end",
  pt: "$3",
  px: "$5",
  pb: "$5"
});
var modalCloseButtonStyles = css({
  position: "absolute",
  top: "$4",
  insetInlineEnd: "$4"
});
var drawerTransitionName = {
  fade: "hope-drawer-fade-transition",
  slideInTop: "hope-drawer-slide-in-top-transition",
  slideInRight: "hope-drawer-slide-in-right-transition",
  slideInBottom: "hope-drawer-slide-in-bottom-transition",
  slideInLeft: "hope-drawer-slide-in-left-transition"
};
var drawerTransitionStyles = globalCss({
  [`.${drawerTransitionName.fade}-enter, .${drawerTransitionName.fade}-exit-to`]: {
    opacity: 0
  },
  [`.${drawerTransitionName.fade}-enter-to, .${drawerTransitionName.fade}-exit`]: {
    opacity: 1
  },
  [`.${drawerTransitionName.fade}-enter-active, .${drawerTransitionName.fade}-exit-active`]: {
    transition: "opacity 500ms ease-in-out"
  },
  [`.${drawerTransitionName.slideInTop}-enter-active, .${drawerTransitionName.slideInTop}-exit-active,
    .${drawerTransitionName.slideInRight}-enter-active, .${drawerTransitionName.slideInRight}-exit-active,
    .${drawerTransitionName.slideInBottom}-enter-active, .${drawerTransitionName.slideInBottom}-exit-active,
    .${drawerTransitionName.slideInLeft}-enter-active, .${drawerTransitionName.slideInLeft}-exit-active`]: {
    transition: "transform 500ms ease-in-out"
  },
  [`.${drawerTransitionName.slideInTop}-enter, .${drawerTransitionName.slideInTop}-exit-to`]: {
    transform: "translateY(-100%)"
  },
  [`.${drawerTransitionName.slideInTop}-enter-to, .${drawerTransitionName.slideInTop}-exit`]: {
    transform: "translateY(0)"
  },
  [`.${drawerTransitionName.slideInRight}-enter, .${drawerTransitionName.slideInRight}-exit-to`]: {
    transform: "translateX(100%)"
  },
  [`.${drawerTransitionName.slideInRight}-enter-to, .${drawerTransitionName.slideInRight}-exit`]: {
    transform: "translateX(0)"
  },
  [`.${drawerTransitionName.slideInBottom}-enter, .${drawerTransitionName.slideInBottom}-exit-to`]: {
    transform: "translateY(100%)"
  },
  [`.${drawerTransitionName.slideInBottom}-enter-to, .${drawerTransitionName.slideInBottom}-exit`]: {
    transform: "translateY(0)"
  },
  [`.${drawerTransitionName.slideInLeft}-enter, .${drawerTransitionName.slideInLeft}-exit-to`]: {
    transform: "translateX(-100%)"
  },
  [`.${drawerTransitionName.slideInLeft}-enter-to, .${drawerTransitionName.slideInLeft}-exit`]: {
    transform: "translateX(0)"
  }
});
var drawerContainerStyles = css(baseModalContainerStyles, {
  overflow: "hidden",
  variants: {
    placement: {
      top: {
        alignItems: "flex-start",
        justifyContent: "stretch"
      },
      right: {
        alignItems: "stretch",
        justifyContent: "flex-end"
      },
      bottom: {
        alignItems: "flex-end",
        justifyContent: "stretch"
      },
      left: {
        alignItems: "stretch",
        justifyContent: "flex-start"
      }
    }
  }
});
var drawerDialogStyles = css(baseDialogStyles, {
  maxHeight: "100vh",
  variants: {
    size: {
      xs: {
        maxWidth: "$xs"
      },
      sm: {
        maxWidth: "$md"
      },
      md: {
        maxWidth: "$lg"
      },
      lg: {
        maxWidth: "$2xl"
      },
      xl: {
        maxWidth: "$4xl"
      },
      full: {
        maxWidth: "100vw",
        height: "100vh"
      }
    },
    placement: {
      top: {},
      right: {},
      bottom: {},
      left: {}
    },
    fullHeight: {
      true: {
        height: "100vh"
      },
      false: {}
    }
  },
  compoundVariants: [
    { placement: "top", size: "xs", css: { maxWidth: "100vw" } },
    { placement: "top", size: "sm", css: { maxWidth: "100vw" } },
    { placement: "top", size: "md", css: { maxWidth: "100vw" } },
    { placement: "top", size: "lg", css: { maxWidth: "100vw" } },
    { placement: "top", size: "xl", css: { maxWidth: "100vw" } },
    { placement: "bottom", size: "xs", css: { maxWidth: "100vw" } },
    { placement: "bottom", size: "sm", css: { maxWidth: "100vw" } },
    { placement: "bottom", size: "md", css: { maxWidth: "100vw" } },
    { placement: "bottom", size: "lg", css: { maxWidth: "100vw" } },
    { placement: "bottom", size: "xl", css: { maxWidth: "100vw" } }
  ]
});
var menuTransitionName = {
  scaleTopLeft: "hope-menu-scale-top-left-transition",
  scaleTopRight: "hope-menu-scale-top-right-transition",
  scaleBottomLeft: "hope-menu-scale-bottom-left-transition",
  scaleBottomRight: "hope-menu-scale-bottom-right-transition"
};
function createMenuScaleTransition(name, transformOrigin) {
  return {
    [`.${name}-enter, .${name}-exit-to`]: {
      opacity: 0,
      transform: "scale(0.8)"
    },
    [`.${name}-enter-to, .${name}-exit`]: {
      opacity: 1,
      transform: "scale(1)"
    },
    [`.${name}-enter-active`]: {
      transformOrigin,
      transitionProperty: "opacity, transform",
      transitionDuration: "200ms",
      transitionTimingFunction: "ease-out"
    },
    [`.${name}-exit-active`]: {
      transformOrigin,
      transitionProperty: "opacity, transform",
      transitionDuration: "100ms",
      transitionTimingFunction: "ease-in"
    }
  };
}
var menuTransitionStyles = globalCss(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, createMenuScaleTransition(menuTransitionName.scaleTopLeft, "top left")), createMenuScaleTransition(menuTransitionName.scaleTopRight, "top right")), createMenuScaleTransition(menuTransitionName.scaleBottomLeft, "bottom left")), createMenuScaleTransition(menuTransitionName.scaleBottomRight, "bottom right")));
var menuTriggerStyles = css({
  appearance: "none",
  display: "inline-flex",
  alignItems: "center",
  outline: "none"
});
var menuContentStyles = css({
  zIndex: "$dropdown",
  position: "absolute",
  left: 0,
  top: "100%",
  display: "flex",
  flexDirection: "column",
  minWidth: "$56",
  overflowY: "auto",
  outline: "none",
  margin: 0,
  boxShadow: "$md",
  border: "1px solid $colors$neutral7",
  borderRadius: "$sm",
  backgroundColor: "$loContrast",
  px: 0,
  py: "$1",
  "&:focus": {
    outline: "none"
  }
});
var menuGroupStyles = css({});
var menuLabelStyles = css({
  display: "flex",
  alignItems: "center",
  mx: "$1",
  py: "$2",
  px: "$3",
  color: "$neutral11",
  fontSize: "$xs",
  fontWeight: "$medium",
  lineHeight: "$4"
});
function createColorVariant$1(config2) {
  return {
    color: config2.color,
    [`&[data-active]`]: {
      backgroundColor: config2.bgColorActive
    }
  };
}
var menuItemStyles = css({
  position: "relative",
  display: "flex",
  alignItems: "center",
  mx: "$1",
  borderRadius: "$sm",
  py: "$2",
  px: "$3",
  fontSize: "$base",
  fontWeight: "$normal",
  lineHeight: "$6",
  cursor: "pointer",
  userSelect: "none",
  transition: "color 250ms, background-color 250ms",
  "&[data-disabled]": {
    color: "$neutral8",
    cursor: "not-allowed"
  },
  variants: {
    colorScheme: {
      primary: createColorVariant$1({ color: "$primary11", bgColorActive: "$primary3" }),
      accent: createColorVariant$1({ color: "$accent11", bgColorActive: "$accent3" }),
      neutral: createColorVariant$1({ color: "$neutral12", bgColorActive: "$neutral4" }),
      success: createColorVariant$1({ color: "$success11", bgColorActive: "$success3" }),
      info: createColorVariant$1({ color: "$info11", bgColorActive: "$info3" }),
      warning: createColorVariant$1({ color: "$warning11", bgColorActive: "$warning3" }),
      danger: createColorVariant$1({ color: "$danger11", bgColorActive: "$danger3" })
    }
  },
  defaultVariants: {
    colorScheme: "neutral"
  }
});
var menuItemIconWrapperStyles = css({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0
});
var menuItemTextStyles = css({
  flexGrow: 1
});
var menuItemCommandStyles = css({
  flexShrink: 0,
  color: "$neutral11",
  fontSize: "$sm",
  lineHeight: "$none"
});
var spin = keyframes({
  from: { transform: "rotate(0deg)" },
  to: { transform: "rotate(360deg)" }
});
var fadeIn = keyframes({
  from: { opacity: 0 },
  to: { opacity: 1 }
});
var notificationTransitionName = {
  slideInTop: "hope-notification-slide-in-top-transition",
  slideInRight: "hope-notification-slide-in-right-transition",
  slideInBottom: "hope-notification-slide-in-bottom-transition",
  slideInLeft: "hope-notification-slide-in-left-transition"
};
function createNotificationSlideTransition(config2) {
  return {
    [`.${config2.name}-enter, .${config2.name}-exit-to`]: {
      opacity: 0,
      transform: config2.enterTransform
    },
    [`.${config2.name}-enter-to, .${config2.name}-exit`]: {
      opacity: 1,
      transform: config2.leaveTransform
    },
    [`.${config2.name}-enter-active`]: {
      transitionProperty: "opacity, transform",
      transitionTimingFunction: "cubic-bezier(.51,.3,0,1.21)",
      transitionDuration: "300ms"
    },
    [`.${config2.name}-exit-active`]: {
      transitionProperty: "opacity, transform",
      transitionTimingFunction: "ease-in",
      transitionDuration: "200ms"
    }
  };
}
var notificationTransitionStyles = globalCss(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, createNotificationSlideTransition({
  name: notificationTransitionName.slideInTop,
  enterTransform: "translateY(-100%)",
  leaveTransform: "translateY(0)"
})), createNotificationSlideTransition({
  name: notificationTransitionName.slideInRight,
  enterTransform: "translateX(100%)",
  leaveTransform: "translateX(0)"
})), createNotificationSlideTransition({
  name: notificationTransitionName.slideInBottom,
  enterTransform: "translateY(100%)",
  leaveTransform: "translateY(0)"
})), createNotificationSlideTransition({
  name: notificationTransitionName.slideInLeft,
  enterTransform: "translateX(-100%)",
  leaveTransform: "translateX(0)"
})));
var notificationListStyles = css({
  position: "fixed",
  zIndex: "$notification",
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-end",
  gap: "$4",
  width: "calc(100% - 32px)",
  maxWidth: "$md",
  variants: {
    placement: {
      "top-start": {
        top: "$4",
        left: "$4"
      },
      top: {
        top: "$4",
        left: "50%",
        transform: "translateX(-50%)"
      },
      "top-end": {
        top: "$4",
        right: "$4"
      },
      "bottom-start": {
        bottom: "$4",
        left: "$4"
      },
      bottom: {
        bottom: "$4",
        left: "50%",
        transform: "translateX(-50%)"
      },
      "bottom-end": {
        bottom: "$4",
        right: "$4"
      }
    }
  },
  defaultVariants: {
    placement: "top-end"
  }
});
var notificationStyles = css({
  position: "relative",
  display: "flex",
  alignItems: "center",
  width: "100%",
  maxWidth: "$md",
  borderRadius: "$sm",
  border: "1px solid $colors$neutral5",
  boxShadow: "$lg",
  backgroundColor: "$loContrast",
  padding: "$3",
  fontSize: "$sm",
  lineHeight: "$5",
  variants: {
    status: {
      success: {},
      info: {},
      warning: {},
      danger: {}
    }
  }
});
var notificationLoaderStyles = css({
  animation: `1s linear infinite ${spin}`
});
var notificationIconStyles = css({
  flexShrink: 0,
  variants: {
    status: {
      success: { color: "$success9" },
      info: { color: "$info9" },
      warning: { color: "$warning9" },
      danger: { color: "$danger9" }
    }
  }
});
var notificationTitleStyles = css({
  fontWeight: "$medium"
});
var notificationDescriptionStyles = css({
  display: "inline-block",
  color: "$neutral11"
});
var popoverTransitionName = {
  scale: "hope-popover-scale-transition"
};
var popoverTransitionStyles = globalCss({
  [`.${popoverTransitionName.scale}-enter, .${popoverTransitionName.scale}-exit-to`]: {
    opacity: 0,
    transform: "scale(0.95)"
  },
  [`.${popoverTransitionName.scale}-enter-to, .${popoverTransitionName.scale}-exit`]: {
    opacity: 1,
    transform: "scale(1)"
  },
  [`.${popoverTransitionName.scale}-enter-active`]: {
    transitionProperty: "opacity, transform",
    transitionDuration: "300ms",
    transitionTimingFunction: "ease"
  },
  [`.${popoverTransitionName.scale}-exit-active`]: {
    transitionProperty: "opacity, transform",
    transitionDuration: "200ms",
    transitionTimingFunction: "ease-in-out"
  }
});
var popoverContentStyles = css({
  zIndex: "$popover",
  position: "absolute",
  display: "flex",
  flexDirection: "column",
  justifyContent: "center",
  width: "100%",
  maxWidth: "$xs",
  outline: "none",
  boxShadow: "$md",
  border: "1px solid $colors$neutral7",
  borderRadius: "$sm",
  backgroundColor: "$loContrast",
  color: "inherit",
  "&:focus": {
    outline: "none"
  }
});
var popoverHeaderStyles = css({
  display: "flex",
  alignItems: "center",
  flex: 0,
  borderColor: "inherit",
  borderBottomWidth: "1px",
  px: "$3",
  py: "$2",
  fontSize: "$base",
  fontWeight: "$medium"
});
var popoverBodyStyles = css({
  flex: 1,
  px: "$3",
  py: "$2"
});
var popoverFooterStyles = css({
  display: "flex",
  alignItems: "center",
  borderColor: "inherit",
  borderTopWidth: "1px",
  px: "$3",
  py: "$2"
});
var popoverCloseButtonStyles = css({
  position: "absolute",
  top: "$2",
  insetInlineEnd: "$2"
});
var popoverArrowStyles = css({
  zIndex: "$popover",
  position: "absolute",
  boxSize: "8px",
  borderWidth: "1px",
  borderStyle: "solid",
  borderColor: "inherit",
  backgroundColor: "inherit",
  transform: "rotate(45deg)",
  variants: {
    popoverPlacement: {
      left: {
        borderLeft: 0,
        borderBottom: 0
      },
      top: {
        borderLeft: 0,
        borderTop: 0
      },
      right: {
        borderTop: 0,
        borderRight: 0
      },
      bottom: {
        borderRight: 0,
        borderBottom: 0
      }
    }
  }
});
function createInputSizeVariant(config2) {
  return {
    minHeight: config2.minHeight,
    fontSize: config2.fontSize,
    lineHeight: config2.lineHeight
  };
}
var inputSizes = {
  xs: createInputSizeVariant({ fontSize: "$xs", lineHeight: "$4", minHeight: "$6" }),
  sm: createInputSizeVariant({ fontSize: "$sm", lineHeight: "$5", minHeight: "$8" }),
  md: createInputSizeVariant({ fontSize: "$base", lineHeight: "$6", minHeight: "$10" }),
  lg: createInputSizeVariant({ fontSize: "$lg", lineHeight: "$7", minHeight: "$12" })
};
var commonOutlineAndFilledStyles = {
  "&:disabled": {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  "&:focus": {
    boxShadow: "0 0 0 3px $colors$primary5",
    borderColor: "$primary8"
  },
  "&[aria-invalid=true]": {
    borderColor: "$danger8"
  },
  "&[aria-invalid=true]:focus": {
    boxShadow: "0 0 0 3px $colors$danger5"
  }
};
var baseInputResetStyles = css({
  appearance: "none",
  position: "relative",
  width: "100%",
  minWidth: 0,
  outline: "none",
  borderRadius: "$sm",
  backgroundColor: "transparent",
  padding: 0,
  color: "$neutral12",
  fontSize: "$base",
  lineHeight: "$base",
  transition: "color 250ms, border-color 250ms, background-color 250ms, box-shadow 250ms",
  "&[readonly]": {
    boxShadow: "none !important",
    userSelect: "all",
    cursor: "default"
  },
  "&::placeholder": {
    color: "$neutral9",
    opacity: 1
  },
  variants: {
    variant: {
      outline: __spreadValues({
        border: "1px solid $neutral7",
        backgroundColor: "transparent",
        "&:hover": {
          borderColor: "$neutral8"
        }
      }, commonOutlineAndFilledStyles),
      filled: __spreadValues({
        border: "1px solid transparent",
        backgroundColor: "$neutral3",
        "&:hover, &:focus": {
          backgroundColor: "$neutral4"
        }
      }, commonOutlineAndFilledStyles),
      unstyled: {
        border: "1px solid transparent",
        backgroundColor: "transparent"
      }
    },
    size: __spreadValues({}, inputSizes)
  }
});
function createVariantAndSizeCompoundVariant(config2) {
  return [
    {
      variant: config2.variant,
      size: config2.size,
      css: { px: config2.paddingX }
    },
    {
      withLeftElement: true,
      variant: config2.variant,
      size: config2.size,
      css: { paddingInlineStart: config2.paddingWithElement }
    },
    {
      withRightElement: true,
      variant: config2.variant,
      size: config2.size,
      css: { paddingInlineEnd: config2.paddingWithElement }
    }
  ];
}
var inputStyles = css(baseInputResetStyles, {
  variants: {
    withLeftElement: {
      true: {}
    },
    withRightElement: {
      true: {}
    },
    withLeftAddon: {
      true: {
        borderLeftRadius: 0
      }
    },
    withRightAddon: {
      true: {
        borderRightRadius: 0
      }
    }
  },
  compoundVariants: [
    ...createVariantAndSizeCompoundVariant({
      variant: "outline",
      size: "xs",
      paddingX: "$2",
      paddingWithElement: "$6"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "outline",
      size: "sm",
      paddingX: "$2_5",
      paddingWithElement: "$8"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "outline",
      size: "md",
      paddingX: "$3",
      paddingWithElement: "$10"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "outline",
      size: "lg",
      paddingX: "$4",
      paddingWithElement: "$12"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "filled",
      size: "xs",
      paddingX: "$2",
      paddingWithElement: "$6"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "filled",
      size: "sm",
      paddingX: "$2_5",
      paddingWithElement: "$8"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "filled",
      size: "md",
      paddingX: "$3",
      paddingWithElement: "$10"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "filled",
      size: "lg",
      paddingX: "$4",
      paddingWithElement: "$12"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "unstyled",
      size: "xs",
      paddingX: 0,
      paddingWithElement: "$6"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "unstyled",
      size: "sm",
      paddingX: 0,
      paddingWithElement: "$8"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "unstyled",
      size: "md",
      paddingX: 0,
      paddingWithElement: "$10"
    }),
    ...createVariantAndSizeCompoundVariant({
      variant: "unstyled",
      size: "lg",
      paddingX: 0,
      paddingWithElement: "$12"
    })
  ]
});
var inputGroupStyles = css({
  position: "relative",
  display: "flex",
  width: "100%"
});
var inputElementStyles = css({
  position: "absolute",
  top: "0",
  zIndex: 2,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  variants: {
    placement: {
      left: { insetInlineStart: "0" },
      right: { insetInlineEnd: "0" }
    },
    size: {
      xs: __spreadProps(__spreadValues({}, inputSizes.xs), {
        width: inputSizes.xs.minHeight
      }),
      sm: __spreadProps(__spreadValues({}, inputSizes.sm), {
        width: inputSizes.sm.minHeight
      }),
      md: __spreadProps(__spreadValues({}, inputSizes.md), {
        width: inputSizes.md.minHeight
      }),
      lg: __spreadProps(__spreadValues({}, inputSizes.lg), {
        width: inputSizes.lg.minHeight
      })
    }
  }
});
function createInputAddonVariantAndSizeCompoundVariant(config2) {
  return {
    variant: config2.variant,
    size: config2.size,
    css: { px: config2.paddingX }
  };
}
var inputAddonStyles = css({
  display: "flex",
  alignItems: "center",
  flex: "0 0 auto",
  width: "auto",
  whiteSpace: "nowrap",
  variants: {
    placement: {
      left: {
        marginEnd: "-1px"
      },
      right: {
        marginStart: "-1px"
      }
    },
    variant: {
      outline: {
        borderRadius: "$sm",
        border: "1px solid $neutral7",
        backgroundColor: "$neutral3",
        color: "$neutral12"
      },
      filled: {
        borderRadius: "$sm",
        border: "1px solid transparent",
        backgroundColor: "$neutral3",
        color: "$neutral12"
      },
      unstyled: {
        border: "1px solid transparent",
        backgroundColor: "transparent"
      }
    },
    size: __spreadValues({}, inputSizes)
  },
  compoundVariants: [
    {
      variant: "outline",
      placement: "left",
      css: {
        borderRightRadius: 0,
        borderInlineEndColor: "transparent"
      }
    },
    {
      variant: "outline",
      placement: "right",
      css: {
        borderLeftRadius: 0,
        borderInlineStartColor: "transparent"
      }
    },
    {
      variant: "filled",
      placement: "left",
      css: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        borderInlineEndColor: "transparent"
      }
    },
    {
      variant: "filled",
      placement: "right",
      css: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
        borderInlineStartColor: "transparent"
      }
    },
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "outline",
      size: "xs",
      paddingX: "$2"
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "outline",
      size: "sm",
      paddingX: "$2_5"
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "outline",
      size: "md",
      paddingX: "$3"
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "outline",
      size: "lg",
      paddingX: "$4"
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "filled",
      size: "xs",
      paddingX: "$2"
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "filled",
      size: "sm",
      paddingX: "$2_5"
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "filled",
      size: "md",
      paddingX: "$3"
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "filled",
      size: "lg",
      paddingX: "$4"
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "unstyled",
      size: "xs",
      paddingX: 0
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "unstyled",
      size: "sm",
      paddingX: 0
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "unstyled",
      size: "md",
      paddingX: 0
    }),
    createInputAddonVariantAndSizeCompoundVariant({
      variant: "unstyled",
      size: "lg",
      paddingX: 0
    })
  ]
});
var selectTransitionName = {
  fadeInTop: "hope-select-fade-in-top-transition"
};
var selectTransitionStyles = globalCss({
  [`.${selectTransitionName.fadeInTop}-enter, .${selectTransitionName.fadeInTop}-exit-to`]: {
    opacity: 0,
    transform: "translateY(-16px)"
  },
  [`.${selectTransitionName.fadeInTop}-enter-to, .${selectTransitionName.fadeInTop}-exit`]: {
    opacity: 1,
    transform: "translateY(0)"
  },
  [`.${selectTransitionName.fadeInTop}-enter-active`]: {
    transitionProperty: "opacity, transform",
    transitionDuration: "200ms",
    transitionTimingFunction: "ease-out"
  },
  [`.${selectTransitionName.fadeInTop}-exit-active`]: {
    transitionProperty: "opacity, transform",
    transitionDuration: "100ms",
    transitionTimingFunction: "ease-in"
  }
});
function createVariantAndSizeCompoundVariants$1(variant, paddingStart, paddingEnd) {
  return Object.entries({
    xs: {
      start: paddingStart != null ? paddingStart : "$2",
      end: paddingEnd != null ? paddingEnd : "$1"
    },
    sm: {
      start: paddingStart != null ? paddingStart : "$2_5",
      end: paddingEnd != null ? paddingEnd : "$1_5"
    },
    md: {
      start: paddingStart != null ? paddingStart : "$3",
      end: paddingEnd != null ? paddingEnd : "$2"
    },
    lg: {
      start: paddingStart != null ? paddingStart : "$4",
      end: paddingEnd != null ? paddingEnd : "$3"
    }
  }).map(([key, value]) => ({
    variant,
    size: key,
    css: {
      paddingInlineStart: value.start,
      paddingInlineEnd: value.end
    }
  }));
}
var selectTriggerStyles = css(baseInputResetStyles, {
  appearance: "none",
  display: "inline-flex",
  alignItems: "center",
  outline: "none",
  cursor: "pointer",
  "&:focus": {
    outline: "none"
  },
  compoundVariants: [
    ...createVariantAndSizeCompoundVariants$1("outline"),
    ...createVariantAndSizeCompoundVariants$1("filled"),
    ...createVariantAndSizeCompoundVariants$1("unstyled", 0, 0)
  ]
});
var selectSingleValueStyles = css({
  flexGrow: 1,
  flexShrink: 1,
  textAlign: "start",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
});
var selectMultiValueStyles = css({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "flex-start",
  flexWrap: "wrap",
  flexGrow: 1,
  flexShrink: 1,
  variants: {
    size: {
      xs: {
        gap: "$0_5",
        py: "$0_5"
      },
      sm: {
        gap: "$1",
        py: "$1"
      },
      md: {
        gap: "$1_5",
        py: "$1_5"
      },
      lg: {
        gap: "$2",
        py: "$2"
      }
    }
  }
});
var selectTagStyles = css({
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  gap: "$0_5",
  borderRadius: "$sm",
  py: 0,
  pl: "$2",
  lineHeight: "$none",
  variants: {
    variant: {
      subtle: {
        backgroundColor: "$neutral4",
        color: "$neutral12"
      },
      outline: {
        border: "1px solid $colors$neutral7",
        backgroundColor: "$loContrast",
        color: "$neutral12"
      }
    },
    size: {
      xs: {
        height: "$4",
        fontSize: "$2xs"
      },
      sm: {
        height: "$5",
        fontSize: "$xs"
      },
      md: {
        height: "$6",
        fontSize: "$sm"
      },
      lg: {
        height: "$7",
        fontSize: "$base"
      }
    }
  }
});
var selectTagCloseButtonStyles = css({
  appearance: "none",
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  height: "100%",
  outline: "none",
  borderRightRadius: "$sm",
  backgroundColor: "transparent",
  px: "$1",
  color: "inherit",
  lineHeight: "$none",
  textDecoration: "none",
  cursor: "pointer",
  userSelect: "none",
  transition: "color 250ms, background-color 250ms, box-shadow 250ms",
  "&:hover": {
    backgroundColor: "$neutral7"
  },
  "&:focus": {
    outline: "none",
    boxShadow: "$outline"
  }
});
var selectPlaceholderStyles = css(selectSingleValueStyles, {
  color: "$neutral9",
  opacity: 1
});
var selectIconStyles = css({
  flexGrow: 0,
  flexShrink: 0,
  marginInlineStart: "auto",
  color: "$neutral11",
  fontSize: "1.25em",
  pointerEvents: "none",
  transition: "transform 250ms",
  transformOrigin: "center",
  variants: {
    opened: {
      true: {
        transform: "rotate(-180deg)"
      }
    }
  }
});
var selectContentStyles = css({
  zIndex: "$dropdown",
  position: "absolute",
  left: 0,
  top: "100%",
  display: "flex",
  flexDirection: "column",
  width: "100%",
  overflow: "hidden",
  margin: 0,
  boxShadow: "$md",
  border: "1px solid $colors$neutral7",
  borderRadius: "$sm",
  backgroundColor: "$loContrast",
  padding: 0
});
var selectListboxStyles = css({
  position: "relative",
  display: "flex",
  flexDirection: "column",
  maxHeight: "$60",
  width: "100%",
  overflowY: "auto",
  margin: 0,
  padding: "$1",
  listStyle: "none"
});
var selectOptGroupStyles = css({});
var selectLabelStyles = css({
  display: "flex",
  alignItems: "center",
  py: "$2",
  px: "$3",
  color: "$neutral11",
  fontSize: "$xs",
  lineHeight: "$4"
});
var selectOptionStyles = css({
  position: "relative",
  display: "flex",
  alignItems: "center",
  borderRadius: "$sm",
  color: "$neutral12",
  fontSize: "$base",
  fontWeight: "$normal",
  lineHeight: "$6",
  cursor: "pointer",
  userSelect: "none",
  "&[data-disabled]": {
    color: "$neutral8",
    cursor: "not-allowed"
  },
  [`&[data-active]`]: {
    backgroundColor: "$neutral4"
  }
});
var selectOptionTextStyles = css({
  display: "inline-flex",
  alignItems: "center",
  py: "$2",
  paddingInlineStart: "$3",
  paddingInlineEnd: "$6"
});
var selectOptionIndicatorStyles = css({
  position: "absolute",
  top: 0,
  bottom: 0,
  right: 0,
  display: "flex",
  alignItems: "center",
  paddingInlineEnd: "$3",
  color: "$primary10",
  pointerEvents: "none"
});
var tooltipTransitionName = {
  scale: "hope-tooltip-scale-transition"
};
var tooltipTransitionStyles = globalCss({
  [`.${tooltipTransitionName.scale}-enter, .${tooltipTransitionName.scale}-exit-to`]: {
    opacity: 0,
    transform: "scale(0.90)"
  },
  [`.${tooltipTransitionName.scale}-enter-to, .${tooltipTransitionName.scale}-exit`]: {
    opacity: 1,
    transform: "scale(1)"
  },
  [`.${tooltipTransitionName.scale}-enter-active`]: {
    transitionProperty: "opacity, transform",
    transitionDuration: "200ms",
    transitionTimingFunction: "ease"
  },
  [`.${tooltipTransitionName.scale}-exit-active`]: {
    transitionProperty: "opacity, transform",
    transitionDuration: "150ms",
    transitionTimingFunction: "ease-in-out"
  }
});
var tooltipStyles = css({
  zIndex: "$tooltip",
  position: "absolute",
  maxWidth: "$96",
  boxShadow: "$md",
  borderRadius: "$sm",
  backgroundColor: "$neutral12",
  px: "$2",
  py: "$1",
  color: "$neutral1",
  fontSize: "$sm",
  fontWeight: "$normal",
  lineHeight: "$4"
});
var tooltipArrowStyles = css({
  zIndex: "$tooltip",
  position: "absolute",
  boxSize: "8px",
  backgroundColor: "inherit",
  transform: "rotate(45deg)"
});
var globalResetStyles = globalCss({
  "*, ::before, ::after": {
    boxSizing: "border-box",
    borderWidth: "0",
    borderStyle: "solid"
  },
  "*": {
    margin: 0
  },
  "html, body": {
    height: "100%"
  },
  html: {
    fontFamily: "$sans",
    lineHeight: "$base",
    fontSize: "16px"
  },
  body: {
    backgroundColor: "$background",
    color: "$neutral12",
    fontFamily: "inherit",
    lineHeight: "inherit",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale"
  },
  "h1, h2, h3, h4, h5, h6": {
    fontSize: "inherit",
    fontWeight: "inherit"
  },
  "p, h1, h2, h3, h4, h5, h6": {
    overflowWrap: "break-word"
  },
  "img, picture, video, canvas, svg": {
    display: "block",
    maxWidth: "100%"
  },
  "button, input, textarea, select, optgroup": {
    fontFamily: "inherit",
    fontSize: "100%"
  },
  "button:focus": {
    outline: "5px auto -webkit-focus-ring-color"
  },
  fieldset: {
    margin: 0,
    padding: 0
  },
  "ol, ul": {
    margin: 0,
    padding: 0
  },
  a: {
    backgroundColor: "transparent",
    color: "inherit",
    textDecoration: "inherit"
  }
});
function mergeStyleObject(sourceStyleObject, destStyleObject, destResponsiveStyleObject) {
  Object.entries(sourceStyleObject).forEach(([key, value]) => {
    if (isObject(value)) {
      if (key in destResponsiveStyleObject) {
        const atMediaRule = key;
        destResponsiveStyleObject[atMediaRule] = __spreadValues(__spreadValues({}, destResponsiveStyleObject[atMediaRule]), value);
      } else {
        destStyleObject[key] = __spreadValues(__spreadValues({}, destStyleObject[key]), value);
      }
    } else {
      destStyleObject[key] = value;
    }
  });
}
function toCssObject(props, baseStyles) {
  const destStyleObject = {};
  const destResponsiveStyleObject = {
    "@sm": {},
    "@md": {},
    "@lg": {},
    "@xl": {},
    "@2xl": {},
    "@reduce-motion": {},
    "@light": {},
    "@dark": {}
  };
  baseStyles == null ? void 0 : baseStyles.forEach((styles) => styles && mergeStyleObject(styles, destStyleObject, destResponsiveStyleObject));
  Object.entries(props).forEach(([prop, value]) => {
    if (value === null || value === void 0) {
      return;
    }
    if (prop === "css") {
      return;
    }
    if (prop.startsWith("_")) {
      destStyleObject[prop] = value;
    } else if (isObject(value)) {
      Object.keys(value).forEach((key) => {
        if (key === "@initial") {
          destStyleObject[prop] = value[key];
        } else if (key in destResponsiveStyleObject) {
          const atMediaRule = key;
          destResponsiveStyleObject[atMediaRule] = __spreadProps(__spreadValues({}, destResponsiveStyleObject[atMediaRule]), {
            [prop]: value[atMediaRule]
          });
        }
      });
    } else {
      destStyleObject[prop] = value;
    }
  });
  props.css && mergeStyleObject(props.css, destStyleObject, destResponsiveStyleObject);
  return __spreadValues(__spreadValues({}, destStyleObject), destResponsiveStyleObject);
}
function extendBaseTheme(type, themeConfig) {
  const isDark = type === "dark";
  const className = isDark ? colorModeClassNames.dark : colorModeClassNames.light;
  const finalConfig = isDark ? (0, import_lodash.default)({}, baseDarkThemeTokens, themeConfig) : themeConfig;
  const customTheme = createTheme(className, finalConfig);
  return (0, import_lodash.default)({}, baseTheme, customTheme);
}
function mapResponsive(prop, mapper) {
  if (isObject(prop)) {
    return Object.keys(prop).reduce((result, key) => {
      result[key] = mapper(prop[key]);
      return result;
    }, {});
  }
  if (prop != null) {
    return mapper(prop);
  }
  return null;
}
function colorTokenToCssVar(token) {
  if (!token.startsWith("$")) {
    return token;
  }
  return `var(--hope-colors-${token.substring(1)})`;
}
var visuallyHiddenStyles = css({
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0"
});
var HopeContext = createContext();
function applyGlobalTransitionStyles() {
  drawerTransitionStyles();
  menuTransitionStyles();
  modalTransitionStyles();
  notificationTransitionStyles();
  popoverTransitionStyles();
  selectTransitionStyles();
  tooltipTransitionStyles();
}
function HopeProvider(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const defaultProps = {
    enableCssReset: true
  };
  props = mergeProps(defaultProps, props);
  const lightTheme = extendBaseTheme("light", (_b = (_a = props.config) == null ? void 0 : _a.lightTheme) != null ? _b : {});
  const darkTheme = extendBaseTheme("dark", (_d = (_c = props.config) == null ? void 0 : _c.darkTheme) != null ? _d : {});
  const defaultColorMode = getDefaultColorMode((_f = (_e = props.config) == null ? void 0 : _e.initialColorMode) != null ? _f : "light");
  const defaultTheme = defaultColorMode === "dark" ? darkTheme : lightTheme;
  const [colorMode, rawSetColorMode] = createSignal(defaultColorMode);
  const [theme, setTheme] = createSignal(defaultTheme);
  const isDarkMode = () => colorMode() === "dark";
  const setColorMode = (value) => {
    rawSetColorMode(value);
    saveColorModeToLocalStorage(value);
  };
  const toggleColorMode = () => {
    setColorMode(isDarkMode() ? "light" : "dark");
  };
  const context = {
    components: (_h = (_g = props.config) == null ? void 0 : _g.components) != null ? _h : {},
    theme,
    colorMode,
    setColorMode,
    toggleColorMode
  };
  createEffect(() => {
    setTheme(isDarkMode() ? darkTheme : lightTheme);
    syncBodyColorModeClassName(isDarkMode());
  });
  if (props.enableCssReset) {
    globalResetStyles();
  }
  applyGlobalTransitionStyles();
  return createComponent(HopeContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}
function useTheme() {
  const context = useContext(HopeContext);
  if (!context) {
    throw new Error("[Hope UI]: useTheme must be used within a HopeProvider");
  }
  return context.theme;
}
function useStyleConfig() {
  const context = useContext(HopeContext);
  if (!context) {
    throw new Error("[Hope UI]: useStyleConfig must be used within a HopeProvider");
  }
  return context.components;
}
function useColorMode() {
  const context = useContext(HopeContext);
  if (!context) {
    throw new Error("[Hope UI]: useColorMode must be used within a HopeProvider");
  }
  return {
    colorMode: context.colorMode,
    setColorMode: context.setColorMode,
    toggleColorMode: context.toggleColorMode
  };
}
function useColorModeValue(light, dark) {
  const {
    colorMode
  } = useColorMode();
  return () => colorMode() === "dark" ? dark : light;
}
function createClassSelector(className) {
  return `.${className}`;
}
function classNames(...classNames2) {
  return classNames2.filter(Boolean).join(" ");
}
function valueToPercent(value, min3, max3) {
  return (value - min3) * 100 / (max3 - min3);
}
function getNextIndex(current, last, loop) {
  let next = current + 1;
  if (next > last) {
    next = loop ? 0 : last;
  }
  return next;
}
function getPrevIndex(current, last, loop) {
  let next = current - 1;
  if (next < 0) {
    next = loop ? last : 0;
  }
  return next;
}
var borderPropNames = {
  border: true,
  borderWidth: true,
  borderStyle: true,
  borderColor: true,
  borderTop: true,
  borderTopWidth: true,
  borderTopStyle: true,
  borderTopColor: true,
  borderRight: true,
  borderRightWidth: true,
  borderRightStyle: true,
  borderRightColor: true,
  borderBottom: true,
  borderBottomWidth: true,
  borderBottomStyle: true,
  borderBottomColor: true,
  borderLeft: true,
  borderLeftWidth: true,
  borderLeftStyle: true,
  borderLeftColor: true,
  borderX: true,
  borderY: true
};
var colorPropNames = {
  color: true,
  background: true,
  bg: true,
  backgroundColor: true,
  bgColor: true,
  opacity: true
};
var cssPropName = { css: true };
var flexboxPropNames = {
  alignItems: true,
  alignContent: true,
  alignSelf: true,
  justifyItems: true,
  justifyContent: true,
  justifySelf: true,
  flexDirection: true,
  flexWrap: true,
  flex: true,
  flexGrow: true,
  flexShrink: true,
  flexBasis: true,
  order: true
};
var gridLayoutPropNames = {
  gridTemplate: true,
  gridTemplateColumns: true,
  gridTemplateRows: true,
  gridTemplateAreas: true,
  gridArea: true,
  gridRow: true,
  gridRowStart: true,
  gridRowEnd: true,
  gridColumn: true,
  gridColumnStart: true,
  gridColumnEnd: true,
  gridAutoFlow: true,
  gridAutoColumns: true,
  gridAutoRows: true,
  placeItems: true,
  placeContent: true,
  placeSelf: true,
  gap: true,
  rowGap: true,
  columnGap: true
};
var interactivityPropNames = {
  appearance: true,
  userSelect: true,
  pointerEvents: true,
  resize: true,
  cursor: true,
  outline: true,
  outlineOffset: true,
  outlineColor: true
};
var layoutPropNames = {
  display: true,
  d: true,
  verticalAlign: true,
  overflow: true,
  overflowX: true,
  overflowY: true,
  objectFit: true,
  objectPosition: true
};
var marginPropNames = {
  margin: true,
  m: true,
  marginTop: true,
  mt: true,
  marginRight: true,
  mr: true,
  marginStart: true,
  ms: true,
  marginBottom: true,
  mb: true,
  marginLeft: true,
  ml: true,
  marginEnd: true,
  me: true,
  mx: true,
  my: true
};
var paddingPropNames = {
  padding: true,
  p: true,
  paddingTop: true,
  pt: true,
  paddingRight: true,
  pr: true,
  paddingStart: true,
  ps: true,
  paddingBottom: true,
  pb: true,
  paddingLeft: true,
  pl: true,
  paddingEnd: true,
  pe: true,
  px: true,
  py: true
};
var positionPropNames = {
  position: true,
  pos: true,
  zIndex: true,
  top: true,
  right: true,
  bottom: true,
  left: true
};
var pseudoSelectorPropNames = {
  _hover: true,
  _active: true,
  _focus: true,
  _highlighted: true,
  _focusWithin: true,
  _focusVisible: true,
  _disabled: true,
  _readOnly: true,
  _before: true,
  _after: true,
  _empty: true,
  _expanded: true,
  _checked: true,
  _grabbed: true,
  _pressed: true,
  _invalid: true,
  _valid: true,
  _loading: true,
  _selected: true,
  _hidden: true,
  _even: true,
  _odd: true,
  _first: true,
  _last: true,
  _notFirst: true,
  _notLast: true,
  _visited: true,
  _activeLink: true,
  _activeStep: true,
  _indeterminate: true,
  _groupHover: true,
  _peerHover: true,
  _groupFocus: true,
  _peerFocus: true,
  _groupFocusVisible: true,
  _peerFocusVisible: true,
  _groupActive: true,
  _peerActive: true,
  _groupSelected: true,
  _peerSelected: true,
  _groupDisabled: true,
  _peerDisabled: true,
  _groupInvalid: true,
  _peerInvalid: true,
  _groupChecked: true,
  _peerChecked: true,
  _groupFocusWithin: true,
  _peerFocusWithin: true,
  _peerPlaceholderShown: true,
  _placeholder: true,
  _placeholderShown: true,
  _fullScreen: true,
  _selection: true,
  _mediaDark: true,
  _mediaReduceMotion: true,
  _dark: true,
  _light: true
};
var radiiPropNames = {
  borderRadius: true,
  borderTopRightRadius: true,
  borderTopLeftRadius: true,
  borderBottomRightRadius: true,
  borderBottomLeftRadius: true,
  borderTopRadius: true,
  borderRightRadius: true,
  borderStartRadius: true,
  borderBottomRadius: true,
  borderLeftRadius: true,
  borderEndRadius: true,
  rounded: true,
  roundedTop: true,
  roundedRight: true,
  roundedStart: true,
  roundedBottom: true,
  roundedLeft: true,
  roundedEnd: true
};
var shadowPropNames = {
  textShadow: true,
  boxShadow: true,
  shadow: true
};
var sizePropNames = {
  width: true,
  w: true,
  minWidth: true,
  minW: true,
  maxWidth: true,
  maxW: true,
  height: true,
  h: true,
  minHeight: true,
  minH: true,
  maxHeight: true,
  maxH: true,
  boxSize: true
};
var transformPropNames = {
  transform: true,
  transformOrigin: true,
  clipPath: true
};
var transitionPropNames = {
  transition: true,
  transitionProperty: true,
  transitionTimingFunction: true,
  transitionDuration: true,
  transitionDelay: true,
  animation: true,
  willChange: true
};
var typographyPropNames = {
  fontFamily: true,
  fontSize: true,
  fontWeight: true,
  lineHeight: true,
  letterSpacing: true,
  textAlign: true,
  fontStyle: true,
  textTransform: true,
  textDecoration: true,
  noOfLines: true
};
var stylePropNames = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, borderPropNames), colorPropNames), flexboxPropNames), gridLayoutPropNames), interactivityPropNames), layoutPropNames), marginPropNames), paddingPropNames), positionPropNames), radiiPropNames), shadowPropNames), sizePropNames), transformPropNames), transitionPropNames), typographyPropNames), pseudoSelectorPropNames), cssPropName);
var styledSystemStyles = css({});
function createStyledSystemClass(props, baseStyles) {
  return styledSystemStyles({ css: toCssObject(props, baseStyles) });
}
function getUsedStylePropNames(props) {
  return Object.keys(props).filter((key) => key in stylePropNames);
}
var styled = (component, styleOptions) => {
  const hopeComponent = (props) => {
    const usedStylePropNames = getUsedStylePropNames(props);
    const propsWithDefault = mergeProps({
      as: component
    }, props);
    const [local, styleProps, others] = splitProps(propsWithDefault, ["as", "class", "className", "__baseStyle"], usedStylePropNames);
    const __baseStyles = createMemo(() => {
      const factoryBaseStyle = isFunction(styleOptions == null ? void 0 : styleOptions.baseStyle) ? styleOptions == null ? void 0 : styleOptions.baseStyle(props) : styleOptions == null ? void 0 : styleOptions.baseStyle;
      return [factoryBaseStyle, local.__baseStyle];
    });
    const classes = () => {
      return classNames(styleOptions == null ? void 0 : styleOptions.baseClass, local.class, local.className, createStyledSystemClass(styleProps, __baseStyles()));
    };
    return createComponent(Dynamic, mergeProps({
      get component() {
        var _a;
        return (_a = local.as) != null ? _a : "div";
      },
      get ["class"]() {
        return classes();
      }
    }, others));
  };
  hopeComponent.toString = () => (styleOptions == null ? void 0 : styleOptions.baseClass) ? createClassSelector(styleOptions.baseClass) : "";
  return hopeComponent;
};
function factory() {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(styled, {
    apply(target, thisArg, argArray) {
      return styled(...argArray);
    },
    get(_, element) {
      if (!cache.has(element)) {
        cache.set(element, styled(element));
      }
      return cache.get(element);
    }
  });
}
var hope = factory();
var Box = hope.div;
var hopeAccordionClass = "hope-accordion";
function Accordion(props) {
  var _a;
  const theme = useStyleConfig().Accordion;
  const [buttons, setButtons] = createSignal([]);
  const [state, setState] = createStore({
    _expandedIndex: (_a = props.defaultIndex) != null ? _a : props.allowMultiple ? [] : -1,
    focusedIndex: -1,
    get isControlled() {
      return props.index !== void 0;
    },
    get expandedIndex() {
      return this.isControlled ? props.index : this._expandedIndex;
    }
  });
  const [local, others] = splitProps(props, ["class", "allowMultiple", "index", "defaultIndex", "onChange"]);
  const reverseButtons = createMemo(() => buttons().slice().reverse());
  const setFocusedIndex = (index) => {
    setState("focusedIndex", index);
  };
  const setExpandedIndex = (index, isExpanded) => {
    var _a2;
    let nextState = -1;
    if (local.allowMultiple && isArray(state.expandedIndex)) {
      nextState = isExpanded ? [...state.expandedIndex, index] : state.expandedIndex.filter((idx) => idx !== index);
    } else if (isExpanded) {
      nextState = index;
    } else {
      nextState = -1;
    }
    setState("_expandedIndex", nextState);
    (_a2 = local.onChange) == null ? void 0 : _a2.call(local, nextState);
  };
  const isExpandedIndex = (index) => {
    return isArray(state.expandedIndex) ? state.expandedIndex.includes(index) : state.expandedIndex === index;
  };
  const registerAccordionButton = (node) => {
    return setButtons((prev) => [...prev, node]).length - 1;
  };
  const focusNextAccordionButton = () => {
    const lastIndex = buttons().length - 1;
    let nextIndex = getNextIndex(state.focusedIndex, lastIndex, true);
    let nextButton = buttons()[nextIndex];
    while (nextButton.disabled) {
      nextIndex = getNextIndex(nextIndex, lastIndex, true);
      nextButton = buttons()[nextIndex];
    }
    nextButton.focus();
  };
  const focusPrevAccordionButton = () => {
    const lastIndex = buttons().length - 1;
    let prevIndex = getPrevIndex(state.focusedIndex, lastIndex, true);
    let prevButton = buttons()[prevIndex];
    while (prevButton.disabled) {
      prevIndex = getPrevIndex(prevIndex, lastIndex, true);
      prevButton = buttons()[prevIndex];
    }
    prevButton.focus();
  };
  const focusFirstAccordionButton = () => {
    var _a2;
    (_a2 = buttons().find((button) => !button.disabled)) == null ? void 0 : _a2.focus();
  };
  const focusLastAccordionButton = () => {
    var _a2;
    (_a2 = reverseButtons().find((button) => !button.disabled)) == null ? void 0 : _a2.focus();
  };
  const classes = () => classNames(local.class, hopeAccordionClass);
  onCleanup(() => {
    setFocusedIndex(-1);
  });
  const context = {
    state,
    setFocusedIndex,
    setExpandedIndex,
    isExpandedIndex,
    registerAccordionButton,
    focusNextAccordionButton,
    focusPrevAccordionButton,
    focusFirstAccordionButton,
    focusLastAccordionButton
  };
  return createComponent(AccordionContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a2;
          return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.root;
        }
      }, others));
    }
  });
}
Accordion.toString = () => createClassSelector(hopeAccordionClass);
var AccordionContext = createContext();
function useAccordionContext() {
  const context = useContext(AccordionContext);
  if (!context) {
    throw new Error("[Hope UI]: useAccordionContext must be used within a `<Accordion />` component");
  }
  return context;
}
var accordionItemStyles = css({
  borderTopWidth: "1px",
  borderColor: "$neutral7",
  overflowAnchor: "none",
  "&:last-of-type": {
    borderBottomWidth: "1px"
  }
});
var accordionButtonStyles = css({
  appearance: "none",
  display: "flex",
  alignItems: "center",
  width: "100%",
  outline: "none",
  backgroundColor: "transparent",
  px: "$4",
  py: "$2",
  color: "inherit",
  fontSize: "$base",
  lineHeight: "$6",
  cursor: "pointer",
  transition: "background-color 250ms",
  "&:disabled": {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  "&:hover": {
    backgroundColor: "$neutral4"
  },
  "&:focus": {
    outline: "none",
    boxShadow: "$outline"
  }
});
var accordionIconStyles = css({
  flexGrow: 0,
  flexShrink: 0,
  fontSize: "1.25em",
  pointerEvents: "none",
  transition: "transform 250ms",
  transformOrigin: "center",
  variants: {
    expanded: {
      true: {
        transform: "rotate(-180deg)"
      }
    },
    disabled: {
      true: {
        opacity: 0.4
      }
    }
  }
});
var accordionPanelStyles = css({
  pt: "$2",
  px: "$4",
  pb: "$4"
});
function isElement2(el) {
  return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
}
function isHTMLElement2(el) {
  var _a;
  if (!isElement2(el)) {
    return false;
  }
  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
  return el instanceof win.HTMLElement;
}
function getOwnerDocument(node) {
  var _a;
  return isElement2(node) ? (_a = node.ownerDocument) != null ? _a : document : document;
}
function isValidEvent(event, element) {
  const target = event.target;
  if (event.button > 0) {
    return false;
  }
  if (target) {
    const doc = getOwnerDocument(target);
    if (!doc.body.contains(target))
      return false;
  }
  return !(element == null ? void 0 : element.contains(target));
}
function normalizeEventKey(event) {
  const { key, keyCode } = event;
  const isArrowKey = keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0;
  const eventKey = isArrowKey ? `Arrow${key}` : key;
  return eventKey;
}
function getActiveElement(node) {
  const doc = getOwnerDocument(node);
  return doc == null ? void 0 : doc.activeElement;
}
function contains2(parent, child) {
  if (!parent) {
    return false;
  }
  return parent === child || parent.contains(child);
}
function getRelatedTarget(event) {
  var _a, _b;
  const target = (_a = event.target) != null ? _a : event.currentTarget;
  const activeElement = getActiveElement(target);
  return (_b = event.relatedTarget) != null ? _b : activeElement;
}
function isScrollable(element) {
  return element && element.clientHeight < element.scrollHeight;
}
function maintainScrollVisibility(activeElement, scrollParent) {
  const { offsetHeight, offsetTop } = activeElement;
  const { offsetHeight: parentOffsetHeight, scrollTop } = scrollParent;
  const isAbove = offsetTop < scrollTop;
  const isBelow = offsetTop + offsetHeight > scrollTop + parentOffsetHeight;
  if (isAbove) {
    scrollParent.scrollTo(0, offsetTop);
  } else if (isBelow) {
    scrollParent.scrollTo(0, offsetTop - parentOffsetHeight + offsetHeight);
  }
}
function isChildrenFunction(props) {
  const childrenProp = Object.getOwnPropertyDescriptor(props, "children");
  if (childrenProp == null) {
    return false;
  }
  return isFunction(childrenProp.value);
}
var hopeAccordionItemClass = "hope-accordion__item";
function AccordionItem(props) {
  const defaultIdPrefix = `hope-accordion-item-${createUniqueId()}`;
  const theme = useStyleConfig().Accordion;
  const accordionContext = useAccordionContext();
  const [state, setState] = createStore({
    index: -1,
    get buttonId() {
      return `${defaultIdPrefix}-button`;
    },
    get panelId() {
      return `${defaultIdPrefix}-panel`;
    },
    get expanded() {
      return accordionContext.isExpandedIndex(this.index);
    },
    get disabled() {
      var _a;
      return (_a = props.disabled) != null ? _a : false;
    }
  });
  const [local, others] = splitProps(props, ["class", "children"]);
  const registerButton = (el) => {
    const index = accordionContext.registerAccordionButton(el);
    setState("index", index);
  };
  const setFocusedIndex = () => {
    accordionContext.setFocusedIndex(state.index);
  };
  const toggleExpandedState = () => {
    accordionContext.setExpandedIndex(state.index, !state.expanded);
  };
  const keyMap = createMemo(() => ({
    ArrowDown: accordionContext.focusNextAccordionButton,
    ArrowUp: accordionContext.focusPrevAccordionButton,
    Home: accordionContext.focusFirstAccordionButton,
    End: accordionContext.focusLastAccordionButton
  }));
  const onButtonKeyDown = (event) => {
    const eventKey = normalizeEventKey(event);
    const action = keyMap()[eventKey];
    if (action) {
      event.preventDefault();
      callHandler(action, event);
    }
  };
  const expandedAccessor = () => state.expanded;
  const disabledAccessor = () => state.disabled;
  const classes = () => classNames(local.class, hopeAccordionItemClass, accordionItemStyles());
  const context = {
    state,
    registerButton,
    setFocusedIndex,
    toggleExpandedState,
    onButtonKeyDown
  };
  return createComponent(AccordionItemContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.item;
        }
      }, others, {
        get children() {
          return createComponent(Show, {
            get when() {
              return isChildrenFunction(local);
            },
            get fallback() {
              return local.children;
            },
            get children() {
              var _a;
              return (_a = local.children) == null ? void 0 : _a.call(local, {
                expanded: expandedAccessor,
                disabled: disabledAccessor
              });
            }
          });
        }
      }));
    }
  });
}
AccordionItem.toString = () => createClassSelector(hopeAccordionItemClass);
var AccordionItemContext = createContext();
function useAccordionItemContext() {
  const context = useContext(AccordionItemContext);
  if (!context) {
    throw new Error("[Hope UI]: useAccordionItemContext must be used within a `<AccordionItem />` component");
  }
  return context;
}
var hopeAccordionButtonClass = "hope-accordion__button";
function AccordionButton(props) {
  const theme = useStyleConfig().Accordion;
  const accordionItemContext = useAccordionItemContext();
  const [local, others] = splitProps(props, ["ref", "class", "disabled", "onClick", "onFocus", "onKeyDown"]);
  const assignRef = (el) => {
    accordionItemContext.registerButton(el);
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const onClick = (event) => {
    callHandler(local.onClick, event);
    accordionItemContext.toggleExpandedState();
  };
  const onFocus = (event) => {
    callHandler(local.onFocus, event);
    accordionItemContext.setFocusedIndex();
  };
  const onKeyDown = (event) => {
    chainHandlers(local.onKeyDown, accordionItemContext.onButtonKeyDown)(event);
  };
  const classes = () => classNames(local.class, hopeAccordionButtonClass, accordionButtonStyles());
  return createComponent(hope.button, mergeProps({
    role: "button",
    type: "button",
    ref: assignRef,
    get id() {
      return accordionItemContext.state.buttonId;
    },
    get ["aria-controls"]() {
      return accordionItemContext.state.panelId;
    },
    get ["aria-expanded"]() {
      return accordionItemContext.state.expanded;
    },
    get disabled() {
      return accordionItemContext.state.disabled;
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.button;
    },
    onClick,
    onFocus,
    onKeyDown
  }, others));
}
AccordionButton.toString = () => createClassSelector(hopeAccordionButtonClass);
var iconStyles = css({
  display: "inline-block",
  flexShrink: 0,
  boxSize: "1em",
  color: "currentColor",
  lineHeight: "1em",
  verticalAlign: "middle"
});
var _tmpl$$i = template(`<svg><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`, 4, true);
var fallbackIcon = {
  viewBox: "0 0 24 24",
  path: () => _tmpl$$i.cloneNode(true)
};
var hopeIconClass = "hope-icon";
function Icon(props) {
  const defaultProps = {
    viewBox: fallbackIcon.viewBox
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["as", "class", "children", "viewBox"]);
  const classes = () => classNames(local.class, hopeIconClass, iconStyles());
  const shouldRenderComponent = () => local.as && !isString(local.as);
  return createComponent(Show, {
    get when() {
      return shouldRenderComponent();
    },
    get fallback() {
      return createComponent(hope.svg, mergeProps({
        get ["class"]() {
          return classes();
        },
        get viewBox() {
          return local.viewBox;
        }
      }, others, {
        get children() {
          return createComponent(Show, {
            get when() {
              return local.children;
            },
            get fallback() {
              return fallbackIcon.path;
            },
            get children() {
              return local.children;
            }
          });
        }
      }));
    },
    get children() {
      return createComponent(Box, mergeProps({
        get as() {
          return local.as;
        },
        get ["class"]() {
          return classes();
        }
      }, others));
    }
  });
}
Icon.toString = () => createClassSelector(hopeIconClass);
function createIcon(options) {
  const {
    viewBox = "0 0 24 24",
    defaultProps = {}
  } = options;
  const IconComponent = (props) => {
    return createComponent(Icon, mergeProps({
      viewBox
    }, defaultProps, props, {
      get children() {
        return options.path;
      }
    }));
  };
  IconComponent.toString = () => createClassSelector(hopeIconClass);
  return IconComponent;
}
var _tmpl$$h = template(`<svg><path d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg>`, 4, true);
var IconCaretDown = createIcon({
  viewBox: "0 0 15 15",
  path: () => _tmpl$$h.cloneNode(true)
});
var hopeAccordionIconClass = "hope-accordion__icon";
function AccordionIcon(props) {
  const theme = useStyleConfig().Accordion;
  const accordionItemContext = useAccordionItemContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => {
    return classNames(local.class, hopeAccordionIconClass, accordionIconStyles({
      expanded: accordionItemContext.state.expanded,
      disabled: accordionItemContext.state.disabled
    }));
  };
  return createComponent(IconCaretDown, mergeProps({
    "aria-hidden": true,
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.icon;
    }
  }, others));
}
AccordionIcon.toString = () => createClassSelector(hopeAccordionIconClass);
var collapseStyles = css({
  overflow: "hidden"
});
var hopeCollapseClass = "hope-collapse";
function Collapse(props) {
  const defaultProps = {
    animateOpacity: true,
    expandDuration: 300,
    expandTimingFunction: "ease",
    collapseDuration: 300,
    collapseTimingFunction: "ease",
    keepAlive: true
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "children", "expanded", "animateOpacity", "expandDuration", "expandTimingFunction", "collapseDuration", "collapseTimingFunction", "keepAlive"]);
  const resolvedChildren = children(() => local.children);
  const classes = () => {
    return classNames(local.class, hopeCollapseClass, collapseStyles());
  };
  const collapsedStyles = () => {
    const styles = {
      height: 0
    };
    if (local.animateOpacity) {
      return __spreadProps(__spreadValues({}, styles), {
        opacity: 0
      });
    }
    return styles;
  };
  const expandedStyles = (el) => {
    const styles = {
      height: `${el.scrollHeight}px`
    };
    if (local.animateOpacity) {
      return __spreadProps(__spreadValues({}, styles), {
        opacity: 1
      });
    }
    return styles;
  };
  const onEnterTransition = (el, done) => {
    const animation = el.animate([collapsedStyles(), expandedStyles(el)], {
      duration: local.expandDuration,
      easing: local.expandTimingFunction
    });
    animation.finished.then(done);
  };
  const onExitTransition = (el, done) => {
    const animation = el.animate([expandedStyles(el), collapsedStyles()], {
      duration: local.collapseDuration,
      easing: local.collapseTimingFunction
    });
    animation.finished.then(done);
  };
  return createComponent(Transition, {
    onEnter: onEnterTransition,
    onExit: onExitTransition,
    get children() {
      return createComponent(Show, {
        get when() {
          return local.expanded;
        },
        get children() {
          return createComponent(Box, mergeProps({
            get ["class"]() {
              return classes();
            }
          }, others, {
            get children() {
              return createComponent(Show, {
                get when() {
                  return local.keepAlive;
                },
                get fallback() {
                  return local.children;
                },
                get children() {
                  return resolvedChildren();
                }
              });
            }
          }));
        }
      });
    }
  });
}
Collapse.toString = () => createClassSelector(hopeCollapseClass);
var hopeAccordionPanelClass = "hope-accordion__panel";
function AccordionPanel(props) {
  const theme = useStyleConfig().Accordion;
  const accordionItemContext = useAccordionItemContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeAccordionPanelClass, accordionPanelStyles());
  return createComponent(Collapse, {
    get expanded() {
      return accordionItemContext.state.expanded;
    },
    get children() {
      return createComponent(Box, mergeProps({
        role: "region",
        get id() {
          return accordionItemContext.state.panelId;
        },
        get ["aria-labelledby"]() {
          return accordionItemContext.state.buttonId;
        },
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.panel;
        }
      }, others));
    }
  });
}
AccordionPanel.toString = () => createClassSelector(hopeAccordionPanelClass);
var alertIconStyles = css({
  flexShrink: 0
});
var alertTitleStyles = css({
  fontWeight: "$semibold"
});
var alertDescriptionStyles = css({
  display: "inline-block"
});
var alertStyles = css({
  position: "relative",
  display: "flex",
  alignItems: "center",
  borderRadius: "$sm",
  px: "$4",
  py: "$3",
  fontSize: "$base",
  lineHeight: "$6",
  variants: {
    variant: {
      solid: {},
      subtle: {},
      "left-accent": {
        borderLeftStyle: "solid",
        borderLeftWidth: "$sizes$1"
      },
      "top-accent": {
        borderTopStyle: "solid",
        borderTopWidth: "$sizes$1"
      }
    },
    status: {
      success: {},
      info: {},
      warning: {},
      danger: {}
    }
  },
  compoundVariants: [
    {
      variant: "solid",
      status: "success",
      css: {
        backgroundColor: "$success9",
        color: "white"
      }
    },
    {
      variant: "solid",
      status: "info",
      css: {
        backgroundColor: "$info9",
        color: "white"
      }
    },
    {
      variant: "solid",
      status: "warning",
      css: {
        backgroundColor: "$warning9",
        color: "$blackAlpha12"
      }
    },
    {
      variant: "solid",
      status: "danger",
      css: {
        backgroundColor: "$danger9",
        color: "white"
      }
    },
    {
      variant: "subtle",
      status: "success",
      css: {
        backgroundColor: "$success3",
        color: "$success11",
        [`& .${alertIconStyles}`]: {
          color: "$success9"
        }
      }
    },
    {
      variant: "subtle",
      status: "info",
      css: {
        backgroundColor: "$info3",
        color: "$info11",
        [`& .${alertIconStyles}`]: {
          color: "$info9"
        }
      }
    },
    {
      variant: "subtle",
      status: "warning",
      css: {
        backgroundColor: "$warning3",
        color: "$warning11",
        [`& .${alertIconStyles}`]: {
          color: "$warning9"
        }
      }
    },
    {
      variant: "subtle",
      status: "danger",
      css: {
        backgroundColor: "$danger3",
        color: "$danger11",
        [`& .${alertIconStyles}`]: {
          color: "$danger9"
        }
      }
    },
    {
      variant: "left-accent",
      status: "success",
      css: {
        borderLeftColor: "$success9",
        backgroundColor: "$success3",
        color: "$success11",
        [`& .${alertIconStyles}`]: {
          color: "$success9"
        }
      }
    },
    {
      variant: "left-accent",
      status: "info",
      css: {
        borderLeftColor: "$info9",
        backgroundColor: "$info3",
        color: "$info11",
        [`& .${alertIconStyles}`]: {
          color: "$info9"
        }
      }
    },
    {
      variant: "left-accent",
      status: "warning",
      css: {
        borderLeftColor: "$warning9",
        backgroundColor: "$warning3",
        color: "$warning11",
        [`& .${alertIconStyles}`]: {
          color: "$warning9"
        }
      }
    },
    {
      variant: "left-accent",
      status: "danger",
      css: {
        borderLeftColor: "$danger9",
        backgroundColor: "$danger3",
        color: "$danger11",
        [`& .${alertIconStyles}`]: {
          color: "$danger9"
        }
      }
    },
    {
      variant: "top-accent",
      status: "success",
      css: {
        borderTopColor: "$success9",
        backgroundColor: "$success3",
        color: "$success11",
        [`& .${alertIconStyles}`]: {
          color: "$success9"
        }
      }
    },
    {
      variant: "top-accent",
      status: "info",
      css: {
        borderTopColor: "$info9",
        backgroundColor: "$info3",
        color: "$info11",
        [`& .${alertIconStyles}`]: {
          color: "$info9"
        }
      }
    },
    {
      variant: "top-accent",
      status: "warning",
      css: {
        borderTopColor: "$warning9",
        backgroundColor: "$warning3",
        color: "$warning11",
        [`& .${alertIconStyles}`]: {
          color: "$warning9"
        }
      }
    },
    {
      variant: "top-accent",
      status: "danger",
      css: {
        borderTopColor: "$danger9",
        backgroundColor: "$danger3",
        color: "$danger11",
        [`& .${alertIconStyles}`]: {
          color: "$danger9"
        }
      }
    }
  ]
});
var hopeAlertClass = "hope-alert";
function Alert(props) {
  var _a, _b, _c, _d, _e, _f;
  const theme = useStyleConfig().Alert;
  const defaultProps = {
    variant: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.variant) != null ? _c : "subtle",
    status: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.root) == null ? void 0 : _e.status) != null ? _f : "info"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "variant", "status"]);
  const classes = () => {
    return classNames(local.class, hopeAlertClass, alertStyles({
      variant: local.variant,
      status: local.status
    }));
  };
  const statusAccessor = () => local.status;
  const context = {
    status: statusAccessor
  };
  return createComponent(AlertContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        role: "alert",
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a2;
          return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.root;
        }
      }, others));
    }
  });
}
Alert.toString = () => createClassSelector(hopeAlertClass);
var AlertContext = createContext();
function useAlertContext() {
  const context = useContext(AlertContext);
  if (!context) {
    throw new Error("[Hope UI]: useAlertContext must be used within an `<Alert />` component");
  }
  return context;
}
var hopeAlertDescriptionClass = "hope-alert__description";
function AlertDescription(props) {
  const theme = useStyleConfig().Alert;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeAlertDescriptionClass, alertDescriptionStyles());
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.description;
    }
  }, others));
}
AlertDescription.toString = () => createClassSelector(hopeAlertDescriptionClass);
var _tmpl$$g = template(`<svg><path fill="currentColor" d="M16 2a14 14 0 1 0 14 14A14 14 0 0 0 16 2Zm-2 19.59l-5-5L10.59 15L14 18.41L21.41 11l1.596 1.586Z"></path></svg>`, 4, true);
var _tmpl$2$3 = template(`<svg><path fill="none" d="m14 21.591l-5-5L10.591 15L14 18.409L21.41 11l1.595 1.585L14 21.591z"></path></svg>`, 4, true);
var IconCheckCircleSolid = createIcon({
  viewBox: "0 0 32 32",
  path: () => [_tmpl$$g.cloneNode(true), _tmpl$2$3.cloneNode(true)]
});
var _tmpl$$f = template(`<svg><path fill="currentColor" d="M16 2C8.3 2 2 8.3 2 16s6.3 14 14 14s14-6.3 14-14S23.7 2 16 2zm-1.1 6h2.2v11h-2.2V8zM16 25c-.8 0-1.5-.7-1.5-1.5S15.2 22 16 22s1.5.7 1.5 1.5S16.8 25 16 25z"></path></svg>`, 4, true);
var IconExclamationCircleSolid = createIcon({
  viewBox: "0 0 32 32",
  path: () => _tmpl$$f.cloneNode(true)
});
var _tmpl$$e = template(`<svg><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M29.4898 29.8706C29.3402 29.9548 29.1713 29.9991 28.9996 29.9993H2.99961C2.82787 29.9991 2.65905 29.9548 2.5094 29.8706C2.35976 29.7864 2.23433 29.665 2.14521 29.5182C2.05608 29.3713 2.00626 29.2041 2.00055 29.0325C1.99485 28.8608 2.03344 28.6907 2.1126 28.5382L15.1126 3.53821C15.1971 3.37598 15.3245 3.23999 15.4808 3.14514C15.6372 3.05017 15.8167 3 15.9996 3C16.1825 3 16.362 3.05017 16.5184 3.14514C16.6748 3.23999 16.8021 3.37598 16.8866 3.53821L29.8866 28.5382C29.9658 28.6907 30.0044 28.8608 29.9986 29.0325C29.9929 29.2041 29.9431 29.3713 29.854 29.5182C29.7649 29.665 29.6395 29.7864 29.4898 29.8706ZM16.0016 6.16919V6.17029H15.9976V6.16919H16.0016ZM15.9996 25.9993C15.7029 25.9993 15.4129 25.9113 15.1662 25.7465C14.9196 25.5817 14.7273 25.3474 14.6138 25.0734C14.5996 25.0391 14.5867 25.0044 14.5752 24.9694C14.4942 24.724 14.4778 24.4613 14.5284 24.2067C14.5863 23.9156 14.7292 23.6484 14.9389 23.4386C14.9652 23.4124 14.9923 23.3872 15.0202 23.3632C15.2159 23.1945 15.4524 23.0787 15.707 23.0281C15.7433 23.0209 15.7799 23.015 15.8165 23.0105C16.0723 22.979 16.3326 23.014 16.572 23.1129L16.5736 23.1135C16.8477 23.2271 17.082 23.4193 17.2468 23.6659C17.2674 23.6968 17.2868 23.7283 17.305 23.7604C17.4322 23.9852 17.4996 24.2397 17.4996 24.4993C17.4996 24.8971 17.3416 25.2787 17.0603 25.5599C16.7789 25.8413 16.3974 25.9993 15.9996 25.9993ZM17.1246 20.9993H14.8746V11.9993H17.1246V20.9993Z"></path></svg>`, 4, true);
var IconExclamationTriangleSolid = createIcon({
  viewBox: "0 0 32 32",
  path: () => _tmpl$$e.cloneNode(true)
});
var _tmpl$$d = template(`<svg><path fill="none" d="M16 8a1.5 1.5 0 1 1-1.5 1.5A1.5 1.5 0 0 1 16 8Zm4 13.875h-2.875v-8H13v2.25h1.875v5.75H12v2.25h8Z"></path></svg>`, 4, true);
var _tmpl$2$2 = template(`<svg><path fill="currentColor" d="M16 2a14 14 0 1 0 14 14A14 14 0 0 0 16 2Zm0 6a1.5 1.5 0 1 1-1.5 1.5A1.5 1.5 0 0 1 16 8Zm4 16.125h-8v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"></path></svg>`, 4, true);
var IconInfoCircleSolid = createIcon({
  viewBox: "0 0 32 32",
  path: () => [_tmpl$$d.cloneNode(true), _tmpl$2$2.cloneNode(true)]
});
var hopeAlertIconClass = "hope-alert__icon";
function AlertIcon(props) {
  const theme = useStyleConfig().Alert;
  const {
    status
  } = useAlertContext();
  const defaultProps = {
    boxSize: "$6"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["as", "class"]);
  const classes = () => classNames(local.class, hopeAlertIconClass, alertIconStyles());
  const icon = () => {
    if (local.as) {
      return local.as;
    }
    switch (status()) {
      case "success":
        return IconCheckCircleSolid;
      case "info":
        return IconInfoCircleSolid;
      case "warning":
        return IconExclamationTriangleSolid;
      case "danger":
        return IconExclamationCircleSolid;
    }
  };
  return createComponent(Icon, mergeProps({
    get as() {
      return icon();
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.icon;
    }
  }, others));
}
AlertIcon.toString = () => createClassSelector(hopeAlertIconClass);
var hopeAlertTitleClass = "hope-alert__title";
function AlertTitle(props) {
  const theme = useStyleConfig().Alert;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeAlertTitleClass, alertTitleStyles());
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.title;
    }
  }, others));
}
AlertTitle.toString = () => createClassSelector(hopeAlertTitleClass);
var anchorStyles = css({
  position: "relative",
  outline: "none",
  backgroundColor: "transparent",
  textDecoration: "none",
  cursor: "pointer",
  transition: "text-decoration 250ms",
  "&:hover": {
    textDecoration: "underline"
  },
  "&:focus": {
    boxShadow: "$outline"
  }
});
var hopeAnchorClass = "hope-anchor";
function Anchor(props) {
  const theme = useStyleConfig().Anchor;
  const [local, others] = splitProps(props, ["class", "external"]);
  const classes = () => classNames(local.class, hopeAnchorClass, anchorStyles());
  return createComponent(hope.a, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      return theme == null ? void 0 : theme.baseStyle;
    },
    get target() {
      return local.external ? "_blank" : void 0;
    },
    get rel() {
      return local.external ? "noopener noreferrer" : void 0;
    }
  }, others));
}
Anchor.toString = () => createClassSelector(hopeAnchorClass);
var aspectRatioStyles = css({
  position: "relative",
  "&::before": {
    height: 0,
    content: "''",
    display: "block"
  },
  "& > *:not(style)": {
    overflow: "hidden",
    position: "absolute",
    top: "0",
    right: "0",
    bottom: "0",
    left: "0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: "100%",
    height: "100%"
  },
  "& > img, & > video": {
    objectFit: "cover"
  }
});
var hopeAspectRatioClass = "hope-aspect-ratio";
function AspectRatio(props) {
  const defaultProps = {
    ratio: 4 / 3
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "ratio"]);
  const classes = () => classNames(local.class, hopeAspectRatioClass, aspectRatioStyles());
  const paddingBottom = () => mapResponsive(local.ratio, (r2) => `${1 / r2 * 100}%`);
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get _before() {
      return {
        paddingBottom: paddingBottom()
      };
    }
  }, others));
}
AspectRatio.toString = () => createClassSelector(hopeAspectRatioClass);
var hopeIconButtonClass = "hope-icon-button";
var buttonIconStyles = css({
  display: "inline-flex",
  alignSelf: "center",
  flexShrink: 0
});
var buttonLoaderStyles = css({
  position: "absolute",
  display: "flex",
  alignItems: "center",
  flexShrink: 0,
  fontSize: "1em",
  lineHeight: "$normal",
  variants: {
    withLoadingText: {
      true: {
        position: "relative"
      }
    }
  }
});
var buttonIconSpinnerStyles = css({
  fontSize: "1.3em",
  animation: `1s linear infinite ${spin}`
});
function createSizeVariant$1(config2) {
  return {
    height: config2.height,
    py: 0,
    px: config2.paddingX,
    fontSize: config2.fontSize,
    [`&.${hopeIconButtonClass}`]: {
      width: config2.height,
      padding: "0"
    }
  };
}
function createCompactSizeCompoundVariant(config2) {
  return {
    height: config2.height,
    py: 0,
    px: config2.paddingX,
    [`&.${hopeIconButtonClass}`]: {
      width: config2.height,
      padding: "0"
    }
  };
}
function createSolidCompoundVariant(config2) {
  return {
    backgroundColor: config2.bgColor,
    color: config2.color,
    "&:hover": {
      backgroundColor: config2.bgColorHover
    }
  };
}
function createSubtleCompoundVariant(config2) {
  return {
    backgroundColor: config2.bgColor,
    color: config2.color,
    "&:hover": {
      backgroundColor: config2.bgColorHover
    },
    "&:active": {
      backgroundColor: config2.bgColorActive
    }
  };
}
function createOutlineCompoundVariant(config2) {
  return {
    borderColor: config2.borderColor,
    color: config2.color,
    "&:hover": {
      borderColor: config2.borderColorHover,
      backgroundColor: config2.bgColorHover
    },
    "&:active": {
      backgroundColor: config2.bgColorActive
    }
  };
}
function createGhostCompoundVariant(config2) {
  return {
    color: config2.color,
    "&:hover": {
      backgroundColor: config2.bgColorHover
    },
    "&:active": {
      backgroundColor: config2.bgColorActive
    }
  };
}
var buttonStyles = css({
  appearance: "none",
  position: "relative",
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  outline: "none",
  borderRadius: "$sm",
  padding: "0",
  fontWeight: "$medium",
  lineHeight: "$none",
  textDecoration: "none",
  cursor: "pointer",
  userSelect: "none",
  whiteSpace: "nowrap",
  verticalAlign: "middle",
  transition: "color 250ms, background-color 250ms, box-shadow 250ms",
  "&:focus": {
    outline: "none",
    boxShadow: "$outline"
  },
  "&:disabled, &:hover:disabled": {
    color: "$neutral7",
    cursor: "not-allowed"
  },
  variants: {
    variant: {
      solid: {
        border: "1px solid transparent",
        "&:disabled, &:hover:disabled": {
          backgroundColor: "$neutral3"
        }
      },
      subtle: {
        border: "1px solid transparent",
        "&:disabled, &:hover:disabled": {
          backgroundColor: "$neutral3"
        }
      },
      outline: {
        borderStyle: "solid",
        borderWidth: "1px",
        backgroundColor: "transparent",
        "&:disabled, &:hover:disabled": {
          borderColor: "$neutral3"
        }
      },
      dashed: {
        borderStyle: "dashed",
        borderWidth: "1px",
        backgroundColor: "transparent",
        "&:disabled, &:hover:disabled": {
          borderColor: "$neutral3"
        }
      },
      ghost: {
        border: "1px solid transparent",
        backgroundColor: "transparent"
      }
    },
    colorScheme: {
      primary: {},
      accent: {},
      neutral: {},
      success: {},
      info: {},
      warning: {},
      danger: {}
    },
    size: {
      xs: createSizeVariant$1({
        height: "$6",
        paddingX: "$2",
        fontSize: "$xs",
        spacing: "$1"
      }),
      sm: createSizeVariant$1({
        height: "$8",
        paddingX: "$3",
        fontSize: "$sm",
        spacing: "$1_5"
      }),
      md: createSizeVariant$1({
        height: "$10",
        paddingX: "$4",
        fontSize: "$base",
        spacing: "$1_5"
      }),
      lg: createSizeVariant$1({
        height: "$12",
        paddingX: "$6",
        fontSize: "$lg",
        spacing: "$2"
      }),
      xl: createSizeVariant$1({
        height: "$16",
        paddingX: "$10",
        fontSize: "$xl",
        spacing: "$2"
      })
    },
    compact: {
      true: {},
      false: {}
    },
    fullWidth: {
      true: {
        display: "flex",
        width: "100%"
      },
      false: {
        display: "inline-flex",
        width: "auto"
      }
    },
    loading: {
      true: {
        opacity: "0.75",
        cursor: "default",
        pointerEvents: "none"
      },
      false: {}
    }
  },
  compoundVariants: [
    {
      variant: "solid",
      colorScheme: "primary",
      css: createSolidCompoundVariant({
        color: "white",
        bgColor: "$primary9",
        bgColorHover: "$primary10"
      })
    },
    {
      variant: "solid",
      colorScheme: "accent",
      css: createSolidCompoundVariant({
        color: "white",
        bgColor: "$accent9",
        bgColorHover: "$accent10"
      })
    },
    {
      variant: "solid",
      colorScheme: "neutral",
      css: createSolidCompoundVariant({
        color: "white",
        bgColor: "$neutral9",
        bgColorHover: "$neutral10"
      })
    },
    {
      variant: "solid",
      colorScheme: "success",
      css: createSolidCompoundVariant({
        color: "white",
        bgColor: "$success9",
        bgColorHover: "$success10"
      })
    },
    {
      variant: "solid",
      colorScheme: "info",
      css: createSolidCompoundVariant({
        color: "white",
        bgColor: "$info9",
        bgColorHover: "$info10"
      })
    },
    {
      variant: "solid",
      colorScheme: "warning",
      css: createSolidCompoundVariant({
        color: "$blackAlpha12",
        bgColor: "$warning9",
        bgColorHover: "$warning10"
      })
    },
    {
      variant: "solid",
      colorScheme: "danger",
      css: createSolidCompoundVariant({
        color: "white",
        bgColor: "$danger9",
        bgColorHover: "$danger10"
      })
    },
    {
      variant: "subtle",
      colorScheme: "primary",
      css: createSubtleCompoundVariant({
        color: "$primary11",
        bgColor: "$primary4",
        bgColorHover: "$primary5",
        bgColorActive: "$primary6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "accent",
      css: createSubtleCompoundVariant({
        color: "$accent11",
        bgColor: "$accent4",
        bgColorHover: "$accent5",
        bgColorActive: "$accent6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "neutral",
      css: createSubtleCompoundVariant({
        color: "$neutral12",
        bgColor: "$neutral4",
        bgColorHover: "$neutral5",
        bgColorActive: "$neutral6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "success",
      css: createSubtleCompoundVariant({
        color: "$success11",
        bgColor: "$success4",
        bgColorHover: "$success5",
        bgColorActive: "$success6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "info",
      css: createSubtleCompoundVariant({
        color: "$info11",
        bgColor: "$info4",
        bgColorHover: "$info5",
        bgColorActive: "$info6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "warning",
      css: createSubtleCompoundVariant({
        color: "$warning11",
        bgColor: "$warning4",
        bgColorHover: "$warning5",
        bgColorActive: "$warning6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "danger",
      css: createSubtleCompoundVariant({
        color: "$danger11",
        bgColor: "$danger4",
        bgColorHover: "$danger5",
        bgColorActive: "$danger6"
      })
    },
    {
      variant: "outline",
      colorScheme: "primary",
      css: createOutlineCompoundVariant({
        color: "$primary11",
        borderColor: "$primary7",
        borderColorHover: "$primary8",
        bgColorHover: "$primary4",
        bgColorActive: "$primary5"
      })
    },
    {
      variant: "outline",
      colorScheme: "accent",
      css: createOutlineCompoundVariant({
        color: "$accent11",
        borderColor: "$accent7",
        borderColorHover: "$accent8",
        bgColorHover: "$accent4",
        bgColorActive: "$accent5"
      })
    },
    {
      variant: "outline",
      colorScheme: "neutral",
      css: createOutlineCompoundVariant({
        color: "$neutral12",
        borderColor: "$neutral7",
        borderColorHover: "$neutral8",
        bgColorHover: "$neutral4",
        bgColorActive: "$neutral5"
      })
    },
    {
      variant: "outline",
      colorScheme: "success",
      css: createOutlineCompoundVariant({
        color: "$success11",
        borderColor: "$success7",
        borderColorHover: "$success8",
        bgColorHover: "$success4",
        bgColorActive: "$success5"
      })
    },
    {
      variant: "outline",
      colorScheme: "info",
      css: createOutlineCompoundVariant({
        color: "$info11",
        borderColor: "$info7",
        borderColorHover: "$info8",
        bgColorHover: "$info4",
        bgColorActive: "$info5"
      })
    },
    {
      variant: "outline",
      colorScheme: "warning",
      css: createOutlineCompoundVariant({
        color: "$warning11",
        borderColor: "$warning7",
        borderColorHover: "$warning8",
        bgColorHover: "$warning4",
        bgColorActive: "$warning5"
      })
    },
    {
      variant: "outline",
      colorScheme: "danger",
      css: createOutlineCompoundVariant({
        color: "$danger11",
        borderColor: "$danger7",
        borderColorHover: "$danger8",
        bgColorHover: "$danger4",
        bgColorActive: "$danger5"
      })
    },
    {
      variant: "dashed",
      colorScheme: "primary",
      css: createOutlineCompoundVariant({
        color: "$primary11",
        borderColor: "$primary7",
        borderColorHover: "$primary8",
        bgColorHover: "$primary4",
        bgColorActive: "$primary5"
      })
    },
    {
      variant: "dashed",
      colorScheme: "accent",
      css: createOutlineCompoundVariant({
        color: "$accent11",
        borderColor: "$accent7",
        borderColorHover: "$accent8",
        bgColorHover: "$accent4",
        bgColorActive: "$accent5"
      })
    },
    {
      variant: "dashed",
      colorScheme: "neutral",
      css: createOutlineCompoundVariant({
        color: "$neutral12",
        borderColor: "$neutral7",
        borderColorHover: "$neutral8",
        bgColorHover: "$neutral4",
        bgColorActive: "$neutral5"
      })
    },
    {
      variant: "dashed",
      colorScheme: "success",
      css: createOutlineCompoundVariant({
        color: "$success11",
        borderColor: "$success7",
        borderColorHover: "$success8",
        bgColorHover: "$success4",
        bgColorActive: "$success5"
      })
    },
    {
      variant: "dashed",
      colorScheme: "info",
      css: createOutlineCompoundVariant({
        color: "$info11",
        borderColor: "$info7",
        borderColorHover: "$info8",
        bgColorHover: "$info4",
        bgColorActive: "$info5"
      })
    },
    {
      variant: "dashed",
      colorScheme: "warning",
      css: createOutlineCompoundVariant({
        color: "$warning11",
        borderColor: "$warning7",
        borderColorHover: "$warning8",
        bgColorHover: "$warning4",
        bgColorActive: "$warning5"
      })
    },
    {
      variant: "dashed",
      colorScheme: "danger",
      css: createOutlineCompoundVariant({
        color: "$danger11",
        borderColor: "$danger7",
        borderColorHover: "$danger8",
        bgColorHover: "$danger4",
        bgColorActive: "$danger5"
      })
    },
    {
      variant: "ghost",
      colorScheme: "primary",
      css: createGhostCompoundVariant({
        color: "$primary11",
        bgColorHover: "$primary4",
        bgColorActive: "$primary5"
      })
    },
    {
      variant: "ghost",
      colorScheme: "accent",
      css: createGhostCompoundVariant({
        color: "$accent11",
        bgColorHover: "$accent4",
        bgColorActive: "$accent5"
      })
    },
    {
      variant: "ghost",
      colorScheme: "neutral",
      css: createGhostCompoundVariant({
        color: "$neutral12",
        bgColorHover: "$neutral4",
        bgColorActive: "$neutral5"
      })
    },
    {
      variant: "ghost",
      colorScheme: "success",
      css: createGhostCompoundVariant({
        color: "$success11",
        bgColorHover: "$success4",
        bgColorActive: "$success5"
      })
    },
    {
      variant: "ghost",
      colorScheme: "info",
      css: createGhostCompoundVariant({
        color: "$info11",
        bgColorHover: "$info4",
        bgColorActive: "$info5"
      })
    },
    {
      variant: "ghost",
      colorScheme: "warning",
      css: createGhostCompoundVariant({
        color: "$warning11",
        bgColorHover: "$warning4",
        bgColorActive: "$warning5"
      })
    },
    {
      variant: "ghost",
      colorScheme: "danger",
      css: createGhostCompoundVariant({
        color: "$danger11",
        bgColorHover: "$danger4",
        bgColorActive: "$danger5"
      })
    },
    {
      size: "xs",
      compact: "true",
      css: createCompactSizeCompoundVariant({ height: "$5", paddingX: "$1" })
    },
    {
      size: "sm",
      compact: "true",
      css: createCompactSizeCompoundVariant({ height: "$6", paddingX: "$1_5" })
    },
    {
      size: "md",
      compact: "true",
      css: createCompactSizeCompoundVariant({ height: "$7", paddingX: "$2" })
    },
    {
      size: "lg",
      compact: "true",
      css: createCompactSizeCompoundVariant({ height: "$8", paddingX: "$2_5" })
    },
    {
      size: "xl",
      compact: "true",
      css: createCompactSizeCompoundVariant({ height: "$10", paddingX: "$3_5" })
    }
  ]
});
var buttonGroupStyles = css({
  display: "inline-flex",
  [`& .${buttonStyles}:focus`]: {
    zIndex: 1
  }
});
var hopeButtonGroupClass = "hope-button__group";
var ButtonGroupContext = createContext();
function ButtonGroup(props) {
  var _a, _b, _c, _d, _e, _f;
  const theme = useStyleConfig().Button;
  const [state] = createStore({
    get variant() {
      var _a2, _b2, _c2;
      return (_c2 = props.variant) != null ? _c2 : (_b2 = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.group) == null ? void 0 : _b2.variant;
    },
    get colorScheme() {
      var _a2, _b2, _c2;
      return (_c2 = props.colorScheme) != null ? _c2 : (_b2 = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.group) == null ? void 0 : _b2.colorScheme;
    },
    get size() {
      var _a2, _b2, _c2;
      return (_c2 = props.size) != null ? _c2 : (_b2 = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.group) == null ? void 0 : _b2.size;
    },
    get disabled() {
      return props.disabled;
    }
  });
  const defaultProps = {
    attached: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.attached) != null ? _c : false,
    spacing: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.group) == null ? void 0 : _e.spacing) != null ? _f : "0.5rem"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, _, others] = splitProps(propsWithDefault, ["class", "attached", "spacing"], ["variant", "colorScheme", "size", "disabled"]);
  const classes = () => {
    return classNames(local.class, hopeButtonGroupClass, buttonGroupStyles({
      css: local.attached ? {
        "> *:first-of-type:not(:last-of-type)": {
          borderRightRadius: 0
        },
        "> *:not(:first-of-type):not(:last-of-type)": {
          borderRadius: 0
        },
        "> *:not(:first-of-type):last-of-type": {
          borderLeftRadius: 0
        }
      } : {
        "& > *:not(style) ~ *:not(style)": {
          marginStart: local.spacing
        }
      }
    }));
  };
  const context = {
    state
  };
  return createComponent(ButtonGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        role: "group",
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a2;
          return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.group;
        }
      }, others));
    }
  });
}
ButtonGroup.toString = () => createClassSelector(hopeButtonGroupClass);
function useButtonGroupContext() {
  return useContext(ButtonGroupContext);
}
var hopeButtonIconClass = "hope-button__icon";
function ButtonIcon(props) {
  const [local, others] = splitProps(props, ["class", "children"]);
  const classes = () => classNames(local.class, hopeButtonIconClass, buttonIconStyles());
  return createComponent(hope.span, mergeProps({
    get ["class"]() {
      return classes();
    }
  }, others, {
    get children() {
      return local.children;
    }
  }));
}
ButtonIcon.toString = () => createClassSelector(hopeButtonIconClass);
var _tmpl$$c = template(`<svg><g fill="none"><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M12 19a7 7 0 1 0 0-14a7 7 0 0 0 0 14zm0 3c5.523 0 10-4.477 10-10S17.523 2 12 2S2 6.477 2 12s4.477 10 10 10z" fill="currentColor"></path><path d="M2 12C2 6.477 6.477 2 12 2v3a7 7 0 0 0-7 7H2z" fill="currentColor"></path></g></svg>`, 8, true);
var IconSpinner = createIcon({
  path: () => _tmpl$$c.cloneNode(true)
});
var hopeButtonLoaderClass = "hope-button__loader";
function ButtonLoader(props) {
  const defaultProps = {
    spacing: "0.5rem",
    children: createComponent(IconSpinner, {
      get ["class"]() {
        return buttonIconSpinnerStyles();
      }
    })
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "children", "withLoadingText", "placement", "spacing"]);
  const marginProp = () => local.placement === "start" ? "marginEnd" : "marginStart";
  const loaderStyles = () => ({
    [marginProp()]: local.withLoadingText ? local.spacing : 0
  });
  const classes = () => {
    return classNames(local.class, hopeButtonLoaderClass, buttonLoaderStyles({
      withLoadingText: local.withLoadingText
    }));
  };
  return createComponent(hope.div, mergeProps({
    get ["class"]() {
      return classes();
    }
  }, loaderStyles, others, {
    get children() {
      return local.children;
    }
  }));
}
ButtonLoader.toString = () => createClassSelector(hopeButtonLoaderClass);
var hopeButtonClass = "hope-button";
function Button(props) {
  var _a, _b, _c;
  const theme = useStyleConfig().Button;
  const buttonGroupContext = useButtonGroupContext();
  const defaultProps = {
    loaderPlacement: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.loaderPlacement) != null ? _c : "start",
    iconSpacing: "0.5rem",
    type: "button",
    role: "button"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, contentProps, others] = splitProps(propsWithDefault, ["class", "disabled", "loadingText", "loader", "loaderPlacement", "variant", "colorScheme", "size", "loading", "compact", "fullWidth"], ["children", "iconSpacing", "leftIcon", "rightIcon"]);
  const disabled = () => {
    var _a2;
    return (_a2 = local.disabled) != null ? _a2 : buttonGroupContext == null ? void 0 : buttonGroupContext.state.disabled;
  };
  const classes = () => {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    return classNames(local.class, hopeButtonClass, buttonStyles({
      variant: (_e = (_d = (_a2 = local.variant) != null ? _a2 : buttonGroupContext == null ? void 0 : buttonGroupContext.state.variant) != null ? _d : (_c2 = (_b2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _b2.root) == null ? void 0 : _c2.variant) != null ? _e : "solid",
      colorScheme: (_j = (_i = (_f = local.colorScheme) != null ? _f : buttonGroupContext == null ? void 0 : buttonGroupContext.state.colorScheme) != null ? _i : (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.root) == null ? void 0 : _h.colorScheme) != null ? _j : "primary",
      size: (_o = (_n = (_k = local.size) != null ? _k : buttonGroupContext == null ? void 0 : buttonGroupContext.state.size) != null ? _n : (_m = (_l = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _l.root) == null ? void 0 : _m.size) != null ? _o : "md",
      loading: local.loading,
      compact: local.compact,
      fullWidth: local.fullWidth
    }));
  };
  return createComponent(hope.button, mergeProps({
    get ["class"]() {
      return classes();
    },
    get disabled() {
      return disabled();
    },
    get __baseStyle() {
      var _a2;
      return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.root;
    }
  }, others, {
    get children() {
      return [createComponent(Show, {
        get when() {
          return local.loading && local.loaderPlacement === "start";
        },
        get children() {
          return createComponent(ButtonLoader, {
            "class": "hope-button__loader--start",
            get withLoadingText() {
              return !!local.loadingText;
            },
            placement: "start",
            get spacing() {
              return contentProps.iconSpacing;
            },
            get children() {
              return local.loader;
            }
          });
        }
      }), createComponent(Show, {
        get when() {
          return local.loading;
        },
        get fallback() {
          return createComponent(ButtonContent, contentProps);
        },
        get children() {
          return createComponent(Show, {
            get when() {
              return local.loadingText;
            },
            get fallback() {
              return createComponent(hope.span, {
                opacity: 0,
                get children() {
                  return createComponent(ButtonContent, contentProps);
                }
              });
            },
            get children() {
              return local.loadingText;
            }
          });
        }
      }), createComponent(Show, {
        get when() {
          return local.loading && local.loaderPlacement === "end";
        },
        get children() {
          return createComponent(ButtonLoader, {
            "class": "hope-button__loader--end",
            get withLoadingText() {
              return !!local.loadingText;
            },
            placement: "end",
            get spacing() {
              return contentProps.iconSpacing;
            },
            get children() {
              return local.loader;
            }
          });
        }
      })];
    }
  }));
}
Button.toString = () => createClassSelector(hopeButtonClass);
function ButtonContent(props) {
  return [createComponent(Show, {
    get when() {
      return props.leftIcon;
    },
    get children() {
      return createComponent(ButtonIcon, {
        get marginEnd() {
          return props.iconSpacing;
        },
        get children() {
          return props.leftIcon;
        }
      });
    }
  }), memo(() => props.children), createComponent(Show, {
    get when() {
      return props.rightIcon;
    },
    get children() {
      return createComponent(ButtonIcon, {
        get marginStart() {
          return props.iconSpacing;
        },
        get children() {
          return props.rightIcon;
        }
      });
    }
  })];
}
function AsyncButton(props) {
  const [local, others] = splitProps(props, ["onClick"]);
  const [loading, setLoading] = createSignal(false);
  const onClickInterceptor = (e) => {
    if (local.onClick) {
      setLoading(true);
      local.onClick(e).finally(() => setLoading(false));
    }
  };
  return createComponent(Button, mergeProps({
    get loading() {
      return loading();
    }
  }, others, {
    onClick: onClickInterceptor
  }));
}
AsyncButton.toString = () => createClassSelector(hopeButtonClass);
function createSizeVariant(size22) {
  return {
    boxSize: size22,
    fontSize: `calc(${size22} / 2.5)`,
    lineHeight: size22
  };
}
var avatarStyles = css({
  position: "relative",
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0,
  borderRadius: "$full",
  borderColor: "$loContrast",
  backgroundColor: "$neutral8",
  color: "$neutral12",
  fontWeight: "$medium",
  textAlign: "center",
  textTransform: "uppercase",
  verticalAlign: "top",
  variants: {
    size: {
      "2xs": createSizeVariant("$sizes$4"),
      xs: createSizeVariant("$sizes$6"),
      sm: createSizeVariant("$sizes$8"),
      md: createSizeVariant("$sizes$12"),
      lg: createSizeVariant("$sizes$16"),
      xl: createSizeVariant("$sizes$24"),
      "2xl": createSizeVariant("$sizes$32"),
      full: {
        boxSize: "$full",
        fontSize: "calc($sizes$full / 2.5)"
      }
    },
    withBorder: {
      true: {}
    }
  },
  compoundVariants: [
    {
      withBorder: true,
      size: "2xs",
      css: { borderWidth: "1px" }
    },
    {
      withBorder: true,
      size: "xs",
      css: { borderWidth: "1px" }
    },
    {
      withBorder: true,
      size: "sm",
      css: { borderWidth: "2px" }
    },
    {
      withBorder: true,
      size: "md",
      css: { borderWidth: "2px" }
    },
    {
      withBorder: true,
      size: "lg",
      css: { borderWidth: "3px" }
    },
    {
      withBorder: true,
      size: "xl",
      css: { borderWidth: "4px" }
    },
    {
      withBorder: true,
      size: "2xl",
      css: { borderWidth: "5px" }
    },
    {
      withBorder: true,
      size: "full",
      css: { borderWidth: "2px" }
    }
  ]
});
var avatarExcessStyles = css(avatarStyles);
var avatarImageStyles = css({
  boxSize: "$full",
  borderRadius: "$full",
  objectFit: "cover"
});
var avatarBadgeStyles = css({
  position: "absolute",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: "$full",
  borderWidth: "0.2em",
  borderStyle: "solid",
  borderColor: "$loContrast",
  variants: {
    placement: {
      "top-start": {
        insetInlineStart: "0",
        top: "0",
        transform: "translate(-25%, -25%)"
      },
      "top-end": {
        insetInlineEnd: "0",
        top: "0",
        transform: "translate(25%, -25%)"
      },
      "bottom-start": {
        insetInlineStart: "0",
        bottom: "0",
        transform: "translate(-25%, 25%)"
      },
      "bottom-end": {
        insetInlineEnd: "0",
        bottom: "0",
        transform: "translate(25%, 25%)"
      }
    }
  }
});
var avatarGroupStyles = css({
  display: "flex",
  alignItems: "center",
  justifyContent: "flex-start",
  flexDirection: "row",
  [`& .${avatarStyles}:first-child`]: {
    marginStart: "0"
  }
});
var _tmpl$$b = template(`<svg><path fill="currentColor" d="M103,102.1388 C93.094,111.92 79.3504,118 64.1638,118 C48.8056,118 34.9294,111.768 25,101.7892 L25,95.2 C25,86.8096 31.981,80 40.6,80 L87.4,80 C96.019,80 103,86.8096 103,95.2 L103,102.1388 Z"></path></svg>`, 4, true);
var _tmpl$2$1 = template(`<svg><path fill="currentColor" d="M63.9961647,24 C51.2938136,24 41,34.2938136 41,46.9961647 C41,59.7061864 51.2938136,70 63.9961647,70 C76.6985159,70 87,59.7061864 87,46.9961647 C87,34.2938136 76.6985159,24 63.9961647,24"></path></svg>`, 4, true);
function initials(name) {
  const [firstName, lastName] = name.split(" ");
  return firstName && lastName ? `${firstName.charAt(0)}${lastName.charAt(0)}` : firstName.charAt(0);
}
function DefaultAvatarIcon(props) {
  return createComponent(hope.svg, mergeProps({
    viewBox: "0 0 128 128",
    "class": "hope-avatar__svg",
    color: "$loContrast",
    boxSize: "$full"
  }, props, {
    get children() {
      return [_tmpl$$b.cloneNode(true), _tmpl$2$1.cloneNode(true)];
    }
  }));
}
var AvatarGroupContext = createContext();
var hopeAvatarGroupClass = "hope-avatar__group";
function AvatarGroup(props) {
  const theme = useStyleConfig().Avatar;
  const [state] = createStore({
    get size() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.size) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.size) != null ? _d : "md";
    },
    get spacing() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.spacing) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.spacing) != null ? _d : "-1em";
    },
    get avatarBorderRadius() {
      var _a, _b, _c;
      return (_c = props.avatarBorderRadius) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.avatarBorderRadius;
    },
    get avatarBorderColor() {
      var _a, _b, _c;
      return (_c = props.avatarBorderColor) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.avatarBorderColor;
    },
    get avatarBorderWidth() {
      var _a, _b, _c;
      return (_c = props.avatarBorderWidth) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.avatarBorderWidth;
    }
  });
  const [local, others] = splitProps(props, ["class", "size", "spacing", "avatarBorderRadius", "avatarBorderColor", "avatarBorderWidth"]);
  const classes = () => classNames(local.class, hopeAvatarGroupClass, avatarGroupStyles());
  const context = {
    state
  };
  return createComponent(AvatarGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        role: "group",
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.group;
        }
      }, others));
    }
  });
}
AvatarGroup.toString = () => createClassSelector(hopeAvatarGroupClass);
function useAvatarGroupContext() {
  return useContext(AvatarGroupContext);
}
function createImageLoadingStatus(props) {
  const [statusState, setStatusState] = createSignal("pending");
  const status = () => props.ignoreFallback ? "loaded" : statusState();
  let imageRef = null;
  const flush = () => {
    if (imageRef) {
      imageRef.onload = null;
      imageRef.onerror = null;
      imageRef = null;
    }
  };
  const load = () => {
    if (!props.src) {
      return;
    }
    flush();
    const img = new Image();
    img.src = props.src;
    if (props.crossOrigin) {
      img.crossOrigin = props.crossOrigin;
    }
    if (props.srcSet) {
      img.srcset = props.srcSet;
    }
    if (props.sizes) {
      img.sizes = props.sizes;
    }
    if (props.loading) {
      img.loading = props.loading;
    }
    img.onload = (event) => {
      flush();
      setStatusState("loaded");
      callHandler(props.onLoad, event);
    };
    img.onerror = (error) => {
      flush();
      setStatusState("failed");
      callHandler(props.onError, error);
    };
    imageRef = img;
  };
  createEffect(() => {
    setStatusState(props.src ? "loading" : "pending");
  });
  createRenderEffect(() => {
    if (props.ignoreFallback) {
      return void 0;
    }
    if (statusState() === "loading") {
      load();
    }
    onCleanup(() => {
      flush();
    });
  });
  return status;
}
var hopeAvatarInitialsClass = "hope-avatar__initials";
function AvatarInitials(props) {
  const theme = useStyleConfig().Avatar;
  const [local, others] = splitProps(props, ["class", "getInitials", "name"]);
  const classes = () => classNames(local.class, hopeAvatarInitialsClass);
  const diplayInitials = () => {
    var _a;
    return local.name && ((_a = local.getInitials) == null ? void 0 : _a.call(local, local.name));
  };
  return createComponent(Box, mergeProps({
    role: "img",
    get ["aria-label"]() {
      return local.name;
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.initials;
    }
  }, others, {
    get children() {
      return diplayInitials();
    }
  }));
}
AvatarInitials.toString = () => createClassSelector(hopeAvatarInitialsClass);
var hopeAvatarImageClass = "hope-avatar__image";
function AvatarImage(props) {
  const theme = useStyleConfig().Avatar;
  const [local, others] = splitProps(props, ["class", "src", "srcSet", "getInitials", "name", "loading", "iconLabel", "icon", "ignoreFallback", "onError"]);
  const status = createMemo(() => {
    return createImageLoadingStatus({
      src: local.src,
      onError: local.onError,
      ignoreFallback: local.ignoreFallback
    });
  });
  const classes = () => classNames(local.class, hopeAvatarImageClass, avatarImageStyles());
  const hasLoaded = () => !!local.src && status()() === "loaded";
  const iconProps = () => {
    var _a;
    return {
      role: "img",
      "aria-label": (_a = local.iconLabel) != null ? _a : "avatar"
    };
  };
  return createComponent(Show, {
    get when() {
      return hasLoaded();
    },
    get fallback() {
      return createComponent(Show, {
        get when() {
          return local.name;
        },
        get fallback() {
          var _a;
          return (_a = local.icon) == null ? void 0 : _a.call(local, iconProps());
        },
        get children() {
          return createComponent(AvatarInitials, {
            get getInitials() {
              return local.getInitials;
            },
            get name() {
              return local.name;
            }
          });
        }
      });
    },
    get children() {
      return createComponent(hope.img, mergeProps({
        get ["class"]() {
          return classes();
        },
        get src() {
          return local.src;
        },
        get srcSet() {
          return local.srcSet;
        },
        get alt() {
          return local.name;
        },
        get loading() {
          return local.loading;
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.image;
        }
      }, others));
    }
  });
}
AvatarImage.toString = () => createClassSelector(hopeAvatarImageClass);
var hopeAvatarClass = "hope-avatar";
function Avatar(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const theme = useStyleConfig().Avatar;
  const avatarGroupContext = useAvatarGroupContext();
  const defaultProps = {
    icon: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.icon) != null ? _c : (props2) => createComponent(DefaultAvatarIcon, props2),
    iconLabel: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.root) == null ? void 0 : _e.iconLabel) != null ? _f : "avatar",
    getInitials: (_i = (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.root) == null ? void 0 : _h.getInitials) != null ? _i : initials,
    ignoreFallback: (_l = (_k = (_j = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _j.root) == null ? void 0 : _k.ignoreFallback) != null ? _l : false,
    loading: (_n = (_m = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _m.root) == null ? void 0 : _n.loading
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "children", "size", "withBorder", "src", "srcSet", "name", "borderRadius", "onError", "getInitials", "icon", "iconLabel", "loading", "ignoreFallback", "imageProps"]);
  const classes = () => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2;
    return classNames(local.class, hopeAvatarClass, avatarStyles({
      size: (_e2 = (_d2 = (_a2 = local.size) != null ? _a2 : avatarGroupContext == null ? void 0 : avatarGroupContext.state.size) != null ? _d2 : (_c2 = (_b2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _b2.root) == null ? void 0 : _c2.size) != null ? _e2 : "md",
      withBorder: (_j2 = (_i2 = (_f2 = local.withBorder) != null ? _f2 : !!avatarGroupContext) != null ? _i2 : (_h2 = (_g2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g2.root) == null ? void 0 : _h2.withBorder) != null ? _j2 : false
    }));
  };
  return createComponent(hope.span, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a2;
      return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.root;
    },
    get borderRadius() {
      var _a2;
      return (_a2 = local.borderRadius) != null ? _a2 : avatarGroupContext == null ? void 0 : avatarGroupContext.state.avatarBorderRadius;
    },
    get borderColor() {
      return avatarGroupContext == null ? void 0 : avatarGroupContext.state.avatarBorderColor;
    },
    get borderWidth() {
      return avatarGroupContext == null ? void 0 : avatarGroupContext.state.avatarBorderWidth;
    },
    get marginStart() {
      return avatarGroupContext == null ? void 0 : avatarGroupContext.state.spacing;
    }
  }, others, {
    get children() {
      return [createComponent(AvatarImage, mergeProps({
        get src() {
          return local.src;
        },
        get srcSet() {
          return local.srcSet;
        },
        get loading() {
          return local.loading;
        },
        get getInitials() {
          return local.getInitials;
        },
        get name() {
          return local.name;
        },
        get icon() {
          return local.icon;
        },
        get iconLabel() {
          return local.iconLabel;
        },
        get ignoreFallback() {
          return local.ignoreFallback;
        },
        get borderRadius() {
          var _a2;
          return (_a2 = local.borderRadius) != null ? _a2 : avatarGroupContext == null ? void 0 : avatarGroupContext.state.avatarBorderRadius;
        },
        get onError() {
          return local.onError;
        }
      }, () => local.imageProps)), memo(() => local.children)];
    }
  }));
}
Avatar.toString = () => createClassSelector(hopeAvatarClass);
var hopeAvatarBadgeClass = "hope-avatar__badge";
function AvatarBadge(props) {
  const theme = useStyleConfig().Avatar;
  const [local, others] = splitProps(props, ["class", "placement"]);
  const classes = () => {
    var _a;
    return classNames(local.class, hopeAvatarBadgeClass, avatarBadgeStyles({
      placement: (_a = local.placement) != null ? _a : "bottom-end"
    }));
  };
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.badge;
    }
  }, others));
}
AvatarBadge.toString = () => createClassSelector(hopeAvatarBadgeClass);
var hopeAvatarExcessClass = "hope-avatar__excess";
function AvatarExcess(props) {
  const theme = useStyleConfig().Avatar;
  const avatarGroupContext = useAvatarGroupContext();
  const [local, others] = splitProps(props, ["class", "size", "withBorder"]);
  const classes = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    return classNames(local.class, hopeAvatarExcessClass, avatarExcessStyles({
      size: (_e = (_d = (_a = local.size) != null ? _a : avatarGroupContext == null ? void 0 : avatarGroupContext.state.size) != null ? _d : (_c = (_b = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _b.root) == null ? void 0 : _c.size) != null ? _e : "md",
      withBorder: (_j = (_i = (_f = local.withBorder) != null ? _f : !!avatarGroupContext) != null ? _i : (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.root) == null ? void 0 : _h.withBorder) != null ? _j : false
    }));
  };
  return createComponent(hope.span, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.excess;
    },
    get borderRadius() {
      return avatarGroupContext == null ? void 0 : avatarGroupContext.state.avatarBorderRadius;
    },
    get borderColor() {
      return avatarGroupContext == null ? void 0 : avatarGroupContext.state.avatarBorderColor;
    },
    get borderWidth() {
      return avatarGroupContext == null ? void 0 : avatarGroupContext.state.avatarBorderWidth;
    },
    get marginStart() {
      return avatarGroupContext == null ? void 0 : avatarGroupContext.state.spacing;
    }
  }, others));
}
AvatarExcess.toString = () => createClassSelector(hopeAvatarExcessClass);
var badgeStyles = css({
  display: "inline-block",
  borderRadius: "$sm",
  py: "$0_5",
  px: "$1",
  fontSize: "$xs",
  fontWeight: "$bold",
  lineHeight: "$none",
  letterSpacing: "$wide",
  textTransform: "uppercase",
  whiteSpace: "nowrap",
  verticalAlign: "middle",
  variants: {
    variant: {
      solid: {
        border: "1px solid transparent",
        color: "white"
      },
      subtle: {
        border: "1px solid transparent"
      },
      outline: {
        borderStyle: "solid",
        borderWidth: "1px",
        backgroundColor: "transparent"
      }
    },
    colorScheme: {
      primary: {},
      accent: {},
      neutral: {},
      success: {},
      info: {},
      warning: {},
      danger: {}
    }
  },
  compoundVariants: [
    {
      variant: "solid",
      colorScheme: "primary",
      css: {
        color: "white",
        bgColor: "$primary9"
      }
    },
    {
      variant: "solid",
      colorScheme: "accent",
      css: {
        color: "white",
        bgColor: "$accent9"
      }
    },
    {
      variant: "solid",
      colorScheme: "neutral",
      css: {
        color: "white",
        bgColor: "$neutral9"
      }
    },
    {
      variant: "solid",
      colorScheme: "success",
      css: {
        color: "white",
        bgColor: "$success9"
      }
    },
    {
      variant: "solid",
      colorScheme: "info",
      css: {
        color: "white",
        bgColor: "$info9"
      }
    },
    {
      variant: "solid",
      colorScheme: "warning",
      css: {
        color: "$blackAlpha12",
        bgColor: "$warning9"
      }
    },
    {
      variant: "solid",
      colorScheme: "danger",
      css: {
        color: "white",
        bgColor: "$danger9"
      }
    },
    {
      variant: "subtle",
      colorScheme: "primary",
      css: {
        color: "$primary11",
        bgColor: "$primary4"
      }
    },
    {
      variant: "subtle",
      colorScheme: "accent",
      css: {
        color: "$accent11",
        bgColor: "$accent4"
      }
    },
    {
      variant: "subtle",
      colorScheme: "neutral",
      css: {
        color: "$neutral12",
        bgColor: "$neutral4"
      }
    },
    {
      variant: "subtle",
      colorScheme: "success",
      css: {
        color: "$success11",
        bgColor: "$success4"
      }
    },
    {
      variant: "subtle",
      colorScheme: "info",
      css: {
        color: "$info11",
        bgColor: "$info4"
      }
    },
    {
      variant: "subtle",
      colorScheme: "warning",
      css: {
        color: "$warning11",
        bgColor: "$warning4"
      }
    },
    {
      variant: "subtle",
      colorScheme: "danger",
      css: {
        color: "$danger11",
        bgColor: "$danger4"
      }
    },
    {
      variant: "outline",
      colorScheme: "primary",
      css: {
        color: "$primary11",
        borderColor: "$primary7"
      }
    },
    {
      variant: "outline",
      colorScheme: "accent",
      css: {
        color: "$accent11",
        borderColor: "$accent7"
      }
    },
    {
      variant: "outline",
      colorScheme: "neutral",
      css: {
        color: "$neutral12",
        borderColor: "$neutral7"
      }
    },
    {
      variant: "outline",
      colorScheme: "success",
      css: {
        color: "$success11",
        borderColor: "$success7"
      }
    },
    {
      variant: "outline",
      colorScheme: "info",
      css: {
        color: "$info11",
        borderColor: "$info7"
      }
    },
    {
      variant: "outline",
      colorScheme: "warning",
      css: {
        color: "$warning11",
        borderColor: "$warning7"
      }
    },
    {
      variant: "outline",
      colorScheme: "danger",
      css: {
        color: "$danger11",
        borderColor: "$danger7"
      }
    }
  ]
});
var hopeBadgeClass = "hope-badge";
function Badge(props) {
  var _a, _b, _c, _d;
  const theme = useStyleConfig().Badge;
  const defaultProps = {
    variant: (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.variant) != null ? _b : "subtle",
    colorScheme: (_d = (_c = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _c.colorScheme) != null ? _d : "neutral"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, variantProps, others] = splitProps(propsWithDefault, ["class"], ["variant", "colorScheme"]);
  const classes = () => classNames(local.class, hopeBadgeClass, badgeStyles(variantProps));
  return createComponent(hope.span, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      return theme == null ? void 0 : theme.baseStyle;
    }
  }, others));
}
Badge.toString = () => createClassSelector(hopeBadgeClass);
var breadcrumbStyles = css({
  display: "block",
  fontSize: "$base",
  lineHeight: "$6"
});
var breadcrumbListStyles = css({
  display: "flex",
  alignItems: "center",
  margin: 0,
  padding: 0,
  listStyle: "none"
});
var breadcrumbItemStyles = css({
  display: "inline-flex",
  alignItems: "center"
});
var breadcrumbSeparatorStyles = css({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center"
});
var breadcrumbLinkStyles = css({
  position: "relative",
  display: "inline-flex",
  alignItems: "center",
  outline: "none",
  backgroundColor: "transparent",
  color: "$neutral11",
  textDecoration: "none",
  cursor: "pointer",
  transition: "color 250ms, text-decoration 250ms",
  "&:focus": {
    boxShadow: "$outline"
  },
  variants: {
    currentPage: {
      true: {
        color: "$neutral12",
        cursor: "default"
      },
      false: {
        "&:hover": {
          color: "$primary11"
        }
      }
    }
  }
});
var BreadcrumbContext = createContext();
var hopeBreadcrumbClass = "hope-breadcrumb";
var hopeBreadcrumbListClass = "hope-breadcrumb__list";
function Breadcrumb(props) {
  const theme = useStyleConfig().Breadcrumb;
  const [state] = createStore({
    get spacing() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.spacing) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.spacing) != null ? _d : "0.5rem";
    },
    get separator() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.separator) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.separator) != null ? _d : "/";
    }
  });
  const [local, others] = splitProps(props, ["class", "children", "separator", "spacing"]);
  const rootClasses = () => classNames(local.class, hopeBreadcrumbClass, breadcrumbStyles());
  const listClasses = () => classNames(hopeBreadcrumbListClass, breadcrumbListStyles());
  const context = {
    state
  };
  return createComponent(BreadcrumbContext.Provider, {
    value: context,
    get children() {
      return createComponent(hope.nav, mergeProps({
        "aria-label": "breadcrumb",
        get ["class"]() {
          return rootClasses();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.root;
        }
      }, others, {
        get children() {
          return createComponent(hope.ol, {
            get ["class"]() {
              return listClasses();
            },
            get gap() {
              return state.spacing;
            },
            get children() {
              return local.children;
            }
          });
        }
      }));
    }
  });
}
Breadcrumb.toString = () => createClassSelector(hopeBreadcrumbClass);
function useBreadcrumbContext() {
  const context = useContext(BreadcrumbContext);
  if (!context) {
    throw new Error("[Hope UI]: useBreadcrumbContext must be used within a `<Breadcrumb />` component");
  }
  return context;
}
var hopeBreadcrumbItemClass = "hope-breadcrumb__item";
function BreadcrumbItem(props) {
  const theme = useStyleConfig().Breadcrumb;
  const breadcrumbContext = useBreadcrumbContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => {
    return classNames(local.class, hopeBreadcrumbItemClass, breadcrumbItemStyles());
  };
  return createComponent(hope.li, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.item;
    },
    get gap() {
      return breadcrumbContext.state.spacing;
    }
  }, others));
}
BreadcrumbItem.toString = () => createClassSelector(hopeBreadcrumbItemClass);
var hopeBreadcrumbLinkClass = "hope-breadcrumb__link";
function BreadcrumbLink(props) {
  const theme = useStyleConfig().Breadcrumb;
  const [local, others] = splitProps(props, ["class", "currentPage", "href"]);
  const classes = () => {
    return classNames(local.class, hopeBreadcrumbLinkClass, breadcrumbLinkStyles({
      currentPage: local.currentPage === true ? true : false
    }));
  };
  return createComponent(Show, {
    get when() {
      return local.currentPage;
    },
    get fallback() {
      return createComponent(hope.a, mergeProps({
        get href() {
          return local.href;
        },
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.link;
        }
      }, others));
    },
    get children() {
      return createComponent(hope.span, mergeProps({
        "aria-current": "page",
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.link;
        }
      }, others));
    }
  });
}
BreadcrumbLink.toString = () => createClassSelector(hopeBreadcrumbLinkClass);
var hopeBreadcrumbSeparatorClass = "hope-breadcrumb__separator";
function BreadcrumbSeparator(props) {
  const theme = useStyleConfig().Breadcrumb;
  const breadcrumbContext = useBreadcrumbContext();
  const [local, others] = splitProps(props, ["class", "children"]);
  const classes = () => {
    return classNames(local.class, hopeBreadcrumbSeparatorClass, breadcrumbSeparatorStyles());
  };
  return createComponent(hope.span, mergeProps({
    role: "presentation",
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.separator;
    }
  }, others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return local.children;
        },
        get fallback() {
          return breadcrumbContext.state.separator;
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
BreadcrumbSeparator.toString = () => createClassSelector(hopeBreadcrumbSeparatorClass);
var centerStyles = css({
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
var hopeCenterClass = "hope-center";
function Center(props) {
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeCenterClass, centerStyles());
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    }
  }, others));
}
Center.toString = () => createClassSelector(hopeCenterClass);
function createColorVariant(config2) {
  return {
    color: config2.color,
    "&[data-disabled]": {
      color: "$neutral10"
    },
    "&[data-focus]": {
      boxShadow: `0 0 0 3px $colors${config2.boxShadowColorFocus}`,
      borderColor: config2.borderColorFocus
    }
  };
}
var toggleWrapperStyles = css({
  position: "relative",
  display: "inline-flex",
  alignItems: "center",
  gap: "$2",
  cursor: "pointer",
  userSelect: "none",
  "&[data-disabled]": {
    opacity: "0.5",
    cursor: "not-allowed"
  },
  variants: {
    size: {
      sm: {
        fontSize: "$sm",
        lineHeight: "$5"
      },
      md: {
        fontSize: "$base",
        lineHeight: "$6"
      },
      lg: {
        fontSize: "$lg",
        lineHeight: "$7"
      }
    }
  }
});
var toggleControlLabelStyles = css({
  cursor: "pointer",
  userSelect: "none",
  "&[data-disabled]": {
    opacity: "0.5",
    cursor: "not-allowed"
  }
});
var toggleControlStyles = css({
  position: "relative",
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0,
  height: "100%",
  outline: "none",
  padding: 0,
  verticalAlign: "middle",
  cursor: "pointer",
  userSelect: "none",
  transition: "border-color 250ms, box-shadow 250ms",
  "&[data-disabled]": {
    opacity: "0.5",
    cursor: "not-allowed"
  },
  "&[data-invalid]": {
    borderColor: "$danger8",
    color: "$danger9"
  },
  "&[data-focus][data-invalid]": {
    boxShadow: "0 0 0 3px $colors$danger5",
    borderColor: "$danger8"
  },
  "&[data-checked], &[data-focus][data-checked]": {
    borderColor: "transparent",
    backgroundColor: "currentColor"
  },
  variants: {
    variant: {
      outline: {
        border: "1px solid $colors$neutral8",
        backgroundColor: "transparent"
      },
      filled: {
        border: "1px solid transparent",
        backgroundColor: "$neutral7"
      }
    },
    colorScheme: {
      primary: createColorVariant({
        color: "$primary9",
        boxShadowColorFocus: "$primary5",
        borderColorFocus: "$primary8"
      }),
      accent: createColorVariant({
        color: "$accent9",
        boxShadowColorFocus: "$accent5",
        borderColorFocus: "$accent8"
      }),
      neutral: createColorVariant({
        color: "$neutral9",
        boxShadowColorFocus: "$neutral5",
        borderColorFocus: "$neutral8"
      }),
      success: createColorVariant({
        color: "$success9",
        boxShadowColorFocus: "$success5",
        borderColorFocus: "$success8"
      }),
      info: createColorVariant({
        color: "$info9",
        boxShadowColorFocus: "$info5",
        borderColorFocus: "$info8"
      }),
      warning: createColorVariant({
        color: "$warning9",
        boxShadowColorFocus: "$warning5",
        borderColorFocus: "$warning8"
      }),
      danger: createColorVariant({
        color: "$danger9",
        boxShadowColorFocus: "$danger5",
        borderColorFocus: "$danger8"
      })
    },
    size: {
      sm: {
        boxSize: "$3"
      },
      md: {
        boxSize: "$4"
      },
      lg: {
        boxSize: "$5"
      }
    }
  }
});
var checkboxWrapperStyles = css(toggleWrapperStyles, {
  variants: {
    labelPlacement: {
      start: {
        flexDirection: "row-reverse"
      },
      end: {
        flexDirection: "row"
      }
    }
  }
});
var checkboxLabelStyles = css(toggleControlLabelStyles);
var checkboxControlStyles = css(toggleControlStyles, {
  borderRadius: "$sm",
  "& svg": {
    color: "$loContrast"
  },
  "&[data-indeterminate], &[data-focus][data-indeterminate]": {
    borderColor: "transparent",
    backgroundColor: "currentColor"
  }
});
var hopeCheckboxGroupClass = "hope-checkbox__group";
function CheckboxGroup(props) {
  var _a;
  const defaultName = `hope-checkbox-group-${createUniqueId()}--checkbox`;
  const theme = useStyleConfig().Checkbox;
  const [state, setState] = createStore({
    _value: (_a = props.defaultValue) != null ? _a : [],
    get isControlled() {
      return props.value !== void 0;
    },
    get value() {
      return this.isControlled ? props.value : this._value;
    },
    get name() {
      var _a2;
      return (_a2 = props.name) != null ? _a2 : defaultName;
    },
    get required() {
      return props.required;
    },
    get disabled() {
      return props.disabled;
    },
    get invalid() {
      return props.invalid;
    },
    get readOnly() {
      return props.readOnly;
    },
    get variant() {
      var _a2, _b, _c;
      return (_c = props.variant) != null ? _c : (_b = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.group) == null ? void 0 : _b.variant;
    },
    get colorScheme() {
      var _a2, _b, _c;
      return (_c = props.colorScheme) != null ? _c : (_b = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.group) == null ? void 0 : _b.colorScheme;
    },
    get size() {
      var _a2, _b, _c;
      return (_c = props.size) != null ? _c : (_b = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.group) == null ? void 0 : _b.size;
    },
    get labelPlacement() {
      var _a2, _b, _c;
      return (_c = props.labelPlacement) != null ? _c : (_b = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.group) == null ? void 0 : _b.labelPlacement;
    }
  });
  const [local, _, others] = splitProps(props, ["class", "onChange"], ["value", "defaultValue", "name", "required", "disabled", "readOnly", "invalid"]);
  const onChange = (event) => {
    var _a2;
    if (!state.value) {
      return;
    }
    const target = event.target;
    const nextValue = target.checked ? [...state.value, target.value] : state.value.filter((val) => String(val) !== String(target.value));
    setState("_value", nextValue);
    (_a2 = local.onChange) == null ? void 0 : _a2.call(local, nextValue);
  };
  const classes = () => classNames(local.class, hopeCheckboxGroupClass);
  const context = {
    state,
    onChange
  };
  return createComponent(CheckboxGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a2;
          return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.group;
        }
      }, others));
    }
  });
}
CheckboxGroup.toString = () => createClassSelector(hopeCheckboxGroupClass);
var CheckboxGroupContext = createContext();
function useCheckboxGroupContext() {
  return useContext(CheckboxGroupContext);
}
var formControlStyles = css({
  position: "relative",
  width: "$full"
});
var formLabelStyles = css({
  display: "inline-block",
  marginBottom: "$1",
  color: "$neutral12",
  fontWeight: "$medium",
  fontSize: "$sm",
  lineHeight: "$5",
  textAlign: "start",
  opacity: 1,
  "&[data-disabled]": {
    opacity: 0.4,
    cursor: "not-allowed"
  }
});
var requiredIndicatorStyles = css({
  marginInlineStart: "$1",
  color: "$danger9",
  fontSize: "$base"
});
var formHelperTextStyles = css({
  display: "inline-block",
  marginTop: "$1",
  color: "$neutral11",
  fontWeight: "$normal",
  fontSize: "$sm",
  lineHeight: "$5",
  textAlign: "start",
  opacity: 1,
  "&[data-disabled]": {
    opacity: 0.4,
    cursor: "not-allowed"
  }
});
var formErrorMessageStyles = css({
  display: "inline-block",
  marginTop: "$1",
  color: "$danger9",
  fontWeight: "$normal",
  fontSize: "$sm",
  lineHeight: "$5",
  textAlign: "start",
  opacity: 1,
  "&[data-disabled]": {
    opacity: 0.4,
    cursor: "not-allowed"
  }
});
var FormControlContext = createContext();
var hopeFormControlClass = "hope-form-control";
function FormControl(props) {
  const defaultId = `hope-field-${createUniqueId()}`;
  const theme = useStyleConfig().FormControl;
  const [state, setState] = createStore({
    get id() {
      var _a;
      return (_a = props.id) != null ? _a : defaultId;
    },
    get labelId() {
      return `${this.id}-label`;
    },
    get helperTextId() {
      return `${this.id}-helper-text`;
    },
    get errorMessageId() {
      return `${this.id}-error-message`;
    },
    get required() {
      return props.required;
    },
    get disabled() {
      return props.disabled;
    },
    get invalid() {
      return props.invalid;
    },
    get readOnly() {
      return props.readOnly;
    },
    get ["data-focus"]() {
      return this.isFocused ? "" : void 0;
    },
    get ["data-disabled"]() {
      return this.disabled ? "" : void 0;
    },
    get ["data-invalid"]() {
      return this.invalid ? "" : void 0;
    },
    get ["data-readonly"]() {
      return this.readOnly ? "" : void 0;
    },
    hasHelperText: false,
    hasErrorMessage: false,
    isFocused: false
  });
  const [local, others] = splitProps(props, ["id", "required", "disabled", "invalid", "readOnly", "class"]);
  const setHasHelperText = (value) => setState("hasHelperText", value);
  const setHasErrorMessage = (value) => setState("hasErrorMessage", value);
  const onFocus = () => setState("isFocused", true);
  const onBlur = () => setState("isFocused", false);
  const context = () => ({
    state,
    setHasHelperText,
    setHasErrorMessage,
    onFocus,
    onBlur
  });
  const classes = () => classNames(local.class, hopeFormControlClass, formControlStyles());
  return createComponent(FormControlContext.Provider, {
    get value() {
      return context();
    },
    get children() {
      return createComponent(Box, mergeProps({
        role: "group",
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.root;
        }
      }, others));
    }
  });
}
FormControl.toString = () => createClassSelector(hopeFormControlClass);
function useFormControlContext() {
  return useContext(FormControlContext);
}
function useFormControl(props) {
  const formControl = useFormControlContext();
  const focusHandler = createMemo(() => {
    return chainHandlers(formControl == null ? void 0 : formControl.onFocus, props.onFocus);
  });
  const blurHandler = createMemo(() => {
    return chainHandlers(formControl == null ? void 0 : formControl.onBlur, props.onBlur);
  });
  const [state] = createStore({
    get id() {
      var _a;
      return (_a = props.id) != null ? _a : formControl == null ? void 0 : formControl.state.id;
    },
    get required() {
      var _a;
      return (_a = props.required) != null ? _a : formControl == null ? void 0 : formControl.state.required;
    },
    get disabled() {
      var _a;
      return (_a = props.disabled) != null ? _a : formControl == null ? void 0 : formControl.state.disabled;
    },
    get invalid() {
      var _a;
      return (_a = props.invalid) != null ? _a : formControl == null ? void 0 : formControl.state.invalid;
    },
    get readOnly() {
      var _a;
      return (_a = props.readOnly) != null ? _a : formControl == null ? void 0 : formControl.state.readOnly;
    },
    get ["aria-required"]() {
      return this.required ? true : void 0;
    },
    get ["aria-disabled"]() {
      return this.disabled ? true : void 0;
    },
    get ["aria-invalid"]() {
      return this.invalid ? true : void 0;
    },
    get ["aria-readonly"]() {
      return this.readOnly ? true : void 0;
    },
    get ["aria-describedby"]() {
      const labelIds = props["aria-describedby"] ? [props["aria-describedby"]] : [];
      if ((formControl == null ? void 0 : formControl.state.hasErrorMessage) && (formControl == null ? void 0 : formControl.state.invalid)) {
        labelIds.push(formControl.state.errorMessageId);
      }
      if (formControl == null ? void 0 : formControl.state.hasHelperText) {
        labelIds.push(formControl.state.helperTextId);
      }
      return labelIds.join(" ") || void 0;
    },
    get onFocus() {
      return focusHandler;
    },
    get onBlur() {
      return blurHandler;
    }
  });
  return state;
}
var _tmpl$$a = template(`<input type="checkbox">`, 1);
function CheckboxPrimitive(props) {
  const defaultId = `hope-checkbox-${createUniqueId()}`;
  const formControlContext = useFormControlContext();
  const checkboxGroupContext = useCheckboxGroupContext();
  const formControlProps = useFormControl(props);
  const [state, setState] = createStore({
    _checked: !!props.defaultChecked,
    isFocused: false,
    get isControlled() {
      return props.checked !== void 0;
    },
    get checked() {
      if (checkboxGroupContext) {
        const checkboxGroupValue = checkboxGroupContext.state.value;
        return checkboxGroupValue != null ? checkboxGroupValue.some((val) => String(props.value) === String(val)) : false;
      }
      return this.isControlled ? !!props.checked : this._checked;
    },
    get id() {
      var _a;
      if (formControlContext && !checkboxGroupContext) {
        return formControlProps.id;
      }
      return (_a = props.id) != null ? _a : defaultId;
    },
    get name() {
      var _a;
      return (_a = props.name) != null ? _a : checkboxGroupContext == null ? void 0 : checkboxGroupContext.state.name;
    },
    get value() {
      return props.value;
    },
    get indeterminate() {
      return props.indeterminate;
    },
    get required() {
      var _a;
      return (_a = formControlProps.required) != null ? _a : checkboxGroupContext == null ? void 0 : checkboxGroupContext.state.required;
    },
    get disabled() {
      var _a;
      return (_a = formControlProps.disabled) != null ? _a : checkboxGroupContext == null ? void 0 : checkboxGroupContext.state.disabled;
    },
    get invalid() {
      var _a;
      return (_a = formControlProps.invalid) != null ? _a : checkboxGroupContext == null ? void 0 : checkboxGroupContext.state.invalid;
    },
    get readOnly() {
      var _a;
      return (_a = formControlProps.readOnly) != null ? _a : checkboxGroupContext == null ? void 0 : checkboxGroupContext.state.readOnly;
    },
    get ["aria-required"]() {
      return this.required ? true : void 0;
    },
    get ["aria-disabled"]() {
      return this.disabled ? true : void 0;
    },
    get ["aria-invalid"]() {
      return this.invalid ? true : void 0;
    },
    get ["aria-readonly"]() {
      return this.readOnly ? true : void 0;
    },
    get ["aria-label"]() {
      return props["aria-label"];
    },
    get ["aria-labelledby"]() {
      return props["aria-labelledby"];
    },
    get ["aria-describedby"]() {
      return props["aria-describedby"];
    },
    get ["data-indeterminate"]() {
      return this.indeterminate ? "" : void 0;
    },
    get ["data-focus"]() {
      return this.isFocused ? "" : void 0;
    },
    get ["data-checked"]() {
      return this.checked ? "" : void 0;
    },
    get ["data-required"]() {
      return this.required ? "" : void 0;
    },
    get ["data-disabled"]() {
      return this.disabled ? "" : void 0;
    },
    get ["data-invalid"]() {
      return this.invalid ? "" : void 0;
    },
    get ["data-readonly"]() {
      return this.readOnly ? "" : void 0;
    }
  });
  const [local, _, others] = splitProps(props, ["inputClass", "children", "ref", "tabIndex", "onChange"], ["id", "name", "value", "indeterminate", "checked", "defaultChecked", "required", "disabled", "invalid", "readOnly", "onFocus", "onBlur"]);
  const onChange = (event) => {
    if (state.readOnly || state.disabled) {
      event.preventDefault();
      return;
    }
    if (!state.isControlled) {
      const target = event.target;
      setState("_checked", target.checked);
    }
    chainHandlers(checkboxGroupContext == null ? void 0 : checkboxGroupContext.onChange, local.onChange)(event);
  };
  const onFocus = (event) => {
    setState("isFocused", true);
    callHandler(formControlProps.onFocus, event);
  };
  const onBlur = (event) => {
    setState("isFocused", false);
    callHandler(formControlProps.onBlur, event);
  };
  const inputClasses = () => classNames(local.inputClass, visuallyHiddenStyles());
  const stateAccessor = () => state;
  const context = {
    state
  };
  return createComponent(CheckboxPrimitiveContext.Provider, {
    value: context,
    get children() {
      return createComponent(hope.label, mergeProps({
        get ["for"]() {
          return state.id;
        },
        "data-group": true,
        get ["data-indeterminate"]() {
          return state["data-indeterminate"];
        },
        get ["data-focus"]() {
          return state["data-focus"];
        },
        get ["data-checked"]() {
          return state["data-checked"];
        },
        get ["data-required"]() {
          return state["data-required"];
        },
        get ["data-disabled"]() {
          return state["data-disabled"];
        },
        get ["data-invalid"]() {
          return state["data-invalid"];
        },
        get ["data-readonly"]() {
          return state["data-readonly"];
        }
      }, others, {
        get children() {
          return [(() => {
            const _el$ = _tmpl$$a.cloneNode(true);
            _el$.addEventListener("blur", onBlur);
            _el$.addEventListener("focus", onFocus);
            _el$.addEventListener("change", onChange);
            const _ref$ = local.ref;
            typeof _ref$ === "function" ? _ref$(_el$) : local.ref = _el$;
            createRenderEffect((_p$) => {
              const _v$ = inputClasses(), _v$2 = local.tabIndex, _v$3 = state.value, _v$4 = state.id, _v$5 = state.name, _v$6 = state.checked, _v$7 = state.required, _v$8 = state.disabled, _v$9 = state.readOnly, _v$10 = state["aria-required"], _v$11 = state["aria-disabled"], _v$12 = state["aria-invalid"], _v$13 = state["aria-readonly"], _v$14 = state["aria-label"], _v$15 = state["aria-labelledby"], _v$16 = state["aria-describedby"];
              _v$ !== _p$._v$ && (_el$.className = _p$._v$ = _v$);
              _v$2 !== _p$._v$2 && setAttribute(_el$, "tabindex", _p$._v$2 = _v$2);
              _v$3 !== _p$._v$3 && (_el$.value = _p$._v$3 = _v$3);
              _v$4 !== _p$._v$4 && setAttribute(_el$, "id", _p$._v$4 = _v$4);
              _v$5 !== _p$._v$5 && setAttribute(_el$, "name", _p$._v$5 = _v$5);
              _v$6 !== _p$._v$6 && (_el$.checked = _p$._v$6 = _v$6);
              _v$7 !== _p$._v$7 && (_el$.required = _p$._v$7 = _v$7);
              _v$8 !== _p$._v$8 && (_el$.disabled = _p$._v$8 = _v$8);
              _v$9 !== _p$._v$9 && (_el$.readOnly = _p$._v$9 = _v$9);
              _v$10 !== _p$._v$10 && setAttribute(_el$, "aria-required", _p$._v$10 = _v$10);
              _v$11 !== _p$._v$11 && setAttribute(_el$, "aria-disabled", _p$._v$11 = _v$11);
              _v$12 !== _p$._v$12 && setAttribute(_el$, "aria-invalid", _p$._v$12 = _v$12);
              _v$13 !== _p$._v$13 && setAttribute(_el$, "aria-readonly", _p$._v$13 = _v$13);
              _v$14 !== _p$._v$14 && setAttribute(_el$, "aria-label", _p$._v$14 = _v$14);
              _v$15 !== _p$._v$15 && setAttribute(_el$, "aria-labelledby", _p$._v$15 = _v$15);
              _v$16 !== _p$._v$16 && setAttribute(_el$, "aria-describedby", _p$._v$16 = _v$16);
              return _p$;
            }, {
              _v$: void 0,
              _v$2: void 0,
              _v$3: void 0,
              _v$4: void 0,
              _v$5: void 0,
              _v$6: void 0,
              _v$7: void 0,
              _v$8: void 0,
              _v$9: void 0,
              _v$10: void 0,
              _v$11: void 0,
              _v$12: void 0,
              _v$13: void 0,
              _v$14: void 0,
              _v$15: void 0,
              _v$16: void 0
            });
            return _el$;
          })(), createComponent(Show, {
            get when() {
              return isFunction(local.children);
            },
            get fallback() {
              return local.children;
            },
            get children() {
              var _a;
              return (_a = local.children) == null ? void 0 : _a.call(local, {
                state: stateAccessor
              });
            }
          })];
        }
      }));
    }
  });
}
var CheckboxPrimitiveContext = createContext();
function useCheckboxPrimitiveContext() {
  const context = useContext(CheckboxPrimitiveContext);
  if (!context) {
    throw new Error("[Hope UI]: useCheckboxPrimitiveContext must be used within a `<CheckboxPrimitive />` component");
  }
  return context;
}
var _tmpl$$9 = template(`<svg><path d="M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z" fill="currentColor" stroke="currentColor" stroke-width="1" fill-rule="evenodd" clip-rule="evenodd"></path></svg>`, 4, true);
var _tmpl$2 = template(`<svg><path d="M2.25 7.5C2.25 7.22386 2.47386 7 2.75 7H12.25C12.5261 7 12.75 7.22386 12.75 7.5C12.75 7.77614 12.5261 8 12.25 8H2.75C2.47386 8 2.25 7.77614 2.25 7.5Z" fill="currentColor" stroke="currentColor" stroke-width="1" fill-rule="evenodd" clip-rule="evenodd"></path></svg>`, 4, true);
var hopeCheckboxClass = "hope-checkbox";
var hopeCheckboxInputClass = "hope-checkbox__input";
var hopeCheckboxControlClass = "hope-checkbox__control";
var hopeCheckboxLabelClass = "hope-checkbox__label";
function Checkbox(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
  const theme = useStyleConfig().Checkbox;
  const checkboxGroupContext = useCheckboxGroupContext();
  const defaultProps = {
    variant: (_e = (_d = (_a = checkboxGroupContext == null ? void 0 : checkboxGroupContext.state) == null ? void 0 : _a.variant) != null ? _d : (_c = (_b = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _b.root) == null ? void 0 : _c.variant) != null ? _e : "outline",
    colorScheme: (_j = (_i = (_f = checkboxGroupContext == null ? void 0 : checkboxGroupContext.state) == null ? void 0 : _f.colorScheme) != null ? _i : (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.root) == null ? void 0 : _h.colorScheme) != null ? _j : "primary",
    size: (_o = (_n = (_k = checkboxGroupContext == null ? void 0 : checkboxGroupContext.state) == null ? void 0 : _k.size) != null ? _n : (_m = (_l = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _l.root) == null ? void 0 : _m.size) != null ? _o : "md",
    labelPlacement: (_t = (_s = (_p = checkboxGroupContext == null ? void 0 : checkboxGroupContext.state) == null ? void 0 : _p.labelPlacement) != null ? _s : (_r = (_q = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _q.root) == null ? void 0 : _r.labelPlacement) != null ? _t : "end"
  };
  const propsWitDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWitDefault, ["children", "class", "variant", "colorScheme", "size", "labelPlacement", "iconChecked", "iconIndeterminate"]);
  const wrapperClasses = () => {
    return classNames(local.class, hopeCheckboxClass, checkboxWrapperStyles({
      size: local.size,
      labelPlacement: local.labelPlacement
    }));
  };
  const controlClasses = () => {
    return classNames(hopeCheckboxControlClass, checkboxControlStyles({
      variant: local.variant,
      colorScheme: local.colorScheme,
      size: local.size
    }));
  };
  const labelClasses = () => {
    return classNames(hopeCheckboxLabelClass, checkboxLabelStyles());
  };
  return createComponent(CheckboxPrimitive, mergeProps({
    get ["class"]() {
      return wrapperClasses();
    },
    inputClass: hopeCheckboxInputClass,
    get __baseStyle() {
      var _a2;
      return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.root;
    }
  }, others, {
    children: ({
      state
    }) => [createComponent(hope.span, {
      "aria-hidden": true,
      get ["class"]() {
        return controlClasses();
      },
      get __baseStyle() {
        var _a2;
        return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.control;
      },
      get ["data-indeterminate"]() {
        return state()["data-indeterminate"];
      },
      get ["data-focus"]() {
        return state()["data-focus"];
      },
      get ["data-checked"]() {
        return state()["data-checked"];
      },
      get ["data-required"]() {
        return state()["data-required"];
      },
      get ["data-disabled"]() {
        return state()["data-disabled"];
      },
      get ["data-invalid"]() {
        return state()["data-invalid"];
      },
      get ["data-readonly"]() {
        return state()["data-readonly"];
      },
      get children() {
        return createComponent(Switch, {
          get children() {
            return [createComponent(Match, {
              get when() {
                return state().indeterminate;
              },
              get children() {
                return createComponent(Show, {
                  get when() {
                    return local.iconIndeterminate;
                  },
                  get fallback() {
                    return createComponent(CheckboxIconIndeterminate, {});
                  },
                  get children() {
                    return local.iconIndeterminate;
                  }
                });
              }
            }), createComponent(Match, {
              get when() {
                return memo(() => !!state().checked, true)() && !state().indeterminate;
              },
              get children() {
                return createComponent(Show, {
                  get when() {
                    return local.iconChecked;
                  },
                  get fallback() {
                    return createComponent(CheckboxIconCheck, {});
                  },
                  get children() {
                    return local.iconChecked;
                  }
                });
              }
            })];
          }
        });
      }
    }), createComponent(hope.span, {
      get ["class"]() {
        return labelClasses();
      },
      get __baseStyle() {
        var _a2;
        return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.label;
      },
      get ["data-indeterminate"]() {
        return state()["data-indeterminate"];
      },
      get ["data-focus"]() {
        return state()["data-focus"];
      },
      get ["data-checked"]() {
        return state()["data-checked"];
      },
      get ["data-required"]() {
        return state()["data-required"];
      },
      get ["data-disabled"]() {
        return state()["data-disabled"];
      },
      get ["data-invalid"]() {
        return state()["data-invalid"];
      },
      get ["data-readonly"]() {
        return state()["data-readonly"];
      },
      get children() {
        return local.children;
      }
    })]
  }));
}
Checkbox.toString = () => createClassSelector(hopeCheckboxClass);
var CheckboxIconCheck = createIcon({
  viewBox: "0 0 15 15",
  path: () => _tmpl$$9.cloneNode(true)
});
var CheckboxIconIndeterminate = createIcon({
  viewBox: "0 0 15 15",
  path: () => _tmpl$2.cloneNode(true)
});
function CheckboxPrimitiveIndicator(props) {
  const checkboxPrimitiveContext = useCheckboxPrimitiveContext();
  return createComponent(Show, {
    get when() {
      return checkboxPrimitiveContext.state.checked || checkboxPrimitiveContext.state.indeterminate;
    },
    get children() {
      return createComponent(hope.span, mergeProps({
        "aria-hidden": true,
        get ["data-indeterminate"]() {
          return checkboxPrimitiveContext.state["data-indeterminate"];
        },
        get ["data-focus"]() {
          return checkboxPrimitiveContext.state["data-focus"];
        },
        get ["data-checked"]() {
          return checkboxPrimitiveContext.state["data-checked"];
        },
        get ["data-required"]() {
          return checkboxPrimitiveContext.state["data-required"];
        },
        get ["data-disabled"]() {
          return checkboxPrimitiveContext.state["data-disabled"];
        },
        get ["data-invalid"]() {
          return checkboxPrimitiveContext.state["data-invalid"];
        },
        get ["data-readonly"]() {
          return checkboxPrimitiveContext.state["data-readonly"];
        }
      }, props));
    }
  });
}
var growAndShrink = keyframes({
  "0%": {
    strokeDasharray: "1, 400",
    strokeDashoffset: "0"
  },
  "50%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-100"
  },
  "100%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-260"
  }
});
var circularProgressStyles = css({
  position: "relative",
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  verticalAlign: "middle"
});
var circularProgressTrackStyles = css({
  fill: "transparent",
  stroke: "currentColor"
});
var circularProgressIndicatorContainerStyles = css({
  position: "absolute",
  top: 0,
  left: 0,
  variants: {
    spin: {
      true: {
        animation: `${spin} 2s linear infinite`
      }
    }
  }
});
var circularProgressIndicatorStyles = css({
  fill: "transparent",
  stroke: "currentColor",
  opacity: 1,
  variants: {
    hidden: {
      true: {
        opacity: 0
      }
    },
    withRoundCaps: {
      true: { strokeLinecap: "round" }
    },
    indeterminate: {
      true: {
        animation: `${growAndShrink} 2s linear infinite`
      },
      false: {
        strokeDashoffset: 66,
        transitionProperty: "stroke-dasharray, stroke, opacity",
        transitionDuration: "600ms",
        transitionTimingFunction: "ease"
      }
    }
  }
});
var circularProgressLabelStyles = css({
  position: "absolute",
  top: "50%",
  left: "50%",
  width: "100%",
  color: "$neutral12",
  fontSize: "$xs",
  lineHeight: "$none",
  fontWeight: "$bold",
  textAlign: "center",
  transform: "translate(-50%, -50%)"
});
var CircularProgressContext = createContext();
var hopeCircularProgressClass = "hope-circular-progress";
var hopeCircularProgressTrackClass = "hope-circular-progress__track";
function CircularProgress(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const theme = useStyleConfig().CircularProgress;
  const [state] = createStore({
    get size() {
      var _a2, _b2, _c2, _d2;
      return (_d2 = (_c2 = props.size) != null ? _c2 : (_b2 = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.root) == null ? void 0 : _b2.size) != null ? _d2 : "$12";
    },
    get thickness() {
      var _a2, _b2, _c2, _d2;
      return (_d2 = (_c2 = props.thickness) != null ? _c2 : (_b2 = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.root) == null ? void 0 : _b2.thickness) != null ? _d2 : "$2_5";
    },
    get min() {
      var _a2;
      return (_a2 = props.min) != null ? _a2 : 0;
    },
    get max() {
      var _a2;
      return (_a2 = props.max) != null ? _a2 : 100;
    },
    get value() {
      var _a2;
      return (_a2 = props.value) != null ? _a2 : 0;
    },
    get percent() {
      return valueToPercent(this.value, this.min, this.max);
    },
    get indeterminate() {
      var _a2;
      return (_a2 = props.indeterminate) != null ? _a2 : false;
    },
    get ariaValueText() {
      var _a2;
      if (this.indeterminate) {
        return void 0;
      }
      if (isFunction(this.getValueText)) {
        return this.getValueText(this.value, this.percent);
      }
      return (_a2 = props.valueText) != null ? _a2 : `${this.percent}%`;
    },
    get getValueText() {
      return props.getValueText;
    },
    get isIndicatorVisible() {
      return this.value > 0 || this.indeterminate ? true : false;
    }
  });
  const defaultProps = {
    size: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.size) != null ? _c : "$12",
    thickness: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.root) == null ? void 0 : _e.thickness) != null ? _f : "$2_5",
    trackColor: (_i = (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.root) == null ? void 0 : _h.trackColor) != null ? _i : "$neutral4"
  };
  const propsWithDefaults = mergeProps(defaultProps, props);
  const [local, _, others] = splitProps(propsWithDefaults, ["class", "children", "trackColor"], ["size", "thickness", "min", "max", "getValueText"]);
  const rootClasses = () => classNames(local.class, hopeCircularProgressClass, circularProgressStyles());
  const trackClasses = () => {
    return classNames(hopeCircularProgressTrackClass, circularProgressTrackStyles({
      css: {
        color: local.trackColor,
        strokeWidth: state.thickness
      }
    }));
  };
  const context = {
    state
  };
  return createComponent(CircularProgressContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        role: "progressbar",
        get ["data-indeterminate"]() {
          return state.indeterminate ? "" : void 0;
        },
        get ["aria-valuemin"]() {
          return state.min;
        },
        get ["aria-valuemax"]() {
          return state.max;
        },
        get ["aria-valuenow"]() {
          return state.indeterminate ? void 0 : state.value;
        },
        get ["aria-valuetext"]() {
          return state.ariaValueText;
        },
        get ["class"]() {
          return rootClasses();
        },
        get __baseStyle() {
          var _a2;
          return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.root;
        }
      }, others, {
        get children() {
          return [createComponent(hope.svg, {
            viewBox: "0 0 100 100",
            get boxSize() {
              return state.size;
            },
            get children() {
              return createComponent(hope.circle, {
                cx: 50,
                cy: 50,
                r: 42,
                get ["class"]() {
                  return trackClasses();
                },
                get __baseStyle() {
                  var _a2;
                  return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.track;
                }
              });
            }
          }), memo(() => local.children)];
        }
      }));
    }
  });
}
CircularProgress.toString = () => createClassSelector(hopeCircularProgressClass);
function useCircularProgressContext() {
  const context = useContext(CircularProgressContext);
  if (!context) {
    throw new Error("[Hope UI]: useCircularProgressContext must be used within a `<CircularProgress />` component");
  }
  return context;
}
var hopeCircularProgressIndicatorClass = "hope-circular-progress__indicator";
function CircularProgressIndicator(props) {
  var _a, _b, _c, _d, _e, _f;
  const theme = useStyleConfig().CircularProgress;
  const circularProgressContext = useCircularProgressContext();
  const defaultProps = {
    color: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.indicator) == null ? void 0 : _b.color) != null ? _c : "$primary9",
    withRoundCaps: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.indicator) == null ? void 0 : _e.withRoundCaps) != null ? _f : false
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "children", "color", "withRoundCaps"]);
  const strokeDasharray = () => {
    if (circularProgressContext.state.indeterminate) {
      return void 0;
    }
    const determinant = circularProgressContext.state.percent * 2.64;
    return `${determinant} ${264 - determinant}`;
  };
  const rootClasses = () => {
    return classNames(local.class, hopeCircularProgressIndicatorClass, circularProgressIndicatorContainerStyles({
      spin: circularProgressContext.state.indeterminate
    }));
  };
  const indicatorClasses = () => {
    return circularProgressIndicatorStyles({
      hidden: !circularProgressContext.state.isIndicatorVisible,
      indeterminate: circularProgressContext.state.indeterminate === true ? true : false,
      withRoundCaps: local.withRoundCaps,
      css: {
        color: local.color,
        strokeWidth: circularProgressContext.state.thickness,
        strokeDasharray: strokeDasharray()
      }
    });
  };
  return createComponent(hope.svg, mergeProps({
    viewBox: "0 0 100 100",
    get ["class"]() {
      return rootClasses();
    },
    get boxSize() {
      return circularProgressContext.state.size;
    }
  }, others, {
    get children() {
      return createComponent(hope.circle, {
        cx: 50,
        cy: 50,
        r: 42,
        get ["class"]() {
          return indicatorClasses();
        },
        get __baseStyle() {
          var _a2;
          return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.indicator;
        }
      });
    }
  }));
}
CircularProgressIndicator.toString = () => createClassSelector(hopeCircularProgressIndicatorClass);
var hopeCircularProgressLabelClass = "hope-circular-progress__label";
function CircularProgressLabel(props) {
  const theme = useStyleConfig().CircularProgress;
  const circularProgressContext = useCircularProgressContext();
  const [local, others] = splitProps(props, ["class", "children"]);
  const classes = () => {
    return classNames(local.class, hopeCircularProgressLabelClass, circularProgressLabelStyles());
  };
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.label;
    }
  }, others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return local.children;
        },
        get fallback() {
          return circularProgressContext.state.ariaValueText;
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
CircularProgressLabel.toString = () => createClassSelector(hopeCircularProgressLabelClass);
var _tmpl$$8 = template(`<svg><path fill="currentColor" d="M2.64 1.27L7.5 6.13l4.84-4.84A.92.92 0 0 1 13 1a1 1 0 0 1 1 1a.9.9 0 0 1-.27.66L8.84 7.5l4.89 4.89A.9.9 0 0 1 14 13a1 1 0 0 1-1 1a.92.92 0 0 1-.69-.27L7.5 8.87l-4.85 4.85A.92.92 0 0 1 2 14a1 1 0 0 1-1-1a.9.9 0 0 1 .27-.66L6.16 7.5L1.27 2.61A.9.9 0 0 1 1 2a1 1 0 0 1 1-1c.24.003.47.1.64.27z"></path></svg>`, 4, true);
var IconClose = createIcon({
  viewBox: "0 0 15 15",
  path: () => _tmpl$$8.cloneNode(true)
});
var closeButtonStyles = css({
  appearance: "none",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0,
  outline: "none",
  borderWidth: 0,
  borderRadius: "$sm",
  backgroundColor: "transparent",
  padding: 0,
  color: "currentColor",
  cursor: "pointer",
  userSelect: "none",
  transition: "color 250ms, background-color 250ms",
  "&:disbaled": {
    opacity: "0.5",
    cursor: "not-allowed",
    boxShadow: "none"
  },
  "&:hover": {
    backgroundColor: "$closeButtonHoverBackground"
  },
  "&:active": {
    backgroundColor: "$closeButtonActiveBackground"
  },
  "&:focus": {
    outline: "none",
    boxShadow: "$outline"
  },
  variants: {
    size: {
      sm: {
        boxSize: "24px",
        fontSize: "10px"
      },
      md: {
        boxSize: "32px",
        fontSize: "12px"
      },
      lg: {
        boxSize: "40px",
        fontSize: "16px"
      }
    }
  }
});
var hopeCloseButtonClass = "hope-close-button";
function CloseButton(props) {
  var _a, _b, _c, _d, _e, _f;
  const theme = useStyleConfig().CloseButton;
  const defaultProps = {
    "aria-label": (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a["aria-label"]) != null ? _b : "Close",
    icon: (_d = (_c = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _c.icon) != null ? _d : createComponent(IconClose, {}),
    size: (_f = (_e = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _e.size) != null ? _f : "md"
  };
  const propsWithDefaults = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefaults, ["class", "children", "size", "icon"]);
  const classes = () => {
    return classNames(local.class, hopeCloseButtonClass, closeButtonStyles({
      size: local.size
    }));
  };
  return createComponent(hope.button, mergeProps({
    type: "button",
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      return theme == null ? void 0 : theme.baseStyle;
    }
  }, others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return local.children;
        },
        get fallback() {
          return local.icon;
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
CloseButton.toString = () => createClassSelector(hopeCloseButtonClass);
var containerStyles = css({
  width: "100%",
  "@sm": { maxWidth: "$containerSm" },
  "@md": { maxWidth: "$containerMd" },
  "@lg": { maxWidth: "$containerLg" },
  "@xl": { maxWidth: "$containerXl" },
  "@2xl": { maxWidth: "$container2xl" },
  variants: {
    centered: {
      true: {
        mx: "auto"
      }
    },
    centerContent: {
      true: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      }
    }
  }
});
var hopeContainerClass = "hope-container";
function Container(props) {
  const defaultProps = {
    centered: true,
    centerContent: false
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, variantProps, others] = splitProps(propsWithDefault, ["class"], ["centered", "centerContent"]);
  const classes = () => classNames(local.class, hopeContainerClass, containerStyles(variantProps));
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    }
  }, others));
}
Container.toString = () => createClassSelector(hopeContainerClass);
var dividerStyles = css({
  border: 0,
  borderColor: "currentColor",
  variants: {
    variant: {
      solid: {
        borderStyle: "solid"
      },
      dashed: {
        borderStyle: "dashed"
      },
      dotted: {
        borderStyle: "dotted"
      }
    },
    orientation: {
      vertical: {
        height: "100%"
      },
      horizontal: {
        width: "100%"
      }
    }
  }
});
var hopeDividerClass = "hope-divider";
function Divider(props) {
  const defaultProps = {
    as: "div",
    variant: "solid",
    orientation: "horizontal",
    color: "$neutral6",
    thickness: "1px"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "variant", "orientation", "thickness"]);
  const classes = () => {
    return classNames(local.class, hopeDividerClass, dividerStyles({
      variant: local.variant,
      orientation: local.orientation,
      css: {
        borderLeftWidth: local.orientation === "vertical" ? local.thickness : 0,
        borderBottomWidth: local.orientation === "horizontal" ? local.thickness : 0
      }
    }));
  };
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    }
  }, others));
}
Divider.toString = () => createClassSelector(hopeDividerClass);
function Modal(props) {
  const defaultDialogId = `hope-modal-${createUniqueId()}`;
  const theme = useStyleConfig().Modal;
  const [state, setState] = createStore({
    headerMounted: false,
    bodyMounted: false,
    get opened() {
      return props.opened;
    },
    get dialogId() {
      var _a;
      return (_a = props.id) != null ? _a : defaultDialogId;
    },
    get headerId() {
      return `${this.dialogId}--header`;
    },
    get bodyId() {
      return `${this.dialogId}--body`;
    },
    get initialFocus() {
      return props.initialFocus;
    },
    get motionPreset() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.motionPreset) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.motionPreset) != null ? _d : "scale";
    },
    get size() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.size) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.size) != null ? _d : "md";
    },
    get centered() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.centered) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.centered) != null ? _d : false;
    },
    get scrollBehavior() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.scrollBehavior) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.scrollBehavior) != null ? _d : "outside";
    },
    get closeOnOverlayClick() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.closeOnOverlayClick) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.closeOnOverlayClick) != null ? _d : true;
    },
    get closeOnEsc() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.closeOnEsc) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.closeOnEsc) != null ? _d : true;
    },
    get trapFocus() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.trapFocus) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.trapFocus) != null ? _d : true;
    },
    get blockScrollOnMount() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.blockScrollOnMount) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.blockScrollOnMount) != null ? _d : true;
    },
    get preserveScrollBarGap() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.preserveScrollBarGap) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.preserveScrollBarGap) != null ? _d : false;
    }
  });
  const [isPortalMounted, setIsPortalMounted] = createSignal(false);
  createEffect(() => {
    if (state.opened) {
      setIsPortalMounted(true);
    } else {
      state.motionPreset === "none" && setIsPortalMounted(false);
    }
  });
  const unmountPortal = () => setIsPortalMounted(false);
  const onClose = () => props.onClose();
  const setHeaderMounted = (value) => setState("headerMounted", value);
  const setBodyMounted = (value) => setState("bodyMounted", value);
  let mouseDownTarget = null;
  const onMouseDown = (event) => {
    mouseDownTarget = event.target;
  };
  const onKeyDown = (event) => {
    var _a;
    if (event.key === "Escape") {
      event.stopPropagation();
      if (state.closeOnEsc) {
        onClose();
      }
      (_a = props.onEsc) == null ? void 0 : _a.call(props);
    }
  };
  const onOverlayClick = (event) => {
    var _a;
    event.stopPropagation();
    if (mouseDownTarget !== event.target) {
      return;
    }
    if (state.closeOnOverlayClick) {
      onClose();
    }
    (_a = props.onOverlayClick) == null ? void 0 : _a.call(props);
  };
  const context = {
    state,
    unmountPortal,
    onClose,
    onMouseDown,
    onKeyDown,
    onOverlayClick,
    setHeaderMounted,
    setBodyMounted
  };
  return createComponent(Show, {
    get when() {
      return isPortalMounted();
    },
    get children() {
      return createComponent(ModalContext.Provider, {
        value: context,
        get children() {
          return createComponent(Portal, {
            get children() {
              return props.children;
            }
          });
        }
      });
    }
  });
}
var ModalContext = createContext();
function useModalContext() {
  const context = useContext(ModalContext);
  if (!context) {
    throw new Error("[Hope UI]: useModalContext must be used within a `<Modal />` component");
  }
  return context;
}
var hopeModalBodyClass = "hope-modal__body";
function ModalBody(props) {
  const theme = useStyleConfig().Modal;
  const modalContext = useModalContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => {
    return classNames(local.class, hopeModalBodyClass, modalBodyStyles({
      scrollBehavior: modalContext.state.scrollBehavior
    }));
  };
  onMount(() => modalContext.setBodyMounted(true));
  onCleanup(() => modalContext.setBodyMounted(false));
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get id() {
      return modalContext.state.bodyId;
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.body;
    }
  }, others));
}
ModalBody.toString = () => createClassSelector(hopeModalBodyClass);
var hopeModalCloseButtonClass = "hope-modal__close-button";
function ModalCloseButton(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const theme = useStyleConfig().Modal;
  const modalContext = useModalContext();
  const defaultProps = {
    "aria-label": (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.closeButton) == null ? void 0 : _b["aria-label"]) != null ? _c : "Close modal",
    size: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.closeButton) == null ? void 0 : _e.size) != null ? _f : "md",
    icon: (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.closeButton) == null ? void 0 : _h.icon
  };
  const propsWithDefaults = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefaults, ["class", "onClick"]);
  const classes = () => classNames(local.class, hopeModalCloseButtonClass, modalCloseButtonStyles());
  const onClick = (event) => {
    chainHandlers(local.onClick, (e) => {
      e.stopPropagation();
      modalContext.onClose();
    })(event);
  };
  return createComponent(CloseButton, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a2;
      return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.closeButton;
    },
    onClick
  }, others));
}
ModalCloseButton.toString = () => createClassSelector(hopeModalCloseButtonClass);
var hopeModalFooterClass = "hope-modal__footer";
function ModalFooter(props) {
  const theme = useStyleConfig().Modal;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeModalFooterClass, modalFooterStyles());
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.footer;
    }
  }, others));
}
ModalFooter.toString = () => createClassSelector(hopeModalFooterClass);
var hopeModalHeaderClass = "hope-modal__header";
function ModalHeader(props) {
  const theme = useStyleConfig().Modal;
  const modalContext = useModalContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeModalHeaderClass, modalHeaderStyles());
  onMount(() => modalContext.setHeaderMounted(true));
  onCleanup(() => modalContext.setHeaderMounted(false));
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get id() {
      return modalContext.state.headerId;
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.header;
    }
  }, others));
}
ModalHeader.toString = () => createClassSelector(hopeModalHeaderClass);
var DrawerContext = createContext();
function Drawer(props) {
  const theme = useStyleConfig().Drawer;
  const [, modalProps] = splitProps(props, ["opened", "onClose", "placement", "size", "fullHeight", "disableMotion"]);
  const [state] = createStore({
    get placement() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.placement) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.placement) != null ? _d : "right";
    },
    get size() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.size) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.size) != null ? _d : "xs";
    },
    get fullHeight() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.fullHeight) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.fullHeight) != null ? _d : false;
    },
    get disableMotion() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.disableMotion) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.disableMotion) != null ? _d : false;
    }
  });
  return createComponent(DrawerContext.Provider, {
    value: state,
    get children() {
      return createComponent(Modal, mergeProps({
        scrollBehavior: "inside",
        get blockScrollOnMount() {
          var _a, _b;
          return (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.blockScrollOnMount;
        },
        get closeOnEsc() {
          var _a, _b;
          return (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.closeOnEsc;
        },
        get closeOnOverlayClick() {
          var _a, _b;
          return (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.closeOnOverlayClick;
        },
        get preserveScrollBarGap() {
          var _a, _b;
          return (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.preserveScrollBarGap;
        },
        get trapFocus() {
          var _a, _b;
          return (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.trapFocus;
        },
        get opened() {
          return props.opened;
        },
        get onClose() {
          return props.onClose;
        }
      }, modalProps));
    }
  });
}
function useDrawerContext() {
  const context = useContext(DrawerContext);
  if (!context) {
    throw new Error("[Hope UI]: useDrawerContext must be used within a `<Drawer />` component");
  }
  return context;
}
function DrawerCloseButton(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const theme = useStyleConfig().Drawer;
  const defaultProps = {
    "aria-label": (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.closeButton) == null ? void 0 : _b["aria-label"]) != null ? _c : "Close drawer",
    size: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.closeButton) == null ? void 0 : _e.size) != null ? _f : "md",
    icon: (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.closeButton) == null ? void 0 : _h.icon
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  return createComponent(ModalCloseButton, mergeProps({
    get __baseStyle() {
      var _a2;
      return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.closeButton;
    }
  }, propsWithDefault));
}
function DrawerBody(props) {
  const theme = useStyleConfig().Drawer;
  return createComponent(ModalBody, mergeProps({
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.body;
    }
  }, props));
}
function DrawerHeader(props) {
  const theme = useStyleConfig().Drawer;
  return createComponent(ModalHeader, mergeProps({
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.header;
    }
  }, props));
}
function DrawerFooter(props) {
  const theme = useStyleConfig().Drawer;
  return createComponent(ModalFooter, mergeProps({
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.footer;
    }
  }, props));
}
function createModal(props) {
  const modalContext = useModalContext();
  let containerRef;
  let focusTrap;
  const assignContainerRef = (el) => {
    containerRef = el;
  };
  const ariaLabelledBy = () => {
    return modalContext.state.headerMounted ? modalContext.state.headerId : void 0;
  };
  const ariaDescribedBy = () => {
    return modalContext.state.bodyMounted ? modalContext.state.bodyId : void 0;
  };
  const onDialogClick = (event) => {
    chainHandlers(props.onClick, (e) => e.stopPropagation())(event);
  };
  const dialogSelector = () => `[id='${modalContext.state.dialogId}']`;
  const childOfDialogSelector = () => `${dialogSelector()} *`;
  const enableFocusTrapAndScrollLock = () => {
    if (!containerRef) {
      return;
    }
    if (modalContext.state.trapFocus) {
      focusTrap = createFocusTrap(containerRef, {
        initialFocus: modalContext.state.initialFocus,
        fallbackFocus: dialogSelector(),
        allowOutsideClick: true
      });
      focusTrap.activate();
    }
    if (modalContext.state.blockScrollOnMount) {
      (0, import_scroll_lock.addScrollableSelector)(childOfDialogSelector());
      (0, import_scroll_lock.disablePageScroll)(containerRef);
    }
  };
  const disableFocusTrapAndScrollLock = () => {
    focusTrap == null ? void 0 : focusTrap.deactivate();
    (0, import_scroll_lock.removeScrollableSelector)(childOfDialogSelector());
    (0, import_scroll_lock.clearQueueScrollLocks)();
    (0, import_scroll_lock.enablePageScroll)();
  };
  onMount(() => {
    enableFocusTrapAndScrollLock();
  });
  onCleanup(() => {
    disableFocusTrapAndScrollLock();
  });
  return {
    assignContainerRef,
    ariaLabelledBy,
    ariaDescribedBy,
    onDialogClick
  };
}
var hopeModalContainerClass = "hope-modal__content-container";
var hopeModalContentClass = "hope-modal__content";
function ModalContent(props) {
  const theme = useStyleConfig().Modal;
  const modalContext = useModalContext();
  const [local, others] = splitProps(props, ["ref", "class", "role", "aria-labelledby", "aria-describedby", "onClick"]);
  const {
    assignContainerRef,
    ariaLabelledBy,
    ariaDescribedBy,
    onDialogClick
  } = createModal(local);
  const containerClasses = () => {
    const containerClass = modalContainerStyles({
      centered: modalContext.state.centered,
      scrollBehavior: modalContext.state.scrollBehavior
    });
    return classNames(hopeModalContainerClass, containerClass);
  };
  const dialogClasses = () => {
    const dialogClass = modalDialogStyles({
      size: modalContext.state.size,
      scrollBehavior: modalContext.state.scrollBehavior
    });
    return classNames(local.class, hopeModalContentClass, dialogClass);
  };
  const transitionName = () => {
    switch (modalContext.state.motionPreset) {
      case "fade-in-bottom":
        return modalTransitionName.fadeInBottom;
      case "scale":
        return modalTransitionName.scale;
      case "none":
        return "hope-none";
    }
  };
  return createComponent(Transition, {
    get name() {
      return transitionName();
    },
    appear: true,
    get onAfterExit() {
      return modalContext.unmountPortal;
    },
    get children() {
      return createComponent(Show, {
        get when() {
          return modalContext.state.opened;
        },
        get children() {
          return createComponent(Box, {
            ref: assignContainerRef,
            get ["class"]() {
              return containerClasses();
            },
            tabIndex: -1,
            get onMouseDown() {
              return modalContext.onMouseDown;
            },
            get onKeyDown() {
              return modalContext.onKeyDown;
            },
            get onClick() {
              return modalContext.onOverlayClick;
            },
            get children() {
              return createComponent(hope.section, mergeProps({
                get ["class"]() {
                  return dialogClasses();
                },
                get __baseStyle() {
                  var _a;
                  return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.content;
                },
                get id() {
                  return modalContext.state.dialogId;
                },
                get role() {
                  var _a;
                  return (_a = local.role) != null ? _a : "dialog";
                },
                tabIndex: -1,
                "aria-modal": true,
                get ["aria-labelledby"]() {
                  return ariaLabelledBy();
                },
                get ["aria-describedby"]() {
                  return ariaDescribedBy();
                },
                onClick: onDialogClick
              }, others));
            }
          });
        }
      });
    }
  });
}
ModalContent.toString = () => createClassSelector(hopeModalContentClass);
var hopeModalOverlayClass = "hope-modal__overlay";
function ModalOverlay(props) {
  const theme = useStyleConfig().Modal;
  const modalContext = useModalContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeModalOverlayClass, modalOverlayStyles());
  const transitionName = () => {
    return modalContext.state.motionPreset === "none" ? "hope-none" : modalTransitionName.fade;
  };
  return createComponent(Transition, {
    get name() {
      return transitionName();
    },
    appear: true,
    get children() {
      return createComponent(Show, {
        get when() {
          return modalContext.state.opened;
        },
        get children() {
          return createComponent(Box, mergeProps({
            get ["class"]() {
              return classes();
            },
            get __baseStyle() {
              var _a;
              return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.overlay;
            }
          }, others));
        }
      });
    }
  });
}
ModalOverlay.toString = () => createClassSelector(hopeModalOverlayClass);
var hopeDrawerContainerClass = "hope-drawer__content-container";
var hopeDrawerContentClass = "hope-drawer__content";
function DrawerContent(props) {
  const theme = useStyleConfig().Drawer;
  const drawerContext = useDrawerContext();
  const modalContext = useModalContext();
  const [local, others] = splitProps(props, ["ref", "class", "role", "aria-labelledby", "aria-describedby", "onClick"]);
  const {
    assignContainerRef,
    ariaLabelledBy,
    ariaDescribedBy,
    onDialogClick
  } = createModal(local);
  const containerClasses = () => {
    return classNames(hopeDrawerContainerClass, drawerContainerStyles({
      placement: drawerContext.placement
    }));
  };
  const dialogClasses = () => {
    const dialogClass = drawerDialogStyles({
      size: drawerContext.size,
      placement: drawerContext.placement,
      fullHeight: drawerContext.fullHeight
    });
    return classNames(local.class, hopeDrawerContentClass, dialogClass);
  };
  const transitionName = () => {
    if (drawerContext.disableMotion) {
      return "hope-none";
    }
    switch (drawerContext.placement) {
      case "top":
        return drawerTransitionName.slideInTop;
      case "right":
        return drawerTransitionName.slideInRight;
      case "bottom":
        return drawerTransitionName.slideInBottom;
      case "left":
        return drawerTransitionName.slideInLeft;
    }
  };
  return createComponent(Transition, {
    get name() {
      return transitionName();
    },
    appear: true,
    get onAfterExit() {
      return modalContext.unmountPortal;
    },
    get children() {
      return createComponent(Show, {
        get when() {
          return modalContext.state.opened;
        },
        get children() {
          return createComponent(Box, {
            ref: assignContainerRef,
            get ["class"]() {
              return containerClasses();
            },
            tabIndex: -1,
            get onMouseDown() {
              return modalContext.onMouseDown;
            },
            get onKeyDown() {
              return modalContext.onKeyDown;
            },
            get onClick() {
              return modalContext.onOverlayClick;
            },
            get children() {
              return createComponent(hope.section, mergeProps({
                get ["class"]() {
                  return dialogClasses();
                },
                get __baseStyle() {
                  var _a;
                  return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.content;
                },
                get id() {
                  return modalContext.state.dialogId;
                },
                get role() {
                  var _a;
                  return (_a = local.role) != null ? _a : "dialog";
                },
                tabIndex: -1,
                "aria-modal": true,
                get ["aria-labelledby"]() {
                  return ariaLabelledBy();
                },
                get ["aria-describedby"]() {
                  return ariaDescribedBy();
                },
                onClick: onDialogClick
              }, others));
            }
          });
        }
      });
    }
  });
}
DrawerContent.toString = () => createClassSelector(hopeDrawerContentClass);
var hopeDrawerOverlayClass = "hope-drawer__overlay";
function DrawerOverlay(props) {
  const theme = useStyleConfig().Drawer;
  const drawerContext = useDrawerContext();
  const modalContext = useModalContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeDrawerOverlayClass, modalOverlayStyles());
  const transitionName = () => {
    return drawerContext.disableMotion ? "hope-none" : drawerTransitionName.fade;
  };
  return createComponent(Transition, {
    get name() {
      return transitionName();
    },
    appear: true,
    get children() {
      return createComponent(Show, {
        get when() {
          return modalContext.state.opened;
        },
        get children() {
          return createComponent(Box, mergeProps({
            get ["class"]() {
              return classes();
            },
            get __baseStyle() {
              var _a;
              return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.overlay;
            }
          }, others));
        }
      });
    }
  });
}
DrawerOverlay.toString = () => createClassSelector(hopeDrawerOverlayClass);
var hopeFlexClass = "hope-flex";
function Flex(props) {
  const [local, others] = splitProps(props, ["class", "direction", "wrap"]);
  const classes = () => classNames(local.class, hopeFlexClass);
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    display: "flex",
    get flexDirection() {
      return local.direction;
    },
    get flexWrap() {
      return local.wrap;
    }
  }, others));
}
Flex.toString = () => createClassSelector(hopeFlexClass);
var hopeFormErrorMessageClass = "hope-form-error-message";
function FormErrorMessage(props) {
  const theme = useStyleConfig().FormControl;
  const formControl = useFormControlContext();
  const [local, others] = splitProps(props, ["ref", "id", "class"]);
  const id = () => {
    var _a;
    return (_a = local.id) != null ? _a : formControl == null ? void 0 : formControl.state.errorMessageId;
  };
  const classes = () => classNames(local.class, hopeFormErrorMessageClass, formErrorMessageStyles());
  onMount(() => formControl == null ? void 0 : formControl.setHasErrorMessage(true));
  onCleanup(() => formControl == null ? void 0 : formControl.setHasErrorMessage(false));
  return createComponent(Show, {
    get when() {
      return formControl == null ? void 0 : formControl.state.invalid;
    },
    get children() {
      return createComponent(Box, mergeProps({
        "aria-live": "polite",
        get id() {
          return id();
        },
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.errorMessage;
        },
        get ["data-disabled"]() {
          return formControl == null ? void 0 : formControl.state["data-disabled"];
        },
        get ["data-readonly"]() {
          return formControl == null ? void 0 : formControl.state["data-readonly"];
        }
      }, others));
    }
  });
}
FormErrorMessage.toString = () => createClassSelector(hopeFormErrorMessageClass);
var hopeFormHelperTextClass = "hope-form-helper-text";
function FormHelperText(props) {
  const theme = useStyleConfig().FormControl;
  const formControl = useFormControlContext();
  const [local, others] = splitProps(props, ["ref", "id", "class"]);
  const id = () => {
    var _a;
    return (_a = local.id) != null ? _a : formControl == null ? void 0 : formControl.state.helperTextId;
  };
  const classes = () => classNames(local.class, hopeFormHelperTextClass, formHelperTextStyles());
  onMount(() => formControl == null ? void 0 : formControl.setHasHelperText(true));
  onCleanup(() => formControl == null ? void 0 : formControl.setHasHelperText(false));
  return createComponent(Box, mergeProps({
    get id() {
      return id();
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.helperText;
    },
    get ["data-disabled"]() {
      return formControl == null ? void 0 : formControl.state["data-disabled"];
    },
    get ["data-readonly"]() {
      return formControl == null ? void 0 : formControl.state["data-readonly"];
    }
  }, others));
}
FormHelperText.toString = () => createClassSelector(hopeFormHelperTextClass);
var _tmpl$$7 = template(`<span role="presentation" aria-hidden="true">*</span>`, 2);
var hopeFormLabelClass = "hope-form-label";
function FormLabel(props) {
  var _a, _b, _c;
  const theme = useStyleConfig().FormControl;
  const formControl = useFormControlContext();
  const defaultProps = {
    withRequiredIndicator: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.label) == null ? void 0 : _b.withRequiredIndicator) != null ? _c : true
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["id", "for", "class", "children", "withRequiredIndicator"]);
  const id = () => {
    var _a2;
    return (_a2 = local.id) != null ? _a2 : formControl == null ? void 0 : formControl.state.labelId;
  };
  const htmlFor = () => {
    var _a2;
    return (_a2 = local.for) != null ? _a2 : formControl == null ? void 0 : formControl.state.id;
  };
  const classes = () => classNames(local.class, hopeFormLabelClass, formLabelStyles());
  return createComponent(hope.label, mergeProps({
    get id() {
      return id();
    },
    get ["for"]() {
      return htmlFor();
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a2;
      return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.label;
    },
    get ["data-focus"]() {
      return formControl == null ? void 0 : formControl.state["data-focus"];
    },
    get ["data-disabled"]() {
      return formControl == null ? void 0 : formControl.state["data-disabled"];
    },
    get ["data-invalid"]() {
      return formControl == null ? void 0 : formControl.state["data-invalid"];
    },
    get ["data-readonly"]() {
      return formControl == null ? void 0 : formControl.state["data-readonly"];
    }
  }, others, {
    get children() {
      return [memo(() => local.children), createComponent(Show, {
        get when() {
          return (formControl == null ? void 0 : formControl.state.required) && local.withRequiredIndicator;
        },
        get children() {
          const _el$ = _tmpl$$7.cloneNode(true);
          createRenderEffect(() => _el$.className = requiredIndicatorStyles());
          return _el$;
        }
      })];
    }
  }));
}
FormLabel.toString = () => createClassSelector(hopeFormLabelClass);
var hopeGridClass = "hope-grid";
function Grid(props) {
  const [local, others] = splitProps(props, ["class", "autoFlow", "autoColumns", "autoRows", "templateAreas", "templateColumns", "templateRows"]);
  const classes = () => classNames(local.class, hopeGridClass);
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    display: "grid",
    get gridAutoFlow() {
      return local.autoFlow;
    },
    get gridAutoColumns() {
      return local.autoColumns;
    },
    get gridAutoRows() {
      return local.autoRows;
    },
    get gridTemplateAreas() {
      return local.templateAreas;
    },
    get gridTemplateColumns() {
      return local.templateColumns;
    },
    get gridTemplateRows() {
      return local.templateRows;
    }
  }, others));
}
Grid.toString = () => createClassSelector(hopeGridClass);
function spanFn(span) {
  if (span === null || span === void 0) {
    return;
  }
  return mapKeys(span, (value) => {
    switch (value) {
      case "auto":
        return "auto";
      case "full":
        return "1 / -1";
      default:
        return `span ${value} / span ${value}`;
    }
  });
}
var hopeGridItemClass = "hope-grid-item";
function GridItem(props) {
  const [local, others] = splitProps(props, ["class", "area", "colSpan", "colStart", "colEnd", "rowSpan", "rowStart", "rowEnd"]);
  const classes = () => classNames(local.class, hopeGridItemClass);
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get gridArea() {
      return local.area;
    },
    get gridColumn() {
      return spanFn(local.colSpan);
    },
    get gridRow() {
      return spanFn(local.rowSpan);
    },
    get gridColumnStart() {
      return local.colStart;
    },
    get gridColumnEnd() {
      return local.colEnd;
    },
    get gridRowStart() {
      return local.rowStart;
    },
    get gridRowEnd() {
      return local.rowEnd;
    }
  }, others));
}
GridItem.toString = () => createClassSelector(hopeGridItemClass);
var hopeSimpleGridClass = "hope-simple-grid";
function toPx(n2) {
  return isNumber(n2) ? `${n2}px` : n2;
}
function widthToColumns(width) {
  return mapResponsive(width, (value) => isNull(value) ? null : `repeat(auto-fit, minmax(${toPx(value)}, 1fr))`);
}
function countToColumns(count) {
  return mapResponsive(count, (value) => isNull(value) ? null : `repeat(${value}, minmax(0, 1fr))`);
}
function SimpleGrid(props) {
  const [local, others] = splitProps(props, ["class", "minChildWidth", "columns"]);
  const classes = () => classNames(local.class, hopeSimpleGridClass);
  const templateColumns = () => {
    return local.minChildWidth ? widthToColumns(local.minChildWidth) : countToColumns(local.columns);
  };
  return createComponent(Grid, mergeProps({
    get ["class"]() {
      return classes();
    },
    get templateColumns() {
      return templateColumns();
    }
  }, others));
}
SimpleGrid.toString = () => createClassSelector(hopeSimpleGridClass);
var textStyles = css({
  variants: {
    size: {
      xs: {
        fontSize: "$xs",
        lineHeight: "$4"
      },
      sm: {
        fontSize: "$sm",
        lineHeight: "$5"
      },
      base: {
        fontSize: "$base",
        lineHeight: "$6"
      },
      lg: {
        fontSize: "$lg",
        lineHeight: "$7"
      },
      xl: {
        fontSize: "$xl",
        lineHeight: "$7"
      },
      "2xl": {
        fontSize: "$2xl",
        lineHeight: "$8"
      },
      "3xl": {
        fontSize: "$3xl",
        lineHeight: "$9"
      },
      "4xl": {
        fontSize: "$4xl",
        lineHeight: "$10"
      },
      "5xl": {
        fontSize: "$5xl",
        lineHeight: "$none"
      },
      "6xl": {
        fontSize: "$6xl",
        lineHeight: "$none"
      },
      "7xl": {
        fontSize: "$7xl",
        lineHeight: "$none"
      },
      "8xl": {
        fontSize: "$8xl",
        lineHeight: "$none"
      },
      "9xl": {
        fontSize: "$9xl",
        lineHeight: "$none"
      }
    }
  }
});
var headingStyles = css(textStyles, {
  fontWeight: "$semibold"
});
var hopeHeadingClass = "hope-heading";
function Heading(props) {
  var _a, _b;
  const theme = useStyleConfig().Heading;
  const defaultProps = {
    as: "h2",
    level: (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.level,
    size: (_b = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _b.size
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "as", "level", "size"]);
  const classes = () => classNames(local.class, hopeHeadingClass, headingStyles({
    size: local.size
  }));
  const asProp = () => local.level ? `h${local.level}` : local.as;
  return createComponent(Box, mergeProps({
    get as() {
      return asProp();
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      return theme == null ? void 0 : theme.baseStyle;
    }
  }, others));
}
Heading.toString = () => createClassSelector(hopeHeadingClass);
function IconButton(props) {
  const theme = useStyleConfig().IconButton;
  const buttonGroupContext = useButtonGroupContext();
  const [local, others] = splitProps(props, ["class", "children", "icon", "variant", "colorScheme", "size", "disabled"]);
  const variant = () => {
    var _a, _b, _c, _d;
    return (_d = (_c = (_a = local.variant) != null ? _a : buttonGroupContext == null ? void 0 : buttonGroupContext.state.variant) != null ? _c : (_b = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _b.variant) != null ? _d : "solid";
  };
  const colorScheme = () => {
    var _a, _b, _c, _d;
    return (_d = (_c = (_a = local.colorScheme) != null ? _a : buttonGroupContext == null ? void 0 : buttonGroupContext.state.colorScheme) != null ? _c : (_b = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _b.colorScheme) != null ? _d : "primary";
  };
  const size22 = () => {
    var _a, _b, _c, _d;
    return (_d = (_c = (_a = local.size) != null ? _a : buttonGroupContext == null ? void 0 : buttonGroupContext.state.size) != null ? _c : (_b = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _b.size) != null ? _d : "md";
  };
  const disabled = () => {
    var _a;
    return (_a = local.disabled) != null ? _a : buttonGroupContext == null ? void 0 : buttonGroupContext.state.disabled;
  };
  const classes = () => classNames(local.class, hopeIconButtonClass);
  return createComponent(Button, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      return theme == null ? void 0 : theme.baseStyle;
    },
    get variant() {
      return variant();
    },
    get colorScheme() {
      return colorScheme();
    },
    get size() {
      return size22();
    },
    get disabled() {
      return disabled();
    }
  }, others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return local.icon;
        },
        get fallback() {
          return local.children;
        },
        get children() {
          return local.icon;
        }
      });
    }
  }));
}
IconButton.toString = () => createClassSelector(hopeIconButtonClass);
var hopeImageClass = "hope-image";
function Image$1(props) {
  const [local, loadEventProps, others] = splitProps(props, ["class", "htmlWidth", "htmlHeight", "fallbackSrc", "fallback", "src", "srcSet", "align", "fit", "loading", "ignoreFallback", "crossOrigin"], ["onError", "onLoad"]);
  const shouldIgnore = () => {
    return local.loading != null || local.ignoreFallback || local.fallbackSrc === void 0 && local.fallback === void 0;
  };
  const status = createMemo(() => createImageLoadingStatus(__spreadProps(__spreadValues({}, props), {
    ignoreFallback: shouldIgnore()
  })));
  const sharedProps = () => __spreadValues(__spreadValues({
    objectFit: local.fit,
    objectPosition: local.align,
    width: local.htmlWidth,
    height: local.htmlHeight
  }, shouldIgnore() ? loadEventProps : {}), others);
  const classes = () => classNames(local.class, hopeImageClass);
  return createComponent(Show, {
    get when() {
      return status()() === "loaded";
    },
    get fallback() {
      return createComponent(Show, {
        get when() {
          return local.fallback;
        },
        get fallback() {
          return createComponent(Box, mergeProps({
            as: "img",
            get src() {
              return local.fallbackSrc;
            },
            "class": "hope-image__placeholder"
          }, sharedProps));
        },
        get children() {
          return local.fallback;
        }
      });
    },
    get children() {
      return createComponent(Box, mergeProps({
        as: "img",
        get src() {
          return local.src;
        },
        get srcSet() {
          return local.srcSet;
        },
        get crossOrigin() {
          return local.crossOrigin;
        },
        get loading() {
          return local.loading;
        },
        get ["class"]() {
          return classes();
        }
      }, sharedProps));
    }
  });
}
Image$1.toString = () => createClassSelector(hopeImageClass);
var InputGroupContext = createContext();
function useInputGroupContext() {
  return useContext(InputGroupContext);
}
var hopeInputGroupClass = "hope-input-group";
function InputGroup(props) {
  const theme = useStyleConfig().Input;
  const [state, setState] = createStore({
    get variant() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.variant) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.variant) != null ? _d : "outline";
    },
    get size() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.size) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.size) != null ? _d : "md";
    },
    hasLeftElement: false,
    hasRightElement: false,
    hasLeftAddon: false,
    hasRightAddon: false
  });
  const [local, others] = splitProps(props, ["variant", "size", "class"]);
  const classes = () => classNames(local.class, hopeInputGroupClass, inputGroupStyles());
  const setHasLeftElement = (value) => setState("hasLeftElement", value);
  const setHasRightElement = (value) => setState("hasRightElement", value);
  const setHasLeftAddon = (value) => setState("hasLeftAddon", value);
  const setHasRightAddon = (value) => setState("hasRightAddon", value);
  const context = {
    state,
    setHasLeftElement,
    setHasRightElement,
    setHasLeftAddon,
    setHasRightAddon
  };
  return createComponent(InputGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.group;
        }
      }, others));
    }
  });
}
InputGroup.toString = () => createClassSelector(hopeInputGroupClass);
var hopeInputClass = "hope-input";
function Input(props) {
  const theme = useStyleConfig().Input;
  const inputGroup = useInputGroupContext();
  const formControlProps = useFormControl(props);
  const [local, others] = splitProps(props, ["class", "htmlSize", "variant", "size"]);
  const classes = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    return classNames(local.class, hopeInputClass, inputStyles({
      variant: (_e = (_d = (_a = local.variant) != null ? _a : inputGroup == null ? void 0 : inputGroup.state.variant) != null ? _d : (_c = (_b = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _b.input) == null ? void 0 : _c.variant) != null ? _e : "outline",
      size: (_j = (_i = (_f = local.size) != null ? _f : inputGroup == null ? void 0 : inputGroup.state.size) != null ? _i : (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.input) == null ? void 0 : _h.size) != null ? _j : "md",
      withLeftElement: (_k = inputGroup == null ? void 0 : inputGroup.state.hasLeftElement) != null ? _k : false,
      withRightElement: (_l = inputGroup == null ? void 0 : inputGroup.state.hasRightElement) != null ? _l : false,
      withLeftAddon: (_m = inputGroup == null ? void 0 : inputGroup.state.hasLeftAddon) != null ? _m : false,
      withRightAddon: (_n = inputGroup == null ? void 0 : inputGroup.state.hasRightAddon) != null ? _n : false
    }));
  };
  return createComponent(hope.input, mergeProps({
    type: "text",
    get ["class"]() {
      return classes();
    },
    get size() {
      return local.htmlSize;
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.input;
    }
  }, formControlProps, others));
}
Input.toString = () => createClassSelector(hopeInputClass);
function InputAddon(props) {
  const theme = useStyleConfig().Input;
  const [local, variantProps, others] = splitProps(props, ["class"], ["placement", "variant", "size"]);
  const classes = () => classNames(local.class, inputAddonStyles(variantProps));
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.addon;
    }
  }, others));
}
var hopeInputLeftAddonClass = "hope-input-left-addon";
function InputLeftAddon(props) {
  const inputGroup = useInputGroupContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeInputLeftAddonClass);
  onMount(() => inputGroup == null ? void 0 : inputGroup.setHasLeftAddon(true));
  onCleanup(() => inputGroup == null ? void 0 : inputGroup.setHasLeftAddon(false));
  return createComponent(InputAddon, mergeProps({
    get ["class"]() {
      return classes();
    },
    placement: "left",
    get variant() {
      var _a;
      return (_a = inputGroup == null ? void 0 : inputGroup.state.variant) != null ? _a : "outline";
    },
    get size() {
      var _a;
      return (_a = inputGroup == null ? void 0 : inputGroup.state.size) != null ? _a : "md";
    }
  }, others));
}
InputLeftAddon.toString = () => createClassSelector(hopeInputLeftAddonClass);
var hopeInputRightAddonClass = "hope-input-right-addon";
function InputRightAddon(props) {
  const inputGroup = useInputGroupContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeInputRightAddonClass);
  onMount(() => inputGroup == null ? void 0 : inputGroup.setHasRightAddon(true));
  onCleanup(() => inputGroup == null ? void 0 : inputGroup.setHasRightAddon(false));
  return createComponent(InputAddon, mergeProps({
    get ["class"]() {
      return classes();
    },
    placement: "right",
    get variant() {
      var _a;
      return (_a = inputGroup == null ? void 0 : inputGroup.state.variant) != null ? _a : "outline";
    },
    get size() {
      var _a;
      return (_a = inputGroup == null ? void 0 : inputGroup.state.size) != null ? _a : "md";
    }
  }, others));
}
InputRightAddon.toString = () => createClassSelector(hopeInputRightAddonClass);
function InputElement(props) {
  const theme = useStyleConfig().Input;
  const [local, variantProps, others] = splitProps(props, ["class"], ["placement", "size"]);
  const classes = () => classNames(local.class, inputElementStyles(variantProps));
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.element;
    }
  }, others));
}
var hopeInputLeftElementClass = "hope-input-left-element";
function InputLeftElement(props) {
  const inputGroup = useInputGroupContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeInputLeftElementClass);
  onMount(() => inputGroup == null ? void 0 : inputGroup.setHasLeftElement(true));
  onCleanup(() => inputGroup == null ? void 0 : inputGroup.setHasLeftElement(false));
  return createComponent(InputElement, mergeProps({
    get ["class"]() {
      return classes();
    },
    placement: "left",
    get size() {
      var _a;
      return (_a = inputGroup == null ? void 0 : inputGroup.state.size) != null ? _a : "md";
    }
  }, others));
}
InputLeftElement.toString = () => createClassSelector(hopeInputLeftElementClass);
var hopeInputRightElementClass = "hope-input-right-element";
function InputRightElement(props) {
  const inputGroup = useInputGroupContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeInputRightElementClass);
  onMount(() => inputGroup == null ? void 0 : inputGroup.setHasRightElement(true));
  onCleanup(() => inputGroup == null ? void 0 : inputGroup.setHasRightElement(false));
  return createComponent(InputElement, mergeProps({
    get ["class"]() {
      return classes();
    },
    placement: "right",
    get size() {
      var _a;
      return (_a = inputGroup == null ? void 0 : inputGroup.state.size) != null ? _a : "md";
    }
  }, others));
}
InputRightElement.toString = () => createClassSelector(hopeInputRightElementClass);
var kbdStyles = css({
  borderRadius: "$md",
  borderColor: "$neutral7",
  borderWidth: "1px",
  borderBottomWidth: "3px",
  backgroundColor: "$neutral2",
  px: "0.4em",
  fontFamily: "$mono",
  fontSize: "0.8em",
  fontWeight: "$bold",
  lineHeight: "$normal",
  whiteSpace: "nowrap"
});
var hopeKbdClass = "hope-kbd";
function Kbd(props) {
  const theme = useStyleConfig().Kbd;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeKbdClass, kbdStyles());
  return createComponent(hope.kbd, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      return theme == null ? void 0 : theme.baseStyle;
    }
  }, others));
}
Kbd.toString = () => createClassSelector(hopeKbdClass);
var listStyles = css({
  listStyleType: "none"
});
var listIconStyles = css({
  marginEnd: "0.5rem"
});
var hopeListClass = "hope-list";
var descendentSelector = "& > *:not(style) ~ *:not(style)";
function List(props) {
  const [local, others] = splitProps(props, ["class", "styleType", "stylePosition", "spacing"]);
  const spacingStyle = () => local.spacing ? {
    [descendentSelector]: {
      mt: local.spacing
    }
  } : {};
  const classes = () => {
    return classNames(local.class, hopeListClass, listStyles({
      css: __spreadValues({
        listStyleType: local.styleType,
        listStylePosition: local.stylePosition
      }, spacingStyle())
    }));
  };
  return createComponent(hope.ul, mergeProps({
    role: "list",
    get ["class"]() {
      return classes();
    }
  }, others));
}
List.toString = () => createClassSelector(hopeListClass);
var hopeOrderedListClass = "hope-ordered-list";
function OrderedList(props) {
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeOrderedListClass);
  return createComponent(List, mergeProps({
    as: "ol",
    get ["class"]() {
      return classes();
    },
    styleType: "decimal",
    marginStart: "1em"
  }, others));
}
OrderedList.toString = () => createClassSelector(hopeOrderedListClass);
var hopeUnorderedListClass = "hope-unordered-list";
function UnorderedList(props) {
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeUnorderedListClass);
  return createComponent(List, mergeProps({
    as: "ul",
    get ["class"]() {
      return classes();
    },
    styleType: "initial",
    marginStart: "1em"
  }, others));
}
UnorderedList.toString = () => createClassSelector(hopeUnorderedListClass);
var hopeListIconClass = "hope-list__icon";
function ListIcon(props) {
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeListIconClass, listIconStyles());
  return createComponent(Icon, mergeProps({
    role: "presentation",
    get ["class"]() {
      return classes();
    },
    verticalAlign: "text-bottom"
  }, others));
}
ListIcon.toString = () => createClassSelector(hopeListIconClass);
var hopeListItemClass = "hope-list__item";
function ListItem(props) {
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeListItemClass);
  return createComponent(hope.li, mergeProps({
    get ["class"]() {
      return classes();
    }
  }, others));
}
ListItem.toString = () => createClassSelector(hopeListItemClass);
var MenuActions = ((MenuActions2) => {
  MenuActions2[MenuActions2["Close"] = 0] = "Close";
  MenuActions2[MenuActions2["SelectAndClose"] = 1] = "SelectAndClose";
  MenuActions2[MenuActions2["First"] = 2] = "First";
  MenuActions2[MenuActions2["Last"] = 3] = "Last";
  MenuActions2[MenuActions2["Next"] = 4] = "Next";
  MenuActions2[MenuActions2["Open"] = 5] = "Open";
  MenuActions2[MenuActions2["OpenAndFocusLast"] = 6] = "OpenAndFocusLast";
  MenuActions2[MenuActions2["Previous"] = 7] = "Previous";
  MenuActions2[MenuActions2["Select"] = 8] = "Select";
  MenuActions2[MenuActions2["Type"] = 9] = "Type";
  return MenuActions2;
})(MenuActions || {});
function filterItems(items = [], filter, exclude = []) {
  return items.filter((item) => {
    if (item.disabled) {
      return false;
    }
    const matches2 = item.textValue.toLowerCase().indexOf(filter.toLowerCase()) === 0;
    return matches2 && exclude.indexOf(item.textValue) < 0;
  });
}
function getIndexByLetter$1(items, filter, startIndex = 0) {
  const orderedItems = [...items.slice(startIndex), ...items.slice(0, startIndex)];
  const firstMatch = filterItems(orderedItems, filter)[0];
  const allSameLetter = (array) => array.every((letter) => letter === array[0]);
  if (firstMatch) {
    return items.indexOf(firstMatch);
  } else if (allSameLetter(filter.split(""))) {
    const matches2 = filterItems(orderedItems, filter[0]);
    return items.indexOf(matches2[0]);
  } else {
    return -1;
  }
}
function getActionFromKey$1(event, menuOpen) {
  const { key, altKey, ctrlKey, metaKey } = event;
  const openKeys = ["ArrowDown", "Enter", " "];
  if (!menuOpen && openKeys.includes(key)) {
    return 5;
  }
  if (!menuOpen && key === "ArrowUp") {
    return 6;
  }
  if (key === "Home") {
    return 2;
  }
  if (key === "End") {
    return 3;
  }
  if (key === "Backspace" || key === "Clear" || key.length === 1 && key !== " " && !altKey && !ctrlKey && !metaKey) {
    return 9;
  }
  if (menuOpen) {
    if (key === "ArrowDown") {
      return 4;
    } else if (key === "ArrowUp") {
      return 7;
    } else if (key === "Escape") {
      return 0;
    } else if (key === "Enter" || key === " ") {
      return 1;
    }
  }
}
function calculateActiveIndex$1(currentIndex, maxIndex, action) {
  switch (action) {
    case 2:
      return 0;
    case 3:
      return maxIndex;
    case 7:
      return currentIndex - 1 < 0 ? maxIndex : currentIndex - 1;
    case 4:
      return currentIndex + 1 > maxIndex ? 0 : currentIndex + 1;
    default:
      return currentIndex;
  }
}
function getUpdatedIndex$1(params) {
  const { currentIndex, maxIndex, initialAction, isItemDisabled } = params;
  let nextIndex = calculateActiveIndex$1(currentIndex, maxIndex, initialAction);
  while (isItemDisabled(nextIndex)) {
    let nextAction = initialAction;
    const isNextIndexFirst = nextIndex === 0;
    const isNextIndexLast = nextIndex === maxIndex;
    if (initialAction === 2) {
      nextAction = 4;
    }
    if (initialAction === 3) {
      nextAction = 7;
    }
    if (initialAction === 7 && isNextIndexFirst) {
      nextIndex = currentIndex;
      break;
    }
    if (initialAction === 4 && isNextIndexLast) {
      nextIndex = currentIndex;
      break;
    }
    nextIndex = calculateActiveIndex$1(nextIndex, maxIndex, nextAction);
  }
  return nextIndex;
}
function Menu(props) {
  const defaultBaseId = `hope-menu-${createUniqueId()}`;
  const theme = useStyleConfig().Menu;
  const [_items, _setItems] = createSignal([]);
  const [state, setState] = createStore({
    get triggerId() {
      var _a;
      return (_a = props.id) != null ? _a : `${defaultBaseId}-trigger`;
    },
    get menuContentId() {
      return `${defaultBaseId}-content`;
    },
    get labelIdPrefix() {
      return `${defaultBaseId}-label`;
    },
    get itemIdPrefix() {
      return `${defaultBaseId}-item`;
    },
    get activeDescendantId() {
      return this.opened ? `${this.itemIdPrefix}-${this.activeIndex}` : void 0;
    },
    get closeOnSelect() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.closeOnSelect) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.closeOnSelect) != null ? _d : true;
    },
    get motionPreset() {
      var _a, _b, _c, _d, _e;
      if (props.motionPreset) {
        return props.motionPreset;
      }
      if ((_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.motionPreset) {
        return (_d = (_c = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _c.root) == null ? void 0 : _d.motionPreset;
      }
      if ((_e = props.placement) == null ? void 0 : _e.startsWith("top")) {
        return "scale-bottom-left";
      }
      return "scale-top-left";
    },
    get items() {
      return _items();
    },
    opened: false,
    activeIndex: 0,
    ignoreBlur: false,
    searchString: "",
    searchTimeoutId: void 0
  });
  let triggerRef;
  let contentRef;
  let cleanupContentAutoUpdate;
  const updateContentPosition = async () => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!triggerRef || !contentRef) {
      return;
    }
    const {
      x: x2,
      y: y2
    } = await computePosition2(triggerRef, contentRef, {
      placement: (_d = (_c = props.placement) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.placement) != null ? _d : "bottom-start",
      middleware: [offset((_h = (_g = props.offset) != null ? _g : (_f = (_e = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _e.root) == null ? void 0 : _f.offset) != null ? _h : 5), flip(), shift()]
    });
    if (!contentRef) {
      return;
    }
    Object.assign(contentRef.style, {
      left: `${Math.round(x2)}px`,
      top: `${Math.round(y2)}px`
    });
  };
  const getSearchString = (char) => {
    if (state.searchTimeoutId) {
      window.clearTimeout(state.searchTimeoutId);
    }
    const searchTimeoutId = window.setTimeout(() => {
      setState("searchString", "");
    }, 500);
    setState("searchTimeoutId", searchTimeoutId);
    setState("searchString", (searchString) => searchString += char);
    return state.searchString;
  };
  const onItemChange = (index) => {
    setState("activeIndex", index);
  };
  const isItemDisabledCallback = (index) => {
    return state.items[index].disabled;
  };
  const selectItem = (index) => {
    var _a;
    onItemChange(index);
    const menuItem = state.items[index];
    (_a = menuItem.onSelect) == null ? void 0 : _a.call(menuItem);
    if (menuItem.closeOnSelect) {
      updateOpeningState(false);
    } else {
      focusTrigger();
    }
  };
  const focusTrigger = () => {
    triggerRef == null ? void 0 : triggerRef.focus();
  };
  const onTriggerBlur = (event) => {
    if (contains2(triggerRef, getRelatedTarget(event))) {
      return;
    }
    if (state.ignoreBlur) {
      setState("ignoreBlur", false);
      return;
    }
    if (state.opened) {
      updateOpeningState(false, false);
    }
  };
  const onTriggerClick = () => {
    updateOpeningState(!state.opened, false);
  };
  const onTriggerKeyDown = (event) => {
    const {
      key
    } = event;
    const max3 = state.items.length - 1;
    const action = getActionFromKey$1(event, state.opened);
    switch (action) {
      case MenuActions.Last:
      case MenuActions.First:
      case MenuActions.Next:
      case MenuActions.Previous:
        event.preventDefault();
        return onItemChange(getUpdatedIndex$1({
          currentIndex: state.activeIndex,
          maxIndex: max3,
          initialAction: action,
          isItemDisabled: isItemDisabledCallback
        }));
      case MenuActions.SelectAndClose:
        event.preventDefault();
        selectItem(state.activeIndex);
        return;
      case MenuActions.Close:
        event.preventDefault();
        return updateOpeningState(false);
      case MenuActions.Type:
        return onTriggerType(key);
      case MenuActions.Open:
        event.preventDefault();
        return updateOpeningState(true);
      case MenuActions.OpenAndFocusLast:
        event.preventDefault();
        return updateOpeningState(true, true, true);
    }
  };
  const onTriggerType = (letter) => {
    updateOpeningState(true);
    const searchString = getSearchString(letter);
    const searchIndex = getIndexByLetter$1(state.items, searchString, state.activeIndex + 1);
    if (searchIndex >= 0) {
      onItemChange(searchIndex);
    } else {
      window.clearTimeout(state.searchTimeoutId);
      setState("searchString", "");
    }
  };
  const onItemClick = (index) => {
    if (state.items[index].disabled) {
      focusTrigger();
      return;
    }
    selectItem(index);
  };
  const onItemMouseMove = (index) => {
    if (state.activeIndex === index) {
      return;
    }
    onItemChange(index);
  };
  const onItemMouseDown = () => {
    setState("ignoreBlur", true);
  };
  const scheduleContentPositionAutoUpdate = () => {
    if (state.opened) {
      updateContentPosition();
      if (triggerRef && contentRef) {
        cleanupContentAutoUpdate = autoUpdate(triggerRef, contentRef, updateContentPosition);
      }
    } else {
      cleanupContentAutoUpdate == null ? void 0 : cleanupContentAutoUpdate();
    }
  };
  const updateOpeningState = (opened, callFocus = true, lastItemActive = false) => {
    if (state.opened === opened) {
      return;
    }
    setState("opened", opened);
    setState("activeIndex", lastItemActive ? state.items.length - 1 : 0);
    scheduleContentPositionAutoUpdate();
    callFocus && focusTrigger();
  };
  const onContentMouseLeave = () => {
    onItemChange(-1);
  };
  const onContentClickOutside = (target) => {
    if (contains2(triggerRef, target)) {
      return;
    }
    updateOpeningState(false, false);
  };
  const isItemActiveDescendant = (index) => {
    return index === state.activeIndex;
  };
  const assignTriggerRef = (el) => {
    triggerRef = el;
  };
  const assignContentRef = (el) => {
    contentRef = el;
  };
  const scrollToItem = (optionRef) => {
    if (!contentRef) {
      return;
    }
    if (isScrollable(contentRef)) {
      maintainScrollVisibility(optionRef, contentRef);
    }
  };
  const registerItem = (itemData) => {
    const index = state.items.findIndex((item) => item.key === itemData.key);
    if (index != -1) {
      return index;
    }
    const updatedItems = _setItems((prev) => [...prev, itemData]);
    return updatedItems.length - 1;
  };
  const openedAccessor = () => state.opened;
  const context = {
    state,
    isItemActiveDescendant,
    assignTriggerRef,
    assignContentRef,
    registerItem,
    scrollToItem,
    onTriggerBlur,
    onTriggerClick,
    onTriggerKeyDown,
    onContentMouseLeave,
    onContentClickOutside,
    onItemClick,
    onItemMouseMove,
    onItemMouseDown
  };
  return createComponent(MenuContext.Provider, {
    value: context,
    get children() {
      return createComponent(Show, {
        get when() {
          return isChildrenFunction(props);
        },
        get fallback() {
          return props.children;
        },
        get children() {
          var _a;
          return (_a = props.children) == null ? void 0 : _a.call(props, {
            opened: openedAccessor
          });
        }
      });
    }
  });
}
var MenuContext = createContext();
function useMenuContext() {
  const context = useContext(MenuContext);
  if (!context) {
    throw new Error("[Hope UI]: useMenuContext must be used within a `<Menu />` component");
  }
  return context;
}
function useClickOutside(props) {
  const [state, setState] = createStore({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  const onPointerDown = (e) => {
    if (isValidEvent(e, props.element())) {
      setState("isPointerDown", true);
    }
  };
  const onMouseUp = (event) => {
    if (state.ignoreEmulatedMouseEvents) {
      setState("ignoreEmulatedMouseEvents", false);
      return;
    }
    if (state.isPointerDown && props.handler && isValidEvent(event, props.element())) {
      setState("isPointerDown", false);
      props.handler(event);
    }
  };
  const onTouchEnd = (event) => {
    setState("ignoreEmulatedMouseEvents", true);
    if (props.handler && state.isPointerDown && isValidEvent(event, props.element())) {
      setState("isPointerDown", false);
      props.handler(event);
    }
  };
  onMount(() => {
    const doc = getOwnerDocument(props.element());
    doc.addEventListener("mousedown", onPointerDown, true);
    doc.addEventListener("mouseup", onMouseUp, true);
    doc.addEventListener("touchstart", onPointerDown, true);
    doc.addEventListener("touchend", onTouchEnd, true);
  });
  onCleanup(() => {
    const doc = getOwnerDocument(props.element());
    doc.removeEventListener("mousedown", onPointerDown, true);
    doc.removeEventListener("mouseup", onMouseUp, true);
    doc.removeEventListener("touchstart", onPointerDown, true);
    doc.removeEventListener("touchend", onTouchEnd, true);
  });
}
function ClickOutside(props) {
  const resolvedChildren = children(() => props.children);
  useClickOutside({
    element: () => resolvedChildren(),
    handler: (event) => props.onClickOutside(event)
  });
  return resolvedChildren;
}
var hopeMenuContentClass = "hope-menu__content";
function MenuContent(props) {
  const theme = useStyleConfig().Menu;
  const menuContext = useMenuContext();
  const [local, others] = splitProps(props, ["ref", "class", "children"]);
  const [isPortalMounted, setIsPortalMounted] = createSignal(false);
  createEffect(on(() => menuContext.state.opened, () => {
    if (menuContext.state.opened) {
      setIsPortalMounted(true);
    } else {
      menuContext.state.motionPreset === "none" && setIsPortalMounted(false);
    }
  }));
  const unmountPortal = () => setIsPortalMounted(false);
  const resolvedChildren = children(() => local.children);
  const assignContentRef = (el) => {
    menuContext.assignContentRef(el);
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const onClickOutside = (event) => {
    menuContext.onContentClickOutside(event.target);
  };
  const classes = () => classNames(local.class, hopeMenuContentClass, menuContentStyles());
  const transitionName = () => {
    switch (menuContext.state.motionPreset) {
      case "scale-top-left":
        return menuTransitionName.scaleTopLeft;
      case "scale-top-right":
        return menuTransitionName.scaleTopRight;
      case "scale-bottom-left":
        return menuTransitionName.scaleBottomLeft;
      case "scale-bottom-right":
        return menuTransitionName.scaleBottomRight;
      case "none":
        return "hope-none";
    }
  };
  return createComponent(Show, {
    get when() {
      return isPortalMounted();
    },
    get children() {
      return createComponent(Portal, {
        get children() {
          return createComponent(Transition, {
            get name() {
              return transitionName();
            },
            appear: true,
            onAfterExit: unmountPortal,
            get children() {
              return createComponent(Show, {
                get when() {
                  return menuContext.state.opened;
                },
                get children() {
                  return createComponent(ClickOutside, {
                    onClickOutside,
                    get children() {
                      return createComponent(Box, mergeProps({
                        role: "menu",
                        tabindex: "-1",
                        ref: assignContentRef,
                        get id() {
                          return menuContext.state.menuContentId;
                        },
                        get ["aria-activedescendant"]() {
                          return menuContext.state.activeDescendantId;
                        },
                        get ["aria-labelledby"]() {
                          return menuContext.state.triggerId;
                        },
                        "aria-orientation": "vertical",
                        get ["class"]() {
                          return classes();
                        },
                        get __baseStyle() {
                          var _a;
                          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.content;
                        },
                        get onMouseLeave() {
                          return menuContext.onContentMouseLeave;
                        }
                      }, others, {
                        get children() {
                          return resolvedChildren();
                        }
                      }));
                    }
                  });
                }
              });
            }
          });
        }
      });
    }
  });
}
MenuContent.toString = () => createClassSelector(hopeMenuContentClass);
var MenuGroupContext = createContext();
var hopeMenuGroupClass = "hope-menu__group";
function MenuGroup(props) {
  const theme = useStyleConfig().Menu;
  const [ariaLabelledBy, setAriaLabelledBy] = createSignal();
  const [local, others] = splitProps(props, ["class", "children"]);
  const classes = () => classNames(local.class, hopeMenuGroupClass, menuGroupStyles());
  const context = {
    setAriaLabelledBy
  };
  return createComponent(MenuGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        role: "group",
        get ["aria-labelledby"]() {
          return ariaLabelledBy();
        },
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.group;
        }
      }, others, {
        get children() {
          return local.children;
        }
      }));
    }
  });
}
MenuGroup.toString = () => createClassSelector(hopeMenuGroupClass);
function useMenuGroupContext() {
  return useContext(MenuGroupContext);
}
var hopeMenuItemClass = "hope-menu__item";
var hopeMenuItemIconWrapperClass = "hope-menu__item__icon-wrapper";
var hopeMenuItemTextClass = "hope-menu__item__text";
var hopeMenuItemCommandClass = "hope-menu__item__command";
function MenuItem(props) {
  const key = createUniqueId();
  const theme = useStyleConfig().Menu;
  const menuContext = useMenuContext();
  const [index, setIndex] = createSignal(-1);
  let itemRef;
  const [local, others] = splitProps(props, ["ref", "class", "children", "colorScheme", "icon", "iconSpacing", "command", "commandSpacing", "textValue", "disabled", "closeOnSelect", "onSelect", "onClick"]);
  const itemData = () => {
    var _a, _b;
    return {
      key,
      textValue: (_b = (_a = local.textValue) != null ? _a : itemRef == null ? void 0 : itemRef.textContent) != null ? _b : "",
      disabled: !!local.disabled,
      closeOnSelect: local.closeOnSelect != null ? !!local.closeOnSelect : menuContext.state.closeOnSelect,
      onSelect: local.onSelect
    };
  };
  const id = () => `${menuContext.state.itemIdPrefix}-${index()}`;
  const isActiveDescendant = () => menuContext.isItemActiveDescendant(index());
  const assignItemRef = (el) => {
    itemRef = el;
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const onItemClick = (event) => {
    event.stopPropagation();
    menuContext.onItemClick(index());
  };
  const onItemMouseMove = (event) => {
    if (local.disabled) {
      menuContext.onItemMouseMove(-1);
    }
    if (isActiveDescendant() || local.disabled) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    menuContext.onItemMouseMove(index());
  };
  const classes = () => {
    return classNames(local.class, hopeMenuItemClass, menuItemStyles({
      colorScheme: local.colorScheme
    }));
  };
  const iconWrapperClasses = () => {
    return classNames(hopeMenuItemIconWrapperClass, menuItemIconWrapperStyles());
  };
  const textClasses = () => {
    return classNames(hopeMenuItemTextClass, menuItemTextStyles());
  };
  const commandClasses = () => {
    return classNames(hopeMenuItemCommandClass, menuItemCommandStyles());
  };
  onMount(() => {
    setIndex(menuContext.registerItem(itemData()));
  });
  createEffect(() => {
    if (isActiveDescendant() && itemRef) {
      menuContext.scrollToItem(itemRef);
    }
  });
  return createComponent(Box, mergeProps({
    ref: assignItemRef,
    role: "menuitem",
    get id() {
      return id();
    },
    get ["data-active"]() {
      return isActiveDescendant() ? "" : void 0;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : void 0;
    },
    "data-group": true,
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.item;
    },
    onClick: onItemClick,
    onMouseMove: onItemMouseMove,
    get onMouseDown() {
      return menuContext.onItemMouseDown;
    }
  }, others, {
    get children() {
      return [createComponent(Show, {
        get when() {
          return local.icon;
        },
        get children() {
          return createComponent(hope.span, {
            "aria-hidden": "true",
            get ["class"]() {
              return iconWrapperClasses();
            },
            get __baseStyle() {
              var _a;
              return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.itemIconWrapper;
            },
            get mr() {
              var _a;
              return (_a = local.iconSpacing) != null ? _a : "0.5rem";
            },
            get children() {
              return local.icon;
            }
          });
        }
      }), createComponent(Show, {
        get when() {
          return local.children;
        },
        get children() {
          return createComponent(hope.span, {
            get ["class"]() {
              return textClasses();
            },
            get __baseStyle() {
              var _a;
              return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.itemText;
            },
            get children() {
              return local.children;
            }
          });
        }
      }), createComponent(Show, {
        get when() {
          return local.command;
        },
        get children() {
          return createComponent(hope.span, {
            get ["class"]() {
              return commandClasses();
            },
            get __baseStyle() {
              var _a;
              return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.itemCommand;
            },
            get ml() {
              var _a;
              return (_a = local.commandSpacing) != null ? _a : "0.5rem";
            },
            get children() {
              return local.command;
            }
          });
        }
      })];
    }
  }));
}
MenuItem.toString = () => createClassSelector(hopeMenuItemClass);
var hopeMenuLabelClass = "hope-menu__label";
function MenuLabel(props) {
  const defaultIdSuffix = createUniqueId();
  const theme = useStyleConfig().Menu;
  const menuContext = useMenuContext();
  const menuGroupContext = useMenuGroupContext();
  const [local, others] = splitProps(props, ["class", "id"]);
  const id = () => {
    var _a;
    return (_a = local.id) != null ? _a : `${menuContext.state.labelIdPrefix}-${defaultIdSuffix}`;
  };
  const classes = () => classNames(local.class, hopeMenuLabelClass, menuLabelStyles());
  onMount(() => {
    menuGroupContext == null ? void 0 : menuGroupContext.setAriaLabelledBy(id());
  });
  return createComponent(Box, mergeProps({
    get id() {
      return id();
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.label;
    }
  }, others));
}
MenuLabel.toString = () => createClassSelector(hopeMenuLabelClass);
var hopeMenuTriggerClass = "hope-menu__trigger";
function MenuTrigger(props) {
  const theme = useStyleConfig().Menu;
  const menuContext = useMenuContext();
  const [local, others] = splitProps(props, ["ref", "class", "onClick", "onKeyDown", "onBlur"]);
  const assignTriggerRef = (el) => {
    menuContext.assignTriggerRef(el);
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const onClick = (event) => {
    chainHandlers(menuContext.onTriggerClick, local.onClick)(event);
  };
  const onKeyDown = (event) => {
    chainHandlers(menuContext.onTriggerKeyDown, local.onKeyDown)(event);
  };
  const onBlur = (event) => {
    chainHandlers(menuContext.onTriggerBlur, local.onBlur)(event);
  };
  const classes = () => classNames(local.class, hopeMenuTriggerClass, menuTriggerStyles());
  return createComponent(hope.button, mergeProps({
    ref: assignTriggerRef,
    get id() {
      return menuContext.state.triggerId;
    },
    type: "button",
    "aria-haspopup": "menu",
    get ["aria-controls"]() {
      return menuContext.state.menuContentId;
    },
    get ["aria-expanded"]() {
      return menuContext.state.opened;
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.trigger;
    },
    onClick,
    onKeyDown,
    onBlur
  }, others));
}
MenuTrigger.toString = () => createClassSelector(hopeMenuTriggerClass);
var hopeNotificationClass = "hope-notification";
function Notification(props) {
  const theme = useStyleConfig().Notification;
  const defaultProps = {};
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "status"]);
  const classes = () => {
    return classNames(local.class, hopeNotificationClass, notificationStyles({
      status: local.status
    }));
  };
  const statusAccessor = () => local.status;
  const context = {
    status: statusAccessor
  };
  return createComponent(NotificationContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        role: "alert",
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.root;
        }
      }, others));
    }
  });
}
Notification.toString = () => createClassSelector(hopeNotificationClass);
var NotificationContext = createContext();
function useNotificationContext() {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error("[Hope UI]: useNotificationContext must be used within an `<Notification />` component");
  }
  return context;
}
var NOTIFICATIONS_EVENTS = {
  show: "hope-ui:show-notification",
  update: "hope-ui:update-notification",
  hide: "hope-ui:hide-notification",
  clear: "hope-ui:clear-notifications",
  clearQueue: "hope-ui:clear-notifications-queue"
};
function createEvent(type, detail) {
  return new CustomEvent(type, { detail });
}
function show(config2) {
  window.dispatchEvent(createEvent(NOTIFICATIONS_EVENTS.show, config2));
}
function update(config2) {
  window.dispatchEvent(createEvent(NOTIFICATIONS_EVENTS.update, config2));
}
function hide2(id) {
  window.dispatchEvent(createEvent(NOTIFICATIONS_EVENTS.hide, id));
}
function clear() {
  window.dispatchEvent(createEvent(NOTIFICATIONS_EVENTS.clear));
}
function clearQueue() {
  window.dispatchEvent(createEvent(NOTIFICATIONS_EVENTS.clearQueue));
}
var notificationService = {
  show,
  update,
  hide: hide2,
  clear,
  clearQueue
};
var hopeNotificationDescriptionClass = "hope-notification__description";
function NotificationDescription(props) {
  const theme = useStyleConfig().Notification;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeNotificationDescriptionClass, notificationDescriptionStyles());
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.description;
    }
  }, others));
}
NotificationDescription.toString = () => createClassSelector(hopeNotificationDescriptionClass);
var hopeNotificationIconClass = "hope-notification__icon";
function NotificationIcon(props) {
  const theme = useStyleConfig().Notification;
  const {
    status
  } = useNotificationContext();
  const defaultProps = {
    boxSize: "$7"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["as", "class"]);
  const classes = () => {
    return classNames(local.class, hopeNotificationIconClass, notificationIconStyles({
      status: status()
    }));
  };
  const icon = () => {
    if (local.as) {
      return local.as;
    }
    switch (status()) {
      case "success":
        return IconCheckCircleSolid;
      case "info":
        return IconInfoCircleSolid;
      case "warning":
        return IconExclamationTriangleSolid;
      case "danger":
        return IconExclamationCircleSolid;
    }
  };
  return createComponent(Icon, mergeProps({
    get as() {
      return icon();
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.icon;
    }
  }, others));
}
NotificationIcon.toString = () => createClassSelector(hopeNotificationIconClass);
var hopeNotificationTitleClass = "hope-notification__title";
function NotificationTitle(props) {
  const theme = useStyleConfig().Notification;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeNotificationTitleClass, notificationTitleStyles());
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.title;
    }
  }, others));
}
NotificationTitle.toString = () => createClassSelector(hopeNotificationTitleClass);
function createQueue(props) {
  var _a, _b, _c, _d;
  const [currentState, setCurrentState] = createSignal((_b = (_a = props.initialValues) == null ? void 0 : _a.slice(0, props.limit)) != null ? _b : []);
  const [queue, setQueue] = createSignal((_d = (_c = props.initialValues) == null ? void 0 : _c.slice(props.limit)) != null ? _d : []);
  const limit = () => props.limit;
  const add = (...items) => {
    const results = [...currentState(), ...queue(), ...items];
    setCurrentState(results.slice(0, limit()));
    setQueue(results.slice(limit()));
  };
  const update2 = (fn) => {
    const results = fn([...currentState(), ...queue()]);
    setCurrentState(results.slice(0, limit()));
    setQueue(results.slice(limit()));
  };
  const clearQueue2 = () => {
    setQueue([]);
  };
  const state = {
    current: currentState,
    queue,
    limit
  };
  return {
    state,
    add,
    update: update2,
    clearQueue: clearQueue2
  };
}
var stackStyles = css({
  display: "flex"
});
var hopeStackClass = "hope-stack";
function Stack(props) {
  const [local, others] = splitProps(props, ["class", "direction", "wrap", "spacing"]);
  const classes = () => classNames(local.class, hopeStackClass, stackStyles());
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get flexDirection() {
      return local.direction;
    },
    get flexWrap() {
      return local.wrap;
    },
    get gap() {
      return local.spacing;
    }
  }, others));
}
Stack.toString = () => createClassSelector(hopeStackClass);
function HStack(props) {
  const [local, others] = splitProps(props, ["spacing"]);
  return createComponent(Stack, mergeProps({
    direction: "row",
    alignItems: "center",
    get columnGap() {
      return local.spacing;
    }
  }, others));
}
HStack.toString = () => createClassSelector(hopeStackClass);
function VStack(props) {
  const [local, others] = splitProps(props, ["spacing"]);
  return createComponent(Stack, mergeProps({
    direction: "column",
    alignItems: "center",
    get rowGap() {
      return local.spacing;
    }
  }, others));
}
VStack.toString = () => createClassSelector(hopeStackClass);
var NotificationsProviderContext = createContext();
function useNotificationsProviderContext() {
  const context = useContext(NotificationsProviderContext);
  if (!context) {
    throw new Error("[Hope UI]: useNotificationsProviderContext must be used within a `<NotificationsProvider />` component");
  }
  return context;
}
function NotificationContainer(props) {
  const notificationsProviderContext = useNotificationsProviderContext();
  const [local] = splitProps(props, ["render", "id", "status", "title", "description", "duration", "persistent", "closable", "loading", "onMouseEnter", "onMouseLeave"]);
  let closeDelayId;
  const clearCloseDelay = () => {
    if (closeDelayId) {
      window.clearTimeout(closeDelayId);
    }
  };
  const closeNotification = () => {
    clearCloseDelay();
    notificationsProviderContext.hideNotification(local.id);
  };
  const closeWithDelay = () => {
    if (local.persistent || local.duration == null) {
      return;
    }
    closeDelayId = window.setTimeout(closeNotification, local.duration);
  };
  const showIcon = () => {
    return local.status && !local.loading;
  };
  onMount(() => {
    closeWithDelay();
  });
  onCleanup(() => {
    clearCloseDelay();
  });
  return createComponent(Show, {
    get when() {
      return local.render;
    },
    get fallback() {
      return createComponent(Notification, {
        get status() {
          return local.status;
        },
        get pr() {
          return local.closable ? "$9" : "$3";
        },
        onMouseEnter: clearCloseDelay,
        onMouseLeave: closeWithDelay,
        get children() {
          return [createComponent(Show, {
            get when() {
              return showIcon();
            },
            get children() {
              return createComponent(NotificationIcon, {
                mr: "$2_5"
              });
            }
          }), createComponent(Show, {
            get when() {
              return local.loading;
            },
            get children() {
              return createComponent(IconSpinner, {
                color: "$primary10",
                boxSize: "$8",
                mr: "$2_5",
                get ["class"]() {
                  return notificationLoaderStyles();
                }
              });
            }
          }), createComponent(Switch, {
            get children() {
              return [createComponent(Match, {
                get when() {
                  return local.title && local.description;
                },
                get children() {
                  return createComponent(VStack, {
                    alignItems: "flex-start",
                    spacing: "$1",
                    get children() {
                      return [createComponent(NotificationTitle, {
                        get children() {
                          return local.title;
                        }
                      }), createComponent(NotificationDescription, {
                        get children() {
                          return local.description;
                        }
                      })];
                    }
                  });
                }
              }), createComponent(Match, {
                get when() {
                  return local.title;
                },
                get children() {
                  return createComponent(NotificationTitle, {
                    get children() {
                      return local.title;
                    }
                  });
                }
              }), createComponent(Match, {
                get when() {
                  return local.description;
                },
                get children() {
                  return createComponent(NotificationDescription, {
                    get children() {
                      return local.description;
                    }
                  });
                }
              })];
            }
          }), createComponent(Show, {
            get when() {
              return local.closable;
            },
            get children() {
              return createComponent(CloseButton, {
                size: "sm",
                position: "absolute",
                top: "$1_5",
                right: "$1_5",
                onClick: closeNotification
              });
            }
          })];
        }
      });
    },
    get children() {
      return createComponent(Flex, {
        w: "$full",
        justifyContent: "flex-end",
        onMouseEnter: clearCloseDelay,
        onMouseLeave: closeWithDelay,
        get children() {
          var _a;
          return (_a = local.render) == null ? void 0 : _a.call(local, {
            id: local.id,
            close: closeNotification
          });
        }
      });
    }
  });
}
var hopeNotificationListClass = "hope-notification__list";
var DEFAULT_NOTIFICATION_DURATION = 5e3;
function NotificationsProvider(props) {
  const [local] = splitProps(props, ["children", "placement", "duration", "persistent", "closable", "limit", "zIndex"]);
  const notificationQueue = createMemo(() => {
    var _a;
    return createQueue({
      initialValues: [],
      limit: (_a = local.limit) != null ? _a : 10
    });
  });
  const finalPlacement = () => {
    var _a;
    return (_a = local.placement) != null ? _a : "top-end";
  };
  const notificationsAccessor = () => notificationQueue().state.current();
  const queueAccessor = () => notificationQueue().state.queue();
  const showNotification = (notification) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const id = (_a = notification.id) != null ? _a : `hope-notification-${createUniqueId()}`;
    const persistent = (_c = (_b = notification.persistent) != null ? _b : local.persistent) != null ? _c : false;
    const duration = (_e = (_d = notification.duration) != null ? _d : local.duration) != null ? _e : DEFAULT_NOTIFICATION_DURATION;
    const closable = (_g = (_f = notification.closable) != null ? _f : local.closable) != null ? _g : true;
    notificationQueue().update((notifications) => {
      if (notification.id && notifications.some((n2) => n2.id === notification.id)) {
        return notifications;
      }
      const newNotification = __spreadProps(__spreadValues({}, notification), {
        id,
        persistent,
        duration,
        closable
      });
      return [...notifications, newNotification];
    });
    return id;
  };
  const updateNotification = (id, notification) => {
    notificationQueue().update((notifications) => {
      const index = notifications.findIndex((n2) => n2.id === id);
      if (index === -1) {
        return notifications;
      }
      const newNotifications = [...notifications];
      newNotifications[index] = notification;
      return newNotifications;
    });
  };
  const hideNotification = (id) => {
    notificationQueue().update((notifications) => {
      return notifications.filter((notification) => {
        var _a;
        if (notification.id === id) {
          (_a = notification.onClose) == null ? void 0 : _a.call(notification, notification.id);
          return false;
        }
        return true;
      });
    });
  };
  const clear2 = () => notificationQueue().update(() => []);
  const clearQueue2 = () => notificationQueue().clearQueue();
  const classes = () => {
    return classNames(hopeNotificationListClass, notificationListStyles({
      placement: finalPlacement()
    }));
  };
  const transitionName = () => {
    switch (finalPlacement()) {
      case "top-start":
        return notificationTransitionName.slideInLeft;
      case "top":
        return notificationTransitionName.slideInTop;
      case "top-end":
        return notificationTransitionName.slideInRight;
      case "bottom-start":
        return notificationTransitionName.slideInLeft;
      case "bottom":
        return notificationTransitionName.slideInBottom;
      case "bottom-end":
        return notificationTransitionName.slideInRight;
      default:
        return notificationTransitionName.slideInRight;
    }
  };
  const context = {
    notifications: notificationsAccessor,
    queue: queueAccessor,
    showNotification,
    updateNotification,
    hideNotification,
    clear: clear2,
    clearQueue: clearQueue2
  };
  const showHandler = (event) => showNotification(event.detail);
  const updateHandler = (event) => updateNotification(event.detail.id, event.detail);
  const hideHandler = (event) => hideNotification(event.detail);
  onMount(() => {
    window.addEventListener(NOTIFICATIONS_EVENTS.show, showHandler);
    window.addEventListener(NOTIFICATIONS_EVENTS.update, updateHandler);
    window.addEventListener(NOTIFICATIONS_EVENTS.hide, hideHandler);
    window.addEventListener(NOTIFICATIONS_EVENTS.clear, clear2);
    window.addEventListener(NOTIFICATIONS_EVENTS.clearQueue, clearQueue2);
  });
  onCleanup(() => {
    window.removeEventListener(NOTIFICATIONS_EVENTS.show, showHandler);
    window.removeEventListener(NOTIFICATIONS_EVENTS.update, updateHandler);
    window.removeEventListener(NOTIFICATIONS_EVENTS.hide, hideHandler);
    window.removeEventListener(NOTIFICATIONS_EVENTS.clear, clear2);
    window.removeEventListener(NOTIFICATIONS_EVENTS.clearQueue, clearQueue2);
  });
  return createComponent(NotificationsProviderContext.Provider, {
    value: context,
    get children() {
      return [createComponent(Portal, {
        get children() {
          return createComponent(Box, {
            get ["class"]() {
              return classes();
            },
            get zIndex() {
              return local.zIndex;
            },
            get children() {
              return createComponent(TransitionGroup, {
                get name() {
                  return transitionName();
                },
                get children() {
                  return createComponent(For, {
                    get each() {
                      return context.notifications();
                    },
                    children: (notification) => createComponent(NotificationContainer, notification)
                  });
                }
              });
            }
          });
        }
      }), memo(() => local.children)];
    }
  });
}
var hasTabIndex = (element) => element.hasAttribute("tabindex");
function isHidden3(element) {
  if (element.parentElement && isHidden3(element.parentElement)) {
    return true;
  }
  return element.hidden;
}
function isDisabled(element) {
  return Boolean(element.getAttribute("disabled")) === true || Boolean(element.getAttribute("aria-disabled")) === true;
}
function isContentEditable(element) {
  const value = element.getAttribute("contenteditable");
  return value !== "false" && value != null;
}
function isFocusable3(element) {
  if (!isHTMLElement2(element) || isHidden3(element) || isDisabled(element)) {
    return false;
  }
  const { localName } = element;
  const focusableTags = ["input", "select", "textarea", "button"];
  if (focusableTags.indexOf(localName) >= 0) {
    return true;
  }
  const others = {
    a: () => element.hasAttribute("href"),
    audio: () => element.hasAttribute("controls"),
    video: () => element.hasAttribute("controls")
  };
  if (localName in others) {
    return others[localName]();
  }
  if (isContentEditable(element)) {
    return true;
  }
  return hasTabIndex(element);
}
function Popover(props) {
  const defaultContentId = `hope-popover-${createUniqueId()}`;
  const theme = useStyleConfig().Popover;
  const [state, setState] = createStore({
    _opened: !!props.defaultOpened,
    isHovering: false,
    headerMounted: false,
    bodyMounted: false,
    finalPlacement: "bottom",
    get isControlled() {
      return props.opened !== void 0;
    },
    get opened() {
      return this.isControlled ? !!props.opened : this._opened;
    },
    get contentId() {
      var _a;
      return (_a = props.id) != null ? _a : defaultContentId;
    },
    get triggerId() {
      return `${this.contentId}--trigger`;
    },
    get headerId() {
      return `${this.contentId}--header`;
    },
    get bodyId() {
      return `${this.contentId}--body`;
    },
    get triggerMode() {
      var _a;
      return (_a = props.triggerMode) != null ? _a : "click";
    },
    get triggerOnClick() {
      return this.triggerMode === "click";
    },
    get triggerOnHover() {
      return this.triggerMode === "hover";
    },
    get initialFocus() {
      return props.initialFocus;
    },
    get inline() {
      var _a;
      return (_a = props.inline) != null ? _a : false;
    },
    get initialPlacement() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.placement) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.placement) != null ? _d : "bottom";
    },
    get offset() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.offset) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.offset) != null ? _d : 8;
    },
    get arrowPadding() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.arrowPadding) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.arrowPadding) != null ? _d : 8;
    },
    get openDelay() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.openDelay) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.openDelay) != null ? _d : 0;
    },
    get closeDelay() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.closeDelay) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.closeDelay) != null ? _d : 100;
    },
    get motionPreset() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.motionPreset) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.motionPreset) != null ? _d : "scale";
    },
    get closeOnBlur() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.closeOnBlur) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.closeOnBlur) != null ? _d : true;
    },
    get closeOnEsc() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.closeOnEsc) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.closeOnEsc) != null ? _d : true;
    },
    get trapFocus() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.trapFocus) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.trapFocus) != null ? _d : false;
    }
  });
  let anchorRef;
  let triggerRef;
  let popoverRef;
  let arrowRef;
  let focusTrap;
  let enterTimeoutId;
  let exitTimeoutId;
  let cleanupPopoverAutoUpdate;
  const popoverSelector = () => `[id='${state.contentId}']`;
  const assignAnchorRef = (el) => {
    anchorRef = el;
  };
  const assignTriggerRef = (el) => {
    triggerRef = el;
  };
  const assignPopoverRef = (el) => {
    popoverRef = el;
  };
  const assignArrowRef = (el) => {
    arrowRef = el;
  };
  async function updatePopoverPosition() {
    var _a, _b, _c;
    const referenceElement = anchorRef != null ? anchorRef : triggerRef;
    if (!referenceElement || !popoverRef) {
      return;
    }
    const middleware = [offset(state.offset)];
    if (state.inline) {
      middleware.push(inline());
    }
    middleware.push(flip());
    middleware.push(shift({
      padding: props.shiftPadding
    }));
    if (arrowRef) {
      middleware.push(arrow({
        element: arrowRef,
        padding: state.arrowPadding
      }));
    }
    middleware.push(hide());
    const {
      x: x2,
      y: y2,
      placement,
      middlewareData
    } = await computePosition2(referenceElement, popoverRef, {
      placement: state.initialPlacement,
      middleware
    });
    if (placement !== state.finalPlacement) {
      setState("finalPlacement", placement);
    }
    if (!popoverRef) {
      return;
    }
    const referenceHidden = (_a = middlewareData.hide) == null ? void 0 : _a.referenceHidden;
    Object.assign(popoverRef.style, {
      left: `${Math.round(x2)}px`,
      top: `${Math.round(y2)}px`,
      visibility: referenceHidden ? "hidden" : "visible"
    });
    if (!arrowRef) {
      return;
    }
    const arrowX = (_b = middlewareData.arrow) == null ? void 0 : _b.x;
    const arrowY = (_c = middlewareData.arrow) == null ? void 0 : _c.y;
    const staticSide = {
      top: "bottom",
      right: "left",
      bottom: "top",
      left: "right"
    }[placement.split("-")[0]];
    const arrowOffset = `${(Math.round(arrowRef.clientWidth / 2) + 1) * -1}px`;
    Object.assign(arrowRef.style, {
      left: arrowX != null ? `${Math.round(arrowX)}px` : "",
      top: arrowY != null ? `${Math.round(arrowY)}px` : "",
      right: "",
      bottom: "",
      [staticSide]: arrowOffset
    });
  }
  const onOpen = () => {
    var _a;
    if (!state.isControlled) {
      setState("_opened", true);
    }
    (_a = props.onOpen) == null ? void 0 : _a.call(props);
    updatePopoverPosition();
  };
  const onClose = () => {
    var _a;
    if (!state.isControlled) {
      setState("_opened", false);
    }
    (_a = props.onClose) == null ? void 0 : _a.call(props);
  };
  const closeIfNotHover = () => {
    !state.isHovering && onClose();
  };
  const openWithDelay = () => {
    enterTimeoutId = window.setTimeout(onOpen, state.openDelay);
  };
  const closeWithDelay = () => {
    if (enterTimeoutId) {
      window.clearTimeout(enterTimeoutId);
    }
    exitTimeoutId = window.setTimeout(onClose, state.closeDelay);
  };
  const setupPopoverAutoUpdate = () => {
    if (isServer) {
      return;
    }
    const referenceElement = anchorRef != null ? anchorRef : triggerRef;
    if (!referenceElement || !popoverRef) {
      return;
    }
    cleanupPopoverAutoUpdate = autoUpdate(referenceElement, popoverRef, updatePopoverPosition);
  };
  const focusInitialElement = () => {
    if (!state.initialFocus) {
      popoverRef == null ? void 0 : popoverRef.focus();
      return;
    }
    const initialFocusRef = document.querySelector(state.initialFocus);
    initialFocusRef && isFocusable3(initialFocusRef) && (initialFocusRef == null ? void 0 : initialFocusRef.focus());
  };
  const onTriggerBlur = (event) => {
    const relatedTarget = getRelatedTarget(event);
    const isValidBlur = !contains2(popoverRef, relatedTarget);
    if (state.opened && state.closeOnBlur && isValidBlur) {
      closeWithDelay();
    }
  };
  const onTriggerMouseLeave = () => {
    setIsHovering(false);
    if (enterTimeoutId) {
      window.clearTimeout(enterTimeoutId);
    }
    exitTimeoutId = window.setTimeout(closeIfNotHover, state.closeDelay);
  };
  const onPopoverFocusOut = (event) => {
    const relatedTarget = getRelatedTarget(event);
    const targetIsPopover = contains2(popoverRef, relatedTarget);
    const targetIsTrigger = contains2(triggerRef, relatedTarget);
    const isValidBlur = !targetIsPopover && !targetIsTrigger;
    if (state.opened && state.closeOnBlur && isValidBlur) {
      closeWithDelay();
    }
  };
  const onPopoverMouseLeave = onTriggerMouseLeave;
  const afterPopoverOpen = () => {
    setupPopoverAutoUpdate();
    if (state.trapFocus && popoverRef) {
      focusTrap = createFocusTrap(popoverRef, {
        initialFocus: state.initialFocus,
        fallbackFocus: popoverSelector(),
        allowOutsideClick: false
      });
      focusTrap.activate();
    } else {
      focusInitialElement();
    }
  };
  const afterPopoverClose = () => {
    focusTrap == null ? void 0 : focusTrap.deactivate();
    cleanupPopoverAutoUpdate == null ? void 0 : cleanupPopoverAutoUpdate();
  };
  const setIsHovering = (value) => setState("isHovering", value);
  const setHeaderMounted = (value) => setState("headerMounted", value);
  const setBodyMounted = (value) => setState("bodyMounted", value);
  const openedAccessor = () => state.opened;
  onCleanup(() => {
    window.clearTimeout(enterTimeoutId);
    window.clearTimeout(exitTimeoutId);
  });
  const context = {
    state,
    assignAnchorRef,
    assignTriggerRef,
    assignPopoverRef,
    assignArrowRef,
    openWithDelay,
    closeWithDelay,
    onTriggerBlur,
    onTriggerMouseLeave,
    onPopoverFocusOut,
    onPopoverMouseLeave,
    updatePopoverPosition,
    afterPopoverOpen,
    afterPopoverClose,
    setIsHovering,
    setHeaderMounted,
    setBodyMounted
  };
  return createComponent(PopoverContext.Provider, {
    value: context,
    get children() {
      return createComponent(Show, {
        get when() {
          return isChildrenFunction(props);
        },
        get fallback() {
          return props.children;
        },
        get children() {
          var _a;
          return (_a = props.children) == null ? void 0 : _a.call(props, {
            opened: openedAccessor,
            onClose: closeWithDelay
          });
        }
      });
    }
  });
}
var PopoverContext = createContext();
function usePopoverContext() {
  const context = useContext(PopoverContext);
  if (!context) {
    throw new Error("[Hope UI]: usePopoverContext must be used within a `<Popover />` component");
  }
  return context;
}
function PopoverAnchor(props) {
  const popoverContext = usePopoverContext();
  const [local, others] = splitProps(props, ["ref", "as"]);
  const assignRef = (el) => {
    popoverContext.assignAnchorRef(el);
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  return createComponent(Dynamic, mergeProps({
    get component() {
      return local.as;
    },
    ref: assignRef
  }, others));
}
var hopePopoverArrowClass = "hope-popover__arrow";
function PopoverArrow(props) {
  const theme = useStyleConfig().Popover;
  const popoverContext = usePopoverContext();
  const [local, others] = splitProps(props, ["class"]);
  const placement = createMemo(() => {
    return popoverContext.state.finalPlacement.split("-")[0];
  });
  const classes = () => {
    return classNames(local.class, hopePopoverArrowClass, popoverArrowStyles({
      popoverPlacement: placement()
    }));
  };
  return createComponent(Box, mergeProps({
    ref(r$) {
      const _ref$ = popoverContext.assignArrowRef;
      typeof _ref$ === "function" ? _ref$(r$) : popoverContext.assignArrowRef = r$;
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.arrow;
    }
  }, others));
}
PopoverArrow.toString = () => createClassSelector(hopePopoverArrowClass);
var hopePopoverBodyClass = "hope-popover__body";
function PopoverBody(props) {
  const theme = useStyleConfig().Popover;
  const popoverContext = usePopoverContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopePopoverBodyClass, popoverBodyStyles());
  onMount(() => popoverContext.setBodyMounted(true));
  onCleanup(() => popoverContext.setBodyMounted(false));
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get id() {
      return popoverContext.state.bodyId;
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.body;
    }
  }, others));
}
PopoverBody.toString = () => createClassSelector(hopePopoverBodyClass);
var hopePopoverCloseButtonClass = "hope-popover__close-button";
function PopoverCloseButton(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const theme = useStyleConfig().Popover;
  const popoverContext = usePopoverContext();
  const defaultProps = {
    "aria-label": (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.closeButton) == null ? void 0 : _b["aria-label"]) != null ? _c : "Close popover",
    size: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.closeButton) == null ? void 0 : _e.size) != null ? _f : "sm",
    icon: (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.closeButton) == null ? void 0 : _h.icon
  };
  const propsWithDefaults = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefaults, ["class", "onClick"]);
  const classes = () => classNames(local.class, hopePopoverCloseButtonClass, popoverCloseButtonStyles());
  const onClick = (event) => {
    chainHandlers(local.onClick, (e) => {
      e.stopPropagation();
      popoverContext.closeWithDelay();
    })(event);
  };
  return createComponent(CloseButton, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a2;
      return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.closeButton;
    },
    onClick
  }, others));
}
PopoverCloseButton.toString = () => createClassSelector(hopePopoverCloseButtonClass);
var hopePopoverContentClass = "hope-popover__content";
function PopoverContent(props) {
  const theme = useStyleConfig().Popover;
  const popoverContext = usePopoverContext();
  const [isPortalMounted, setIsPortalMounted] = createSignal(false);
  const [local, others] = splitProps(props, ["ref", "class", "onKeyDown", "onFocusOut", "onMouseEnter", "onMouseLeave"]);
  const assignRef = (el) => {
    popoverContext.assignPopoverRef(el);
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const closeOnKeyDown = (event) => {
    if (popoverContext.state.closeOnEsc && event.key === "Escape") {
      popoverContext.closeWithDelay();
    }
  };
  const onKeyDown = (event) => {
    chainHandlers(local.onKeyDown, closeOnKeyDown)(event);
  };
  const onFocusOut = (event) => {
    chainHandlers(local.onFocusOut, popoverContext.onPopoverFocusOut)(event);
  };
  const onMouseEnter = (event) => {
    callHandler(local.onMouseEnter, event);
    popoverContext.setIsHovering(true);
  };
  const onMouseLeave = (event) => {
    callHandler(local.onMouseLeave, event);
    popoverContext.onPopoverMouseLeave();
  };
  const afterPopoverEnterTransition = () => {
    if (isServer) {
      return;
    }
    document.addEventListener("keydown", closeOnKeyDown);
    popoverContext.afterPopoverOpen();
  };
  const afterPopoverExitTransition = () => {
    document.removeEventListener("keydown", closeOnKeyDown);
    popoverContext.afterPopoverClose();
    setIsPortalMounted(false);
  };
  const popoverClasses = () => {
    return classNames(local.class, hopePopoverContentClass, popoverContentStyles());
  };
  const transitionName = () => {
    switch (popoverContext.state.motionPreset) {
      case "scale":
        return popoverTransitionName.scale;
      case "none":
        return "hope-none";
    }
  };
  createEffect(() => {
    if (popoverContext.state.opened) {
      setIsPortalMounted(true);
    } else {
      popoverContext.state.motionPreset === "none" && setIsPortalMounted(false);
    }
  });
  return createComponent(Show, {
    get when() {
      return isPortalMounted();
    },
    get children() {
      return createComponent(Portal, {
        get children() {
          return createComponent(Transition, {
            get name() {
              return transitionName();
            },
            appear: true,
            get onBeforeEnter() {
              return popoverContext.updatePopoverPosition;
            },
            onAfterEnter: afterPopoverEnterTransition,
            onAfterExit: afterPopoverExitTransition,
            get children() {
              return createComponent(Show, {
                get when() {
                  return popoverContext.state.opened;
                },
                get children() {
                  return createComponent(hope.section, mergeProps({
                    ref: assignRef,
                    tabIndex: -1,
                    get id() {
                      return popoverContext.state.contentId;
                    },
                    get role() {
                      return popoverContext.state.triggerOnHover ? "tooltip" : "dialog";
                    },
                    get ["aria-labelledby"]() {
                      return popoverContext.state.headerMounted ? popoverContext.state.headerId : void 0;
                    },
                    get ["aria-describedby"]() {
                      return popoverContext.state.bodyMounted ? popoverContext.state.bodyId : void 0;
                    },
                    get ["class"]() {
                      return popoverClasses();
                    },
                    get __baseStyle() {
                      var _a;
                      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.content;
                    },
                    onKeyDown,
                    onFocusOut,
                    get onMouseEnter() {
                      return popoverContext.state.triggerOnHover ? onMouseEnter : void 0;
                    },
                    get onMouseLeave() {
                      return popoverContext.state.triggerOnHover ? onMouseLeave : void 0;
                    }
                  }, others));
                }
              });
            }
          });
        }
      });
    }
  });
}
PopoverContent.toString = () => createClassSelector(hopePopoverContentClass);
var hopePopoverFooterClass = "hope-popover__footer";
function PopoverFooter(props) {
  const theme = useStyleConfig().Popover;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopePopoverFooterClass, popoverFooterStyles());
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.footer;
    }
  }, others));
}
PopoverFooter.toString = () => createClassSelector(hopePopoverFooterClass);
var hopePopoverHeaderClass = "hope-popover__header";
function PopoverHeader(props) {
  const theme = useStyleConfig().Popover;
  const popoverContext = usePopoverContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopePopoverHeaderClass, popoverHeaderStyles());
  onMount(() => popoverContext.setHeaderMounted(true));
  onCleanup(() => popoverContext.setHeaderMounted(false));
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get id() {
      return popoverContext.state.headerId;
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.header;
    }
  }, others));
}
PopoverHeader.toString = () => createClassSelector(hopePopoverHeaderClass);
function PopoverTrigger(props) {
  const popoverContext = usePopoverContext();
  const [local, others] = splitProps(props, ["ref", "onClick", "onKeyDown", "onFocus", "onBlur", "onMouseEnter", "onMouseLeave"]);
  const assignTriggerRef = (el) => {
    popoverContext.assignTriggerRef(el);
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const onClick = (event) => {
    callHandler(local.onClick, event);
    popoverContext.state.opened ? popoverContext.closeWithDelay() : popoverContext.openWithDelay();
  };
  const onKeyDown = (event) => {
    callHandler(local.onKeyDown, event);
    if (event.key === "Escape") {
      popoverContext.closeWithDelay();
    }
  };
  const onFocus = (event) => {
    callHandler(local.onFocus, event);
    popoverContext.openWithDelay();
  };
  const onBlur = (event) => {
    chainHandlers(local.onBlur, popoverContext.onTriggerBlur)(event);
  };
  const onMouseEnter = (event) => {
    callHandler(local.onMouseEnter, event);
    popoverContext.setIsHovering(true);
    popoverContext.openWithDelay();
  };
  const onMouseLeave = (event) => {
    callHandler(local.onMouseLeave, event);
    popoverContext.onTriggerMouseLeave();
  };
  return createComponent(hope.button, mergeProps({
    ref: assignTriggerRef,
    get id() {
      return popoverContext.state.triggerId;
    },
    type: "button",
    "aria-haspopup": "dialog",
    get ["aria-controls"]() {
      return popoverContext.state.contentId;
    },
    get ["aria-expanded"]() {
      return popoverContext.state.opened;
    },
    get onClick() {
      return popoverContext.state.triggerOnClick ? onClick : void 0;
    },
    get onKeyDown() {
      return popoverContext.state.triggerOnHover ? onKeyDown : void 0;
    },
    get onFocus() {
      return popoverContext.state.triggerOnHover ? onFocus : void 0;
    },
    get onBlur() {
      return popoverContext.state.triggerOnHover ? onBlur : void 0;
    },
    get onMouseEnter() {
      return popoverContext.state.triggerOnHover ? onMouseEnter : void 0;
    },
    get onMouseLeave() {
      return popoverContext.state.triggerOnHover ? onMouseLeave : void 0;
    }
  }, others));
}
var indeterminateProgress = keyframes({
  "0%": { left: "-40%" },
  "100%": { left: "100%" }
});
var stripe = keyframes({
  from: { backgroundPosition: "1rem 0" },
  to: { backgroundPosition: "0 0" }
});
var progressStyles = css({
  position: "relative",
  overflow: "hidden",
  variants: {
    size: {
      xs: {
        height: "$1",
        fontSize: "4px"
      },
      sm: {
        height: "$2",
        fontSize: "6px"
      },
      md: {
        height: "$3",
        fontSize: "8px"
      },
      lg: {
        height: "$4",
        fontSize: "10px"
      }
    }
  }
});
var progressIndicatorStyles = css({
  position: "relative",
  height: "100%",
  transition: "width 600ms ease",
  variants: {
    striped: {
      true: {}
    },
    animated: {
      true: {}
    },
    indeterminate: {
      true: {
        position: "absolute",
        willChange: "left",
        minWidth: "50%",
        animation: `${indeterminateProgress} 1200ms ease infinite normal none running`
      }
    }
  },
  compoundVariants: [
    {
      indeterminate: false,
      striped: true,
      css: {
        backgroundImage: "linear-gradient(45deg, $colors$progressStripe 25%, transparent 25%, transparent 50%, $colors$progressStripe 50%,  $colors$progressStripe 75%, transparent 75%, transparent)",
        backgroundSize: "1rem 1rem"
      }
    },
    {
      indeterminate: false,
      striped: true,
      animated: true,
      css: {
        animation: `${stripe} 750ms linear infinite`
      }
    }
  ]
});
var progressLabelStyles = css({
  position: "absolute",
  top: "50%",
  left: "50%",
  width: "100%",
  color: "$neutral12",
  lineHeight: "$none",
  fontWeight: "$bold",
  textAlign: "center",
  transform: "translate(-50%, -50%)"
});
var ProgressContext = createContext();
var hopeProgressClass = "hope-progress";
function Progress(props) {
  var _a, _b, _c, _d, _e, _f;
  const theme = useStyleConfig().Progress;
  const [state] = createStore({
    get min() {
      var _a2;
      return (_a2 = props.min) != null ? _a2 : 0;
    },
    get max() {
      var _a2;
      return (_a2 = props.max) != null ? _a2 : 100;
    },
    get value() {
      var _a2;
      return (_a2 = props.value) != null ? _a2 : 0;
    },
    get percent() {
      return valueToPercent(this.value, this.min, this.max);
    },
    get indeterminate() {
      var _a2;
      return (_a2 = props.indeterminate) != null ? _a2 : false;
    },
    get ariaValueText() {
      var _a2;
      if (this.indeterminate) {
        return void 0;
      }
      if (isFunction(this.getValueText)) {
        return this.getValueText(this.value, this.percent);
      }
      return (_a2 = props.valueText) != null ? _a2 : `${this.percent}%`;
    },
    get getValueText() {
      return props.getValueText;
    }
  });
  const defaultProps = {
    size: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.size) != null ? _c : "md",
    trackColor: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.root) == null ? void 0 : _e.trackColor) != null ? _f : "$neutral4"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, _, others] = splitProps(propsWithDefault, ["class", "size", "trackColor"], ["min", "max", "value", "indeterminate", "valueText", "getValueText"]);
  const classes = () => {
    return classNames(local.class, hopeProgressClass, progressStyles({
      size: local.size
    }));
  };
  const context = {
    state
  };
  return createComponent(ProgressContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        role: "progressbar",
        get ["data-indeterminate"]() {
          return state.indeterminate ? "" : void 0;
        },
        get ["aria-valuemin"]() {
          return state.min;
        },
        get ["aria-valuemax"]() {
          return state.max;
        },
        get ["aria-valuenow"]() {
          return state.indeterminate ? void 0 : state.value;
        },
        get ["aria-valuetext"]() {
          return state.ariaValueText;
        },
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a2;
          return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.root;
        },
        get backgroundColor() {
          return local.trackColor;
        }
      }, others));
    }
  });
}
Progress.toString = () => createClassSelector(hopeProgressClass);
function useProgressContext() {
  const context = useContext(ProgressContext);
  if (!context) {
    throw new Error("[Hope UI]: useProgressContext must be used within a `<Progress />` component");
  }
  return context;
}
var hopeProgressIndicatorClass = "hope-progress__indicator";
function ProgressIndicator(props) {
  const theme = useStyleConfig().Progress;
  const progressContext = useProgressContext();
  const defaultProps = {
    color: "$primary9"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "color", "striped", "animated"]);
  const backgroundStyles = () => {
    if (progressContext.state.indeterminate) {
      return {
        backgroundImage: `linear-gradient(to right, transparent 0%, ${local.color} 50%, transparent 100%)`
      };
    }
    return {
      backgroundColor: local.color
    };
  };
  const classes = () => {
    return classNames(local.class, hopeProgressIndicatorClass, progressIndicatorStyles({
      striped: local.striped,
      animated: local.animated,
      indeterminate: progressContext.state.indeterminate === true ? true : false,
      css: __spreadProps(__spreadValues({}, backgroundStyles()), {
        width: `${progressContext.state.percent}%`
      })
    }));
  };
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.indicator;
    }
  }, others));
}
ProgressIndicator.toString = () => createClassSelector(hopeProgressIndicatorClass);
var hopeProgressLabelClass = "hope-progress__label";
function ProgressLabel(props) {
  const theme = useStyleConfig().Progress;
  const progressContext = useProgressContext();
  const [local, others] = splitProps(props, ["class", "children"]);
  const classes = () => classNames(local.class, hopeProgressLabelClass, progressLabelStyles());
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.label;
    }
  }, others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return local.children;
        },
        get fallback() {
          return progressContext.state.ariaValueText;
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
ProgressLabel.toString = () => createClassSelector(hopeProgressLabelClass);
var radioWrapperStyles = css(toggleWrapperStyles, {
  variants: {
    labelPlacement: {
      start: {
        flexDirection: "row-reverse"
      },
      end: {
        flexDirection: "row"
      }
    }
  }
});
var radioLabelStyles = css(toggleControlLabelStyles);
var radioControlStyles = css(toggleControlStyles, {
  borderRadius: "$full",
  "&[data-checked]::before": {
    content: "",
    display: "inline-block",
    position: "relative",
    boxSize: "calc(50% + 1px)",
    borderRadius: "$full",
    backgroundColor: "$loContrast"
  }
});
var hopeRadioGroupClass = "hope-radio-group";
function RadioGroup(props) {
  const defaultRadioName = `hope-radio-group-${createUniqueId()}--radio`;
  const theme = useStyleConfig().Radio;
  const [state, setState] = createStore({
    _value: props.defaultValue,
    get isControlled() {
      return props.value !== void 0;
    },
    get value() {
      return this.isControlled ? props.value : this._value;
    },
    get name() {
      var _a;
      return (_a = props.name) != null ? _a : defaultRadioName;
    },
    get required() {
      return props.required;
    },
    get disabled() {
      return props.disabled;
    },
    get invalid() {
      return props.invalid;
    },
    get readOnly() {
      return props.readOnly;
    },
    get variant() {
      var _a, _b, _c;
      return (_c = props.variant) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.variant;
    },
    get colorScheme() {
      var _a, _b, _c;
      return (_c = props.colorScheme) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.colorScheme;
    },
    get size() {
      var _a, _b, _c;
      return (_c = props.size) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.group) == null ? void 0 : _b.size;
    }
  });
  const [local, _, others] = splitProps(props, ["class", "onChange"], ["value", "defaultValue", "name", "required", "disabled", "readOnly", "invalid"]);
  const onChange = (event) => {
    var _a;
    const value = event.target.value;
    setState("_value", value);
    (_a = local.onChange) == null ? void 0 : _a.call(local, String(value));
  };
  const classes = () => classNames(local.class, hopeRadioGroupClass);
  const context = {
    state,
    onChange
  };
  return createComponent(RadioGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        role: "radiogroup",
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.group;
        }
      }, others));
    }
  });
}
RadioGroup.toString = () => createClassSelector(hopeRadioGroupClass);
var RadioGroupContext = createContext();
function useRadioGroupContext() {
  return useContext(RadioGroupContext);
}
var _tmpl$$6 = template(`<input type="radio">`, 1);
var hopeRadioClass = "hope-radio";
var hopeRadioInputClass = "hope-radio__input";
var hopeRadioControlClass = "hope-radio__control";
var hopeRadioLabelClass = "hope-radio__label";
function Radio(props) {
  const defaultId = `hope-radio-${createUniqueId()}`;
  const theme = useStyleConfig().Radio;
  const formControlContext = useFormControlContext();
  const radioGroupContext = useRadioGroupContext();
  const formControlProps = useFormControl(props);
  const [state, setState] = createStore({
    _checked: !!props.defaultChecked,
    isFocused: false,
    get isControlled() {
      return props.checked !== void 0;
    },
    get checked() {
      if (radioGroupContext) {
        const radioGroupValue = radioGroupContext.state.value;
        return radioGroupValue != null ? String(props.value) === String(radioGroupValue) : false;
      }
      return this.isControlled ? !!props.checked : this._checked;
    },
    get variant() {
      var _a, _b, _c, _d, _e, _f;
      return (_f = (_e = (_b = props.variant) != null ? _b : (_a = radioGroupContext == null ? void 0 : radioGroupContext.state) == null ? void 0 : _a.variant) != null ? _e : (_d = (_c = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _c.root) == null ? void 0 : _d.variant) != null ? _f : "outline";
    },
    get colorScheme() {
      var _a, _b, _c, _d, _e, _f;
      return (_f = (_e = (_b = props.colorScheme) != null ? _b : (_a = radioGroupContext == null ? void 0 : radioGroupContext.state) == null ? void 0 : _a.colorScheme) != null ? _e : (_d = (_c = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _c.root) == null ? void 0 : _d.colorScheme) != null ? _f : "primary";
    },
    get size() {
      var _a, _b, _c, _d, _e, _f;
      return (_f = (_e = (_b = props.size) != null ? _b : (_a = radioGroupContext == null ? void 0 : radioGroupContext.state) == null ? void 0 : _a.size) != null ? _e : (_d = (_c = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _c.root) == null ? void 0 : _d.size) != null ? _f : "md";
    },
    get labelPlacement() {
      var _a, _b, _c, _d, _e, _f;
      return (_f = (_e = (_b = props.labelPlacement) != null ? _b : (_a = radioGroupContext == null ? void 0 : radioGroupContext.state) == null ? void 0 : _a.labelPlacement) != null ? _e : (_d = (_c = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _c.root) == null ? void 0 : _d.labelPlacement) != null ? _f : "end";
    },
    get id() {
      var _a;
      if (formControlContext && !radioGroupContext) {
        return formControlProps.id;
      }
      return (_a = props.id) != null ? _a : defaultId;
    },
    get name() {
      var _a;
      return (_a = props.name) != null ? _a : radioGroupContext == null ? void 0 : radioGroupContext.state.name;
    },
    get value() {
      return props.value;
    },
    get required() {
      var _a;
      return (_a = formControlProps.required) != null ? _a : radioGroupContext == null ? void 0 : radioGroupContext.state.required;
    },
    get disabled() {
      var _a;
      return (_a = formControlProps.disabled) != null ? _a : radioGroupContext == null ? void 0 : radioGroupContext.state.disabled;
    },
    get invalid() {
      var _a;
      return (_a = formControlProps.invalid) != null ? _a : radioGroupContext == null ? void 0 : radioGroupContext.state.invalid;
    },
    get readOnly() {
      var _a;
      return (_a = formControlProps.readOnly) != null ? _a : radioGroupContext == null ? void 0 : radioGroupContext.state.readOnly;
    },
    get ["aria-required"]() {
      return this.required ? true : void 0;
    },
    get ["aria-disabled"]() {
      return this.disabled ? true : void 0;
    },
    get ["aria-invalid"]() {
      return this.invalid ? true : void 0;
    },
    get ["aria-readonly"]() {
      return this.readOnly ? true : void 0;
    },
    get ["aria-label"]() {
      return props["aria-label"];
    },
    get ["aria-labelledby"]() {
      return props["aria-labelledby"];
    },
    get ["aria-describedby"]() {
      return props["aria-describedby"];
    },
    get ["data-focus"]() {
      return this.isFocused ? "" : void 0;
    },
    get ["data-checked"]() {
      return this.checked ? "" : void 0;
    },
    get ["data-required"]() {
      return this.required ? "" : void 0;
    },
    get ["data-disabled"]() {
      return this.disabled ? "" : void 0;
    },
    get ["data-invalid"]() {
      return this.invalid ? "" : void 0;
    },
    get ["data-readonly"]() {
      return this.readOnly ? "" : void 0;
    }
  });
  const [local, _, others] = splitProps(props, ["class", "children", "ref", "tabIndex", "onChange"], ["variant", "colorScheme", "size", "labelPlacement", "id", "name", "value", "checked", "defaultChecked", "required", "disabled", "invalid", "readOnly", "onFocus", "onBlur"]);
  const onChange = (event) => {
    if (state.readOnly || state.disabled) {
      event.preventDefault();
      return;
    }
    if (!state.isControlled) {
      const target = event.target;
      setState("_checked", target.checked);
    }
    chainHandlers(radioGroupContext == null ? void 0 : radioGroupContext.onChange, local.onChange)(event);
  };
  const onFocus = (event) => {
    setState("isFocused", true);
    callHandler(formControlProps.onFocus, event);
  };
  const onBlur = (event) => {
    setState("isFocused", false);
    callHandler(formControlProps.onBlur, event);
  };
  const wrapperClasses = () => {
    return classNames(local.class, hopeRadioClass, radioWrapperStyles({
      size: state.size,
      labelPlacement: state.labelPlacement
    }));
  };
  const inputClasses = () => classNames(hopeRadioInputClass, visuallyHiddenStyles());
  const controlClasses = () => {
    return classNames(hopeRadioControlClass, radioControlStyles({
      variant: state.variant,
      colorScheme: state.colorScheme,
      size: state.size
    }));
  };
  const labelClasses = () => {
    return classNames(hopeRadioLabelClass, radioLabelStyles());
  };
  const context = {
    state,
    onChange,
    onFocus,
    onBlur
  };
  return createComponent(RadioContext.Provider, {
    value: context,
    get children() {
      return createComponent(hope.label, mergeProps({
        get ["class"]() {
          return wrapperClasses();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.root;
        },
        get ["for"]() {
          return state.id;
        },
        "data-group": true,
        get ["data-focus"]() {
          return state["data-focus"];
        },
        get ["data-checked"]() {
          return state["data-checked"];
        },
        get ["data-required"]() {
          return state["data-required"];
        },
        get ["data-disabled"]() {
          return state["data-disabled"];
        },
        get ["data-invalid"]() {
          return state["data-invalid"];
        },
        get ["data-readonly"]() {
          return state["data-readonly"];
        }
      }, others, {
        get children() {
          return [(() => {
            const _el$ = _tmpl$$6.cloneNode(true);
            _el$.addEventListener("blur", onBlur);
            _el$.addEventListener("focus", onFocus);
            _el$.addEventListener("change", onChange);
            const _ref$ = local.ref;
            typeof _ref$ === "function" ? _ref$(_el$) : local.ref = _el$;
            createRenderEffect((_p$) => {
              const _v$ = inputClasses(), _v$2 = local.tabIndex, _v$3 = state.value, _v$4 = state.id, _v$5 = state.name, _v$6 = state.checked, _v$7 = state.required, _v$8 = state.disabled, _v$9 = state.readOnly, _v$10 = state["aria-required"], _v$11 = state["aria-disabled"], _v$12 = state["aria-invalid"], _v$13 = state["aria-readonly"], _v$14 = state["aria-label"], _v$15 = state["aria-labelledby"], _v$16 = state["aria-describedby"];
              _v$ !== _p$._v$ && (_el$.className = _p$._v$ = _v$);
              _v$2 !== _p$._v$2 && setAttribute(_el$, "tabindex", _p$._v$2 = _v$2);
              _v$3 !== _p$._v$3 && (_el$.value = _p$._v$3 = _v$3);
              _v$4 !== _p$._v$4 && setAttribute(_el$, "id", _p$._v$4 = _v$4);
              _v$5 !== _p$._v$5 && setAttribute(_el$, "name", _p$._v$5 = _v$5);
              _v$6 !== _p$._v$6 && (_el$.checked = _p$._v$6 = _v$6);
              _v$7 !== _p$._v$7 && (_el$.required = _p$._v$7 = _v$7);
              _v$8 !== _p$._v$8 && (_el$.disabled = _p$._v$8 = _v$8);
              _v$9 !== _p$._v$9 && (_el$.readOnly = _p$._v$9 = _v$9);
              _v$10 !== _p$._v$10 && setAttribute(_el$, "aria-required", _p$._v$10 = _v$10);
              _v$11 !== _p$._v$11 && setAttribute(_el$, "aria-disabled", _p$._v$11 = _v$11);
              _v$12 !== _p$._v$12 && setAttribute(_el$, "aria-invalid", _p$._v$12 = _v$12);
              _v$13 !== _p$._v$13 && setAttribute(_el$, "aria-readonly", _p$._v$13 = _v$13);
              _v$14 !== _p$._v$14 && setAttribute(_el$, "aria-label", _p$._v$14 = _v$14);
              _v$15 !== _p$._v$15 && setAttribute(_el$, "aria-labelledby", _p$._v$15 = _v$15);
              _v$16 !== _p$._v$16 && setAttribute(_el$, "aria-describedby", _p$._v$16 = _v$16);
              return _p$;
            }, {
              _v$: void 0,
              _v$2: void 0,
              _v$3: void 0,
              _v$4: void 0,
              _v$5: void 0,
              _v$6: void 0,
              _v$7: void 0,
              _v$8: void 0,
              _v$9: void 0,
              _v$10: void 0,
              _v$11: void 0,
              _v$12: void 0,
              _v$13: void 0,
              _v$14: void 0,
              _v$15: void 0,
              _v$16: void 0
            });
            return _el$;
          })(), createComponent(hope.span, mergeProps({
            "aria-hidden": true,
            get ["class"]() {
              return controlClasses();
            },
            get __baseStyle() {
              var _a;
              return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.control;
            },
            get ["data-focus"]() {
              return state["data-focus"];
            },
            get ["data-checked"]() {
              return state["data-checked"];
            },
            get ["data-required"]() {
              return state["data-required"];
            },
            get ["data-disabled"]() {
              return state["data-disabled"];
            },
            get ["data-invalid"]() {
              return state["data-invalid"];
            },
            get ["data-readonly"]() {
              return state["data-readonly"];
            }
          }, others)), createComponent(hope.span, {
            get ["class"]() {
              return labelClasses();
            },
            get __baseStyle() {
              var _a;
              return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.label;
            },
            get ["data-focus"]() {
              return state["data-focus"];
            },
            get ["data-checked"]() {
              return state["data-checked"];
            },
            get ["data-required"]() {
              return state["data-required"];
            },
            get ["data-disabled"]() {
              return state["data-disabled"];
            },
            get ["data-invalid"]() {
              return state["data-invalid"];
            },
            get ["data-readonly"]() {
              return state["data-readonly"];
            },
            get children() {
              return createComponent(Show, {
                get when() {
                  return isChildrenFunction(local);
                },
                get fallback() {
                  return local.children;
                },
                get children() {
                  var _a;
                  return (_a = local.children) == null ? void 0 : _a.call(local, {
                    checked: state.checked
                  });
                }
              });
            }
          })];
        }
      }));
    }
  });
}
Radio.toString = () => createClassSelector(hopeRadioClass);
var RadioContext = createContext();
function useRadioContext() {
  const context = useContext(RadioContext);
  if (!context) {
    throw new Error("[Hope UI]: useRadioContext must be used within a `<Radio />` component");
  }
  return context;
}
var SelectActions = ((SelectActions2) => {
  SelectActions2[SelectActions2["Close"] = 0] = "Close";
  SelectActions2[SelectActions2["SelectAndClose"] = 1] = "SelectAndClose";
  SelectActions2[SelectActions2["First"] = 2] = "First";
  SelectActions2[SelectActions2["Last"] = 3] = "Last";
  SelectActions2[SelectActions2["Next"] = 4] = "Next";
  SelectActions2[SelectActions2["Open"] = 5] = "Open";
  SelectActions2[SelectActions2["Previous"] = 6] = "Previous";
  SelectActions2[SelectActions2["Select"] = 7] = "Select";
  SelectActions2[SelectActions2["Type"] = 8] = "Type";
  return SelectActions2;
})(SelectActions || {});
function filterOptions(options = [], filter, exclude = []) {
  return options.filter((option) => {
    if (option.disabled) {
      return false;
    }
    const matches2 = option.textValue.toLowerCase().indexOf(filter.toLowerCase()) === 0;
    return matches2 && exclude.indexOf(option.textValue) < 0;
  });
}
function getIndexByLetter(options, filter, startIndex = 0) {
  const orderedOptions = [...options.slice(startIndex), ...options.slice(0, startIndex)];
  const firstMatch = filterOptions(orderedOptions, filter)[0];
  const allSameLetter = (array) => array.every((letter) => letter === array[0]);
  if (firstMatch) {
    return options.indexOf(firstMatch);
  } else if (allSameLetter(filter.split(""))) {
    const matches2 = filterOptions(orderedOptions, filter[0]);
    return options.indexOf(matches2[0]);
  } else {
    return -1;
  }
}
function getActionFromKey(event, menuOpen) {
  const { key, altKey, ctrlKey, metaKey } = event;
  const openKeys = ["ArrowDown", "ArrowUp", "Enter", " "];
  if (!menuOpen && openKeys.includes(key)) {
    return 5;
  }
  if (key === "Home" || key === "PageUp") {
    return 2;
  }
  if (key === "End" || key === "PageDown") {
    return 3;
  }
  if (key === "Backspace" || key === "Clear" || key.length === 1 && key !== " " && !altKey && !ctrlKey && !metaKey) {
    return 8;
  }
  if (menuOpen) {
    if (key === "ArrowUp" && altKey) {
      return 1;
    } else if (key === "ArrowDown" && !altKey) {
      return 4;
    } else if (key === "ArrowUp") {
      return 6;
    } else if (key === "Escape") {
      return 0;
    } else if (key === "Enter" || key === " ") {
      return 1;
    }
  }
}
function calculateActiveIndex(currentIndex, maxIndex, action) {
  switch (action) {
    case 2:
      return 0;
    case 3:
      return maxIndex;
    case 6:
      return Math.max(0, currentIndex - 1);
    case 4:
      return Math.min(maxIndex, currentIndex + 1);
    default:
      return currentIndex;
  }
}
function getUpdatedIndex(params) {
  const { currentIndex, maxIndex, initialAction, isOptionDisabled } = params;
  let nextIndex = calculateActiveIndex(currentIndex, maxIndex, initialAction);
  while (isOptionDisabled(nextIndex)) {
    let nextAction = initialAction;
    const isNextIndexFirst = nextIndex === 0;
    const isNextIndexLast = nextIndex === maxIndex;
    if (initialAction === 2) {
      nextAction = 4;
    }
    if (initialAction === 3) {
      nextAction = 6;
    }
    if (initialAction === 6 && isNextIndexFirst) {
      nextIndex = currentIndex;
      break;
    }
    if (initialAction === 4 && isNextIndexLast) {
      nextIndex = currentIndex;
      break;
    }
    nextIndex = calculateActiveIndex(nextIndex, maxIndex, nextAction);
  }
  return nextIndex;
}
function isOptionEqual(a2, b2) {
  return String(a2.value) === String(b2.value);
}
function Select(props) {
  const defaultBaseId = `hope-select-${createUniqueId()}`;
  const theme = useStyleConfig().Select;
  const formControlProps = useFormControl(props);
  const [initialized, setInitialized] = createSignal(false);
  const [_options, _setOptions] = createSignal([]);
  const [state, setState] = createStore({
    get isControlled() {
      return props.value !== void 0;
    },
    get value() {
      var _a;
      if (this.isControlled) {
        return props.value;
      }
      if (this.multiple) {
        return this.selectedOptions.map((option) => option.value);
      }
      return (_a = this.selectedOptions[0].value) != null ? _a : void 0;
    },
    get multiple() {
      return props.multiple;
    },
    get baseId() {
      var _a, _b;
      return (_b = (_a = props.id) != null ? _a : formControlProps.id) != null ? _b : defaultBaseId;
    },
    get triggerId() {
      return `${this.baseId}-trigger`;
    },
    get listboxId() {
      return `${this.baseId}-listbox`;
    },
    get labelIdPrefix() {
      return `${this.baseId}-label`;
    },
    get optionIdPrefix() {
      return `${this.baseId}-option`;
    },
    get disabled() {
      var _a;
      return (_a = props.disabled) != null ? _a : formControlProps.disabled;
    },
    get invalid() {
      var _a;
      return (_a = props.invalid) != null ? _a : formControlProps.invalid;
    },
    get variant() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.variant) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.variant) != null ? _d : "outline";
    },
    get size() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.size) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.size) != null ? _d : "md";
    },
    get motionPreset() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.motionPreset) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.motionPreset) != null ? _d : "fade-in-top";
    },
    get activeDescendantId() {
      return this.opened ? `${this.optionIdPrefix}-${this.activeIndex}` : void 0;
    },
    get hasSelectedOptions() {
      return this.selectedOptions.length > 0;
    },
    get options() {
      return _options();
    },
    selectedOptions: [],
    opened: false,
    activeIndex: 0,
    ignoreBlur: false,
    searchString: "",
    searchTimeoutId: void 0
  });
  let triggerRef;
  let contentRef;
  let listboxRef;
  let cleanupContentAutoUpdate;
  const updateContentPosition = async () => {
    var _a, _b, _c, _d;
    if (!triggerRef || !contentRef) {
      return;
    }
    const {
      x: x2,
      y: y2
    } = await computePosition2(triggerRef, contentRef, {
      placement: "bottom",
      middleware: [offset((_d = (_c = props.offset) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.offset) != null ? _d : 5), flip(), shift(), size({
        apply({
          reference
        }) {
          if (!contentRef) {
            return;
          }
          Object.assign(contentRef.style, {
            width: `${reference.width}px`
          });
        }
      })]
    });
    if (!contentRef) {
      return;
    }
    Object.assign(contentRef.style, {
      left: `${Math.round(x2)}px`,
      top: `${Math.round(y2)}px`
    });
  };
  const getSearchString = (char) => {
    if (state.searchTimeoutId) {
      window.clearTimeout(state.searchTimeoutId);
    }
    const searchTimeoutId = window.setTimeout(() => {
      setState("searchString", "");
    }, 500);
    setState("searchTimeoutId", searchTimeoutId);
    setState("searchString", (searchString) => searchString += char);
    return state.searchString;
  };
  const focusTrigger = () => {
    triggerRef == null ? void 0 : triggerRef.focus();
  };
  const getDefaultSelectedValues = () => {
    if (state.isControlled) {
      if (props.value == null) {
        return [];
      }
      return isArray(props.value) ? props.value : [props.value];
    } else {
      if (props.defaultValue == null) {
        return [];
      }
      return isArray(props.defaultValue) ? props.defaultValue : [props.defaultValue];
    }
  };
  const initSelectedOptions = () => {
    if (initialized()) {
      return;
    }
    const selectedOptions = getDefaultSelectedValues().map((value) => state.options.find((option) => option.value === value)).filter(Boolean);
    setState("selectedOptions", (prev) => [...prev, ...selectedOptions]);
    setInitialized(true);
  };
  const onOptionChange = (index) => {
    setState("activeIndex", index);
  };
  const isOptionSelected = (option) => {
    if (state.selectedOptions.length <= 0) {
      return false;
    }
    if (state.multiple) {
      return !!state.selectedOptions.find((selectedOption) => isOptionEqual(option, selectedOption));
    } else {
      return isOptionEqual(option, state.selectedOptions[0]);
    }
  };
  const removeFromSelectedOptions = (selectedOption) => {
    setState("selectedOptions", (prev) => prev.filter((option) => !isOptionEqual(selectedOption, option)));
  };
  const setSelectedOptions = (index) => {
    const newSelectedOption = state.options[index];
    if (state.multiple) {
      if (isOptionSelected(newSelectedOption)) {
        removeFromSelectedOptions(newSelectedOption);
      } else {
        setState("selectedOptions", (prev) => [...prev, newSelectedOption]);
      }
    } else {
      setState("selectedOptions", [newSelectedOption]);
    }
  };
  const getSelectedValue = () => {
    var _a;
    if (state.multiple) {
      return state.selectedOptions.map((item) => item.value);
    } else {
      return (_a = state.selectedOptions[0].value) != null ? _a : void 0;
    }
  };
  const selectOption = (index) => {
    var _a;
    onOptionChange(index);
    setSelectedOptions(index);
    (_a = props.onChange) == null ? void 0 : _a.call(props, getSelectedValue());
  };
  const unselectOption = (selectedOption) => {
    var _a;
    removeFromSelectedOptions(selectedOption);
    (_a = props.onChange) == null ? void 0 : _a.call(props, getSelectedValue());
    focusTrigger();
  };
  const isOptionDisabledCallback = (index) => {
    return state.options[index].disabled;
  };
  const onTriggerBlur = (event) => {
    if (contains2(triggerRef, getRelatedTarget(event))) {
      return;
    }
    if (state.ignoreBlur) {
      setState("ignoreBlur", false);
      return;
    }
    if (state.opened) {
      updateOpeningState(false, false);
    }
  };
  const onTriggerClick = () => {
    if (formControlProps.readOnly) {
      return;
    }
    updateOpeningState(!state.opened, false);
  };
  const onTriggerKeyDown = (event) => {
    if (formControlProps.readOnly) {
      return;
    }
    const {
      key
    } = event;
    if (state.hasSelectedOptions && state.multiple && key === "Backspace") {
      unselectOption(state.selectedOptions[state.selectedOptions.length - 1]);
      return;
    }
    const max3 = state.options.length - 1;
    const action = getActionFromKey(event, state.opened);
    switch (action) {
      case SelectActions.Last:
      case SelectActions.First:
        updateOpeningState(true);
      case SelectActions.Next:
      case SelectActions.Previous:
        event.preventDefault();
        return onOptionChange(getUpdatedIndex({
          currentIndex: state.activeIndex,
          maxIndex: max3,
          initialAction: action,
          isOptionDisabled: isOptionDisabledCallback
        }));
      case SelectActions.SelectAndClose:
        event.preventDefault();
        selectOption(state.activeIndex);
        return state.multiple ? void 0 : updateOpeningState(false);
      case SelectActions.Close:
        event.preventDefault();
        return updateOpeningState(false);
      case SelectActions.Type:
        return onTriggerType(key);
      case SelectActions.Open:
        event.preventDefault();
        return updateOpeningState(true);
    }
  };
  const onTriggerType = (letter) => {
    if (formControlProps.readOnly) {
      return;
    }
    updateOpeningState(true);
    const searchString = getSearchString(letter);
    const searchIndex = getIndexByLetter(state.options, searchString, state.activeIndex + 1);
    if (searchIndex >= 0) {
      onOptionChange(searchIndex);
    } else {
      window.clearTimeout(state.searchTimeoutId);
      setState("searchString", "");
    }
  };
  const onOptionClick = (index) => {
    if (state.options[index].disabled) {
      focusTrigger();
      return;
    }
    selectOption(index);
    if (state.multiple) {
      focusTrigger();
    } else {
      updateOpeningState(false);
    }
  };
  const onOptionMouseMove = (index) => {
    if (state.activeIndex === index) {
      return;
    }
    onOptionChange(index);
  };
  const onOptionMouseDown = () => {
    setState("ignoreBlur", true);
  };
  const setDefaultActiveOption = () => {
    if (state.selectedOptions.length > 0) {
      setState("activeIndex", state.options.findIndex((option) => isOptionSelected(option)));
    } else {
      setState("activeIndex", 0);
    }
  };
  const scheduleContentPositionAutoUpdate = () => {
    if (state.opened) {
      updateContentPosition();
      if (triggerRef && contentRef) {
        cleanupContentAutoUpdate = autoUpdate(triggerRef, contentRef, updateContentPosition);
      }
    } else {
      cleanupContentAutoUpdate == null ? void 0 : cleanupContentAutoUpdate();
    }
  };
  const updateOpeningState = (opened, callFocus = true) => {
    if (state.opened === opened) {
      return;
    }
    setState("opened", opened);
    setDefaultActiveOption();
    scheduleContentPositionAutoUpdate();
    callFocus && focusTrigger();
  };
  const onListboxMouseLeave = () => {
    onOptionChange(-1);
  };
  const onContentClickOutside = (target) => {
    if (contains2(triggerRef, target)) {
      return;
    }
    updateOpeningState(false, false);
  };
  const isOptionActiveDescendant = (index) => {
    return index === state.activeIndex;
  };
  const assignTriggerRef = (el) => {
    triggerRef = el;
  };
  const assignContentRef = (el) => {
    contentRef = el;
  };
  const assignListboxRef = (el) => {
    listboxRef = el;
  };
  const scrollToOption = (optionRef) => {
    if (!listboxRef) {
      return;
    }
    if (isScrollable(listboxRef)) {
      maintainScrollVisibility(optionRef, listboxRef);
    }
  };
  const registerOption = (optionData) => {
    const index = state.options.findIndex((option) => isOptionEqual(option, optionData));
    if (index != -1) {
      return index;
    }
    const updatedOptions = _setOptions((prev) => [...prev, optionData]);
    return updatedOptions.length - 1;
  };
  createEffect(on(() => state.options, () => initSelectedOptions(), {
    defer: true
  }));
  createEffect(on(() => props.value, () => {
    if (!state.isControlled) {
      return;
    }
    const controlledValues = isArray(props.value) ? props.value : [props.value];
    const selectedOptions = controlledValues.map((value) => state.options.find((option) => option.value === value)).filter(Boolean);
    setState("selectedOptions", selectedOptions);
  }, {
    defer: true
  }));
  createEffect(on(() => state.opened, (newValue) => {
    if (!newValue) {
      return;
    }
    setTimeout(() => {
      const firstSelectedOption = listboxRef == null ? void 0 : listboxRef.querySelector("[role='option'][aria-selected='true']");
      if (firstSelectedOption) {
        scrollToOption(firstSelectedOption);
      }
    }, 0);
  }));
  const context = {
    state,
    isOptionSelected,
    unselectOption,
    isOptionActiveDescendant,
    formControlProps,
    assignTriggerRef,
    assignContentRef,
    assignListboxRef,
    registerOption,
    scrollToOption,
    onContentClickOutside,
    onTriggerBlur,
    onTriggerClick,
    onTriggerKeyDown,
    onOptionClick,
    onOptionMouseMove,
    onOptionMouseDown,
    onListboxMouseLeave
  };
  return createComponent(SelectContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}
var SelectContext = createContext();
function useSelectContext() {
  const context = useContext(SelectContext);
  if (!context) {
    throw new Error("[Hope UI]: useSelectContext must be used within a `<Select />` component");
  }
  return context;
}
var hopeSelectContentClass = "hope-select__content";
function SelectContent(props) {
  const theme = useStyleConfig().Select;
  const selectContext = useSelectContext();
  const [local, others] = splitProps(props, ["ref", "class", "children"]);
  const [isPortalMounted, setIsPortalMounted] = createSignal(false);
  createEffect(on(() => selectContext.state.opened, () => {
    if (selectContext.state.opened) {
      setIsPortalMounted(true);
    } else {
      selectContext.state.motionPreset === "none" && setIsPortalMounted(false);
    }
  }));
  const unmountPortal = () => setIsPortalMounted(false);
  const classes = () => classNames(local.class, hopeSelectContentClass, selectContentStyles());
  const resolvedChildren = children(() => local.children);
  const assignContentRef = (el) => {
    selectContext.assignContentRef(el);
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const onClickOutside = (event) => {
    selectContext.onContentClickOutside(event.target);
  };
  const transitionName = () => {
    switch (selectContext.state.motionPreset) {
      case "fade-in-top":
        return selectTransitionName.fadeInTop;
      case "none":
        return "hope-none";
    }
  };
  return createComponent(Show, {
    get when() {
      return isPortalMounted();
    },
    get children() {
      return createComponent(Portal, {
        get children() {
          return createComponent(Transition, {
            get name() {
              return transitionName();
            },
            appear: true,
            onAfterExit: unmountPortal,
            get children() {
              return createComponent(Show, {
                get when() {
                  return selectContext.state.opened;
                },
                get children() {
                  return createComponent(ClickOutside, {
                    onClickOutside,
                    get children() {
                      return createComponent(Box, mergeProps({
                        ref: assignContentRef,
                        get ["class"]() {
                          return classes();
                        },
                        get __baseStyle() {
                          var _a;
                          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.content;
                        }
                      }, others, {
                        get children() {
                          return resolvedChildren();
                        }
                      }));
                    }
                  });
                }
              });
            }
          });
        }
      });
    }
  });
}
SelectContent.toString = () => createClassSelector(hopeSelectContentClass);
var _tmpl$$5 = template(`<svg><path d="M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg>`, 4, true);
var IconSelector = createIcon({
  viewBox: "0 0 15 15",
  path: () => _tmpl$$5.cloneNode(true)
});
var hopeSelectIconClass = "hope-select__icon";
function SelectIcon(props) {
  const theme = useStyleConfig().Select;
  const selectContext = useSelectContext();
  const [local, others] = splitProps(props, ["class", "rotateOnOpen"]);
  const classes = () => {
    return classNames(local.class, hopeSelectIconClass, selectIconStyles(local.rotateOnOpen ? {
      opened: selectContext.state.opened
    } : void 0));
  };
  return createComponent(IconSelector, mergeProps({
    "aria-hidden": true,
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.icon;
    }
  }, others));
}
SelectIcon.toString = () => createClassSelector(hopeSelectIconClass);
var SelectOptGroupContext = createContext();
var hopeSelectOptGroupClass = "hope-select__optgroup";
function SelectOptGroup(props) {
  const theme = useStyleConfig().Select;
  const [ariaLabelledBy, setAriaLabelledBy] = createSignal();
  const [local, others] = splitProps(props, ["class", "children"]);
  const classes = () => classNames(local.class, hopeSelectOptGroupClass, selectOptGroupStyles());
  const context = {
    setAriaLabelledBy
  };
  return createComponent(SelectOptGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        role: "group",
        get ["aria-labelledby"]() {
          return ariaLabelledBy();
        },
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.optgroup;
        }
      }, others, {
        get children() {
          return local.children;
        }
      }));
    }
  });
}
SelectOptGroup.toString = () => createClassSelector(hopeSelectOptGroupClass);
function useSelectOptGroupContext() {
  return useContext(SelectOptGroupContext);
}
var hopeSelectLabelClass = "hope-select__label";
function SelectLabel(props) {
  const defaultIdSuffix = createUniqueId();
  const theme = useStyleConfig().Select;
  const selectContext = useSelectContext();
  const selectOptGroupContext = useSelectOptGroupContext();
  const [local, others] = splitProps(props, ["class", "id"]);
  const id = () => {
    var _a;
    return (_a = local.id) != null ? _a : `${selectContext.state.labelIdPrefix}-${defaultIdSuffix}`;
  };
  const classes = () => classNames(local.class, hopeSelectLabelClass, selectLabelStyles());
  onMount(() => {
    selectOptGroupContext == null ? void 0 : selectOptGroupContext.setAriaLabelledBy(id());
  });
  return createComponent(Box, mergeProps({
    get id() {
      return id();
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.label;
    }
  }, others));
}
SelectLabel.toString = () => createClassSelector(hopeSelectLabelClass);
var hopeSelectListboxClass = "hope-select__listbox";
function SelectListbox(props) {
  const theme = useStyleConfig().Select;
  const selectContext = useSelectContext();
  const [local, others] = splitProps(props, ["ref", "class"]);
  const classes = () => classNames(local.class, hopeSelectListboxClass, selectListboxStyles());
  const assignListboxRef = (el) => {
    selectContext.assignListboxRef(el);
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const onMouseDown = (event) => {
    event.preventDefault();
  };
  return createComponent(Box, mergeProps({
    ref: assignListboxRef,
    role: "listbox",
    tabindex: "-1",
    get id() {
      return selectContext.state.listboxId;
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.listbox;
    },
    get onMouseLeave() {
      return selectContext.onListboxMouseLeave;
    },
    onMouseDown
  }, others));
}
SelectListbox.toString = () => createClassSelector(hopeSelectListboxClass);
var SelectOptionContext = createContext();
var hopeSelectOptionClass = "hope-select__option";
function SelectOption(props) {
  const theme = useStyleConfig().Select;
  const selectContext = useSelectContext();
  const [index, setIndex] = createSignal(-1);
  let optionRef;
  const [local, others] = splitProps(props, ["ref", "class", "value", "textValue", "disabled"]);
  const optionData = () => {
    var _a, _b;
    return {
      value: local.value,
      textValue: (_b = (_a = local.textValue) != null ? _a : optionRef == null ? void 0 : optionRef.textContent) != null ? _b : String(local.value),
      disabled: !!local.disabled
    };
  };
  const id = () => `${selectContext.state.optionIdPrefix}-${index()}`;
  const isSelected = () => selectContext.isOptionSelected(optionData());
  const isActiveDescendant = () => selectContext.isOptionActiveDescendant(index());
  const classes = () => {
    return classNames(local.class, hopeSelectOptionClass, selectOptionStyles());
  };
  const assignOptionRef = (el) => {
    optionRef = el;
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const onOptionClick = (event) => {
    event.stopPropagation();
    selectContext.onOptionClick(index());
  };
  const onOptionMouseMove = (event) => {
    if (local.disabled) {
      selectContext.onOptionMouseMove(-1);
    }
    if (isActiveDescendant() || local.disabled) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    selectContext.onOptionMouseMove(index());
  };
  const context = {
    selected: isSelected
  };
  onMount(() => {
    setIndex(selectContext.registerOption(optionData()));
  });
  createEffect(() => {
    if (isActiveDescendant() && optionRef) {
      selectContext.scrollToOption(optionRef);
    }
  });
  return createComponent(SelectOptionContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        ref: assignOptionRef,
        role: "option",
        get id() {
          return id();
        },
        get ["aria-selected"]() {
          return isSelected();
        },
        get ["data-active"]() {
          return isActiveDescendant() ? "" : void 0;
        },
        get ["data-disabled"]() {
          return local.disabled ? "" : void 0;
        },
        "data-group": true,
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.option;
        },
        onClick: onOptionClick,
        onMouseMove: onOptionMouseMove,
        get onMouseDown() {
          return selectContext.onOptionMouseDown;
        }
      }, others));
    }
  });
}
SelectOption.toString = () => createClassSelector(hopeSelectOptionClass);
function useSelectOptionContext() {
  const context = useContext(SelectOptionContext);
  if (!context) {
    throw new Error("[Hope UI]: useSelectOptionContext must be used within a `<Select.Option />` component");
  }
  return context;
}
var _tmpl$$4 = template(`<svg><g fill="none"><path d="M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></g></svg>`, 6, true);
var IconCheck = createIcon({
  viewBox: "0 0 15 15",
  path: () => _tmpl$$4.cloneNode(true)
});
var hopeSelectOptionIndicatorClass = "hope-select__option-indicator";
function SelectOptionIndicator(props) {
  const theme = useStyleConfig().Select;
  const selectOptionContext = useSelectOptionContext();
  const [local, others] = splitProps(props, ["class", "children"]);
  const classes = () => classNames(local.class, hopeSelectOptionIndicatorClass, selectOptionIndicatorStyles());
  return createComponent(Show, {
    get when() {
      return selectOptionContext.selected();
    },
    get children() {
      return createComponent(hope.span, mergeProps({
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.optionIndicator;
        }
      }, others, {
        get children() {
          return createComponent(Show, {
            get when() {
              return local.children;
            },
            get fallback() {
              return createComponent(IconCheck, {
                "aria-hidden": "true",
                boxSize: "$5"
              });
            },
            get children() {
              return local.children;
            }
          });
        }
      }));
    }
  });
}
SelectOptionIndicator.toString = () => createClassSelector(hopeSelectOptionIndicatorClass);
var hopeSelectOptionTextClass = "hope-select__option-text";
function SelectOptionText(props) {
  const theme = useStyleConfig().Select;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeSelectOptionTextClass, selectOptionTextStyles());
  return createComponent(hope.span, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.optionText;
    }
  }, others));
}
SelectOptionText.toString = () => createClassSelector(hopeSelectOptionTextClass);
var hopeSelectPlaceholderClass = "hope-select__placeholder";
function SelectPlaceholder(props) {
  const theme = useStyleConfig().Select;
  const selectContext = useSelectContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeSelectPlaceholderClass, selectPlaceholderStyles());
  return createComponent(Show, {
    get when() {
      return !selectContext.state.hasSelectedOptions;
    },
    get children() {
      return createComponent(hope.span, mergeProps({
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.placeholder;
        }
      }, others));
    }
  });
}
SelectPlaceholder.toString = () => createClassSelector(hopeSelectPlaceholderClass);
var hopeSelectTagClass = "hope-select__tag";
function SelectTag(props) {
  const theme = useStyleConfig().Select;
  const selectContext = useSelectContext();
  const [local, others] = splitProps(props, ["class", "size", "variant"]);
  const classes = () => {
    var _a, _b, _c;
    return classNames(local.class, hopeSelectTagClass, selectTagStyles({
      size: (_b = (_a = local.size) != null ? _a : selectContext.state.size) != null ? _b : "md",
      variant: ((_c = local.variant) != null ? _c : selectContext.state.variant === "filled") ? "outline" : "subtle"
    }));
  };
  return createComponent(hope.span, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.tag;
    }
  }, others));
}
SelectTag.toString = () => createClassSelector(hopeSelectTagClass);
var _tmpl$$3 = template(`<svg><g fill="none"><path d="M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></g></svg>`, 6, true);
var IconCloseSmall = createIcon({
  viewBox: "0 0 15 15",
  path: () => _tmpl$$3.cloneNode(true)
});
var hopeSelectTagCloseButtonClass = "hope-select__tag-close-button";
function SelectTagCloseButton(props) {
  const theme = useStyleConfig().Select;
  const [local, others] = splitProps(props, ["class", "children"]);
  const classes = () => classNames(local.class, hopeSelectTagCloseButtonClass, selectTagCloseButtonStyles());
  return createComponent(hope.button, mergeProps({
    role: "button",
    type: "button",
    "aria-label": "Delete",
    tabIndex: "-1",
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.tagCloseButton;
    }
  }, others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return local.children;
        },
        get fallback() {
          return createComponent(IconCloseSmall, {});
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
SelectTagCloseButton.toString = () => createClassSelector(hopeSelectTagCloseButtonClass);
var hopeSelectTriggerClass = "hope-select__trigger";
function SelectTrigger(props) {
  const theme = useStyleConfig().Select;
  const selectContext = useSelectContext();
  const [local, others] = splitProps(props, ["ref", "class", "onClick", "onKeyDown", "onFocus", "onBlur"]);
  const classes = () => {
    return classNames(local.class, hopeSelectTriggerClass, selectTriggerStyles({
      variant: selectContext.state.variant,
      size: selectContext.state.size
    }));
  };
  const assignTriggerRef = (el) => {
    selectContext.assignTriggerRef(el);
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const onClick = (event) => {
    chainHandlers(selectContext.onTriggerClick, local.onClick)(event);
  };
  const onKeyDown = (event) => {
    chainHandlers(selectContext.onTriggerKeyDown, local.onKeyDown)(event);
  };
  const onFocus = (event) => {
    chainHandlers(selectContext.formControlProps.onFocus, local.onFocus)(event);
  };
  const onBlur = (event) => {
    chainHandlers(selectContext.onTriggerBlur, selectContext.formControlProps.onBlur, local.onBlur)(event);
  };
  return createComponent(hope.button, mergeProps({
    ref: assignTriggerRef,
    get id() {
      return selectContext.state.triggerId;
    },
    get disabled() {
      return selectContext.state.disabled;
    },
    role: "combobox",
    type: "button",
    tabindex: "0",
    "aria-haspopup": "listbox",
    get ["aria-activedescendant"]() {
      return selectContext.state.activeDescendantId;
    },
    get ["aria-controls"]() {
      return selectContext.state.listboxId;
    },
    get ["aria-expanded"]() {
      return selectContext.state.opened;
    },
    get ["aria-required"]() {
      return selectContext.formControlProps["aria-required"];
    },
    get ["aria-invalid"]() {
      return selectContext.formControlProps["aria-invalid"];
    },
    get ["aria-readonly"]() {
      return selectContext.formControlProps["aria-readonly"];
    },
    get ["aria-describedby"]() {
      return selectContext.formControlProps["aria-describedby"];
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.trigger;
    },
    onClick,
    onKeyDown,
    onFocus,
    onBlur
  }, others));
}
SelectTrigger.toString = () => createClassSelector(hopeSelectTriggerClass);
var _tmpl$$2 = template(`<span></span>`, 2);
var hopeSelectValueClass = "hope-select__value";
function SelectValue(props) {
  const theme = useStyleConfig().Select;
  const selectContext = useSelectContext();
  const [local, others] = splitProps(props, ["class", "children"]);
  const singleValueClasses = () => classNames(local.class, hopeSelectValueClass, selectSingleValueStyles());
  const multiValueClasses = () => {
    return classNames(local.class, hopeSelectValueClass, selectMultiValueStyles({
      size: selectContext.state.size
    }));
  };
  const onTagCloseButtonClick = (event, option) => {
    event.preventDefault();
    event.stopPropagation();
    selectContext.unselectOption(option);
  };
  const resolvedChildren = children(() => {
    var _a;
    if (isChildrenFunction(local)) {
      return (_a = local.children) == null ? void 0 : _a.call(local, {
        selectedOptions: selectContext.state.selectedOptions
      });
    }
    return local.children;
  });
  return createComponent(Show, {
    get when() {
      return selectContext.state.hasSelectedOptions;
    },
    get children() {
      return createComponent(Show, {
        get when() {
          return !resolvedChildren();
        },
        get fallback() {
          return resolvedChildren();
        },
        get children() {
          return createComponent(Show, {
            get when() {
              return selectContext.state.multiple;
            },
            get fallback() {
              return createComponent(Box, mergeProps({
                get ["class"]() {
                  return singleValueClasses();
                },
                get __baseStyle() {
                  var _a;
                  return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.singleValue;
                }
              }, others, {
                get children() {
                  return selectContext.state.selectedOptions[0].textValue;
                }
              }));
            },
            get children() {
              return createComponent(Box, mergeProps({
                get ["class"]() {
                  return multiValueClasses();
                },
                get __baseStyle() {
                  var _a;
                  return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.multiValue;
                }
              }, others, {
                get children() {
                  return createComponent(For, {
                    get each() {
                      return selectContext.state.selectedOptions;
                    },
                    children: (option) => createComponent(SelectTag, {
                      get children() {
                        return [(() => {
                          const _el$ = _tmpl$$2.cloneNode(true);
                          insert(_el$, () => option.textValue);
                          return _el$;
                        })(), createComponent(SelectTagCloseButton, {
                          onClick: (e) => onTagCloseButtonClick(e, option)
                        })];
                      }
                    })
                  });
                }
              }));
            }
          });
        }
      });
    }
  });
}
SelectValue.toString = () => createClassSelector(hopeSelectValueClass);
function SimpleOption(props) {
  const [local, others] = splitProps(props, ["children", "value"]);
  return createComponent(SelectOption, mergeProps({
    get value() {
      return local.value;
    }
  }, others, {
    get children() {
      return [createComponent(SelectOptionText, {
        get children() {
          return local.children;
        }
      }), createComponent(SelectOptionIndicator, {})];
    }
  }));
}
function SimpleSelect(props) {
  const [local, selectProps, others] = splitProps(props, ["children", "placeholder"], ["variant", "size", "offset", "id", "multiple", "value", "defaultValue", "required", "disabled", "invalid", "readOnly", "onChange", "onFocus", "onBlur"]);
  return createComponent(Select, mergeProps(selectProps, {
    get children() {
      return [createComponent(SelectTrigger, mergeProps(others, {
        get children() {
          return [createComponent(Show, {
            get when() {
              return local.placeholder;
            },
            get children() {
              return createComponent(SelectPlaceholder, {
                get children() {
                  return local.placeholder;
                }
              });
            }
          }), createComponent(SelectValue, {}), createComponent(SelectIcon, {})];
        }
      })), createComponent(SelectContent, {
        get children() {
          return createComponent(SelectListbox, {
            get children() {
              return local.children;
            }
          });
        }
      })];
    }
  }));
}
var skeletonColorFade = keyframes({
  from: {
    borderColor: "$$startColor",
    background: "$$startColor"
  },
  to: {
    borderColor: "$$endColor",
    background: "$$endColor"
  }
});
var skeletonStyles = css({
  $$startColor: "$colors$neutral2",
  $$endColor: "$colors$neutral8",
  opacity: "0.7",
  borderRadius: "2px",
  borderColor: "$$startColor",
  boxShadow: "$none",
  background: "$$endColor",
  backgroundClip: "padding-box",
  color: "transparent",
  cursor: "default",
  pointerEvents: "none",
  userSelect: "none",
  animationTimingFunction: "linear",
  animationIterationCount: "infinite",
  animationDirection: "alternate",
  animationName: `${skeletonColorFade()}`,
  "&::before, &::after, *": {
    visibility: "hidden"
  }
});
var hopeSkeletonClass = "hope-skeleton";
function Skeleton(props) {
  const [loadedAnimation, setLoadedAnimation] = createSignal("none");
  const defaultProps = {
    speed: "800ms",
    fadeDuration: "400ms"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "startColor", "endColor", "loaded", "speed", "fadeDuration"]);
  const skeletonClasses = () => {
    var _a, _b;
    return classNames(local.class, hopeSkeletonClass, local.loaded ? void 0 : skeletonStyles({
      css: {
        $$startColor: colorTokenToCssVar((_a = local.startColor) != null ? _a : "$neutral2"),
        $$endColor: colorTokenToCssVar((_b = local.endColor) != null ? _b : "$neutral8"),
        animationDuration: local.speed
      }
    }));
  };
  createEffect(on(() => local.loaded, (_, prev) => setLoadedAnimation(prev === true ? "none" : `${fadeIn()} ${local.fadeDuration}`), {
    defer: true
  }));
  return createComponent(Show, {
    get when() {
      return local.loaded;
    },
    get fallback() {
      return createComponent(Box, mergeProps({
        get ["class"]() {
          return skeletonClasses();
        }
      }, others));
    },
    get children() {
      return createComponent(Box, mergeProps({
        get ["class"]() {
          return skeletonClasses();
        },
        get animation() {
          return loadedAnimation();
        }
      }, others));
    }
  });
}
Skeleton.toString = () => createClassSelector(hopeSkeletonClass);
function SkeletonCircle(props) {
  return createComponent(Skeleton, mergeProps({
    borderRadius: "$full",
    get boxSize() {
      var _a;
      return (_a = props.size) != null ? _a : "2rem";
    }
  }, props));
}
SkeletonCircle.toString = () => createClassSelector(hopeSkeletonClass);
function SkeletonText(props) {
  const defaultProps = {
    noOfLines: 3,
    spacing: "0.5rem",
    skeletonHeight: "0.5rem"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, skeletonProps, others] = splitProps(propsWithDefault, ["class", "children", "noOfLines", "spacing", "skeletonHeight"], ["startColor", "endColor", "loaded", "speed", "fadeDuration", "borderRadius", "rounded"]);
  const noOfLines = () => {
    var _a;
    return (_a = local.noOfLines) != null ? _a : 3;
  };
  const numbers = createMemo(() => range(noOfLines()));
  const getWidth = (index) => {
    if (noOfLines() > 1) {
      return index === numbers().length - 1 ? "80%" : "100%";
    }
    return "100%";
  };
  const classes = () => {
    return classNames(local.class, "hope-skeleton__group");
  };
  return createComponent(Show, {
    get when() {
      return skeletonProps.loaded;
    },
    get fallback() {
      return createComponent(Box, mergeProps({
        get ["class"]() {
          return classes();
        },
        d: "flex",
        flexDirection: "column",
        get gap() {
          return local.spacing;
        }
      }, others, {
        get children() {
          return createComponent(Index, {
            get each() {
              return numbers();
            },
            children: (_, index) => createComponent(Skeleton, mergeProps({
              get width() {
                return getWidth(index);
              },
              get height() {
                return local.skeletonHeight;
              }
            }, skeletonProps))
          });
        }
      }));
    },
    get children() {
      return createComponent(Skeleton, mergeProps({
        get ["class"]() {
          return local.class;
        }
      }, skeletonProps, others, {
        get children() {
          return local.children;
        }
      }));
    }
  });
}
SkeletonText.toString = () => createClassSelector(hopeSkeletonClass);
var spacerStyles = css({
  flex: 1,
  justifySelf: "stretch",
  alignSelf: "stretch"
});
var hopeSpacerClass = "hope-spacer";
function Spacer(props) {
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeSpacerClass, spacerStyles());
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    }
  }, others));
}
Spacer.toString = () => createClassSelector(hopeSpacerClass);
var spinnerStyles = css({
  display: "inline-block",
  borderColor: "currentColor",
  borderStyle: "solid",
  borderRadius: "$full",
  borderWidth: "2px",
  borderBottomColor: "transparent",
  borderLeftColor: "transparent",
  animationName: `${spin}`,
  animationDuration: "0.45s",
  animationTimingFunction: "linear",
  animationIterationCount: "infinite",
  variants: {
    size: {
      xs: {
        boxSize: "0.75rem"
      },
      sm: {
        boxSize: "1rem"
      },
      md: {
        boxSize: "1.5rem"
      },
      lg: {
        boxSize: "2rem"
      },
      xl: {
        boxSize: "3rem"
      }
    }
  }
});
var _tmpl$$1 = template(`<span></span>`, 2);
var hopeSpinnerClass = "hope-spinner";
function Spinner(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const theme = useStyleConfig().Spinner;
  const defaultProps = {
    label: (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.label) != null ? _b : "Loading...",
    size: (_d = (_c = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _c.size) != null ? _d : "md",
    emptyColor: (_e = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _e.emptyColor,
    color: (_f = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _f.color,
    thickness: (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.thickness,
    speed: (_h = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _h.speed
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "children", "label", "size", "emptyColor", "color", "thickness", "speed"]);
  const classes = () => classNames(local.class, hopeSpinnerClass, spinnerStyles({
    size: local.size,
    css: {
      color: local.color,
      borderWidth: local.thickness,
      borderBottomColor: local.emptyColor,
      borderLeftColor: local.emptyColor,
      animationDuration: local.speed
    }
  }));
  return createComponent(Box, mergeProps({
    get ["class"]() {
      return classes();
    }
  }, others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return local.label;
        },
        get children() {
          const _el$ = _tmpl$$1.cloneNode(true);
          insert(_el$, () => local.label);
          createRenderEffect(() => _el$.className = visuallyHiddenStyles());
          return _el$;
        }
      });
    }
  }));
}
Spinner.toString = () => createClassSelector(hopeSpinnerClass);
var switchWrapperStyles = css(toggleWrapperStyles, {
  variants: {
    labelPlacement: {
      start: {
        flexDirection: "row"
      },
      end: {
        flexDirection: "row-reverse"
      }
    }
  }
});
var switchLabelStyles = css(toggleControlLabelStyles);
var switchControlStyles = css(toggleControlStyles, {
  borderRadius: "$full",
  transition: "background-color 250ms, border-color 250ms, box-shadow 250ms",
  "&::before": {
    content: "''",
    position: "absolute",
    top: "2px",
    left: "2px",
    zIndex: "1",
    borderRadius: "$full",
    boxShadow: "$sm",
    transition: "250ms"
  },
  variants: {
    variant: {
      outline: {
        "&::before": {
          backgroundColor: "$neutral7"
        },
        "&[data-checked]::before": {
          backgroundColor: "$loContrast"
        }
      },
      filled: {
        "&::before": {
          backgroundColor: "$loContrast"
        }
      }
    },
    size: {
      sm: {
        height: "16px",
        width: "26px",
        "&::before": {
          boxSize: "10px"
        },
        "&[data-checked]::before": {
          transform: "translateX(10px)"
        }
      },
      md: {
        columnGap: "2px",
        height: "20px",
        width: "34px",
        "&::before": {
          boxSize: "14px"
        },
        "&[data-checked]::before": {
          transform: "translateX(14px)"
        }
      },
      lg: {
        columnGap: "4px",
        height: "28px",
        width: "50px",
        "&::before": {
          boxSize: "22px"
        },
        "&[data-checked]::before": {
          transform: "translateX(22px)"
        }
      }
    }
  }
});
var _tmpl$ = template(`<input type="checkbox" role="switch">`, 1);
function SwitchPrimitive(props) {
  const defaultId = `hope-switch-${createUniqueId()}`;
  const formControlProps = useFormControl(props);
  const [state, setState] = createStore({
    _checked: !!props.defaultChecked,
    isFocused: false,
    get isControlled() {
      return props.checked !== void 0;
    },
    get checked() {
      return this.isControlled ? !!props.checked : this._checked;
    },
    get id() {
      var _a;
      return (_a = formControlProps.id) != null ? _a : defaultId;
    },
    get name() {
      return props.name;
    },
    get value() {
      return props.value;
    },
    get required() {
      return formControlProps.required;
    },
    get disabled() {
      return formControlProps.disabled;
    },
    get invalid() {
      return formControlProps.invalid;
    },
    get readOnly() {
      return formControlProps.readOnly;
    },
    get ["aria-required"]() {
      return this.required ? true : void 0;
    },
    get ["aria-disabled"]() {
      return this.disabled ? true : void 0;
    },
    get ["aria-invalid"]() {
      return this.invalid ? true : void 0;
    },
    get ["aria-readonly"]() {
      return this.readOnly ? true : void 0;
    },
    get ["data-focus"]() {
      return this.isFocused ? "" : void 0;
    },
    get ["data-checked"]() {
      return this.checked ? "" : void 0;
    },
    get ["data-required"]() {
      return this.required ? "" : void 0;
    },
    get ["data-disabled"]() {
      return this.disabled ? "" : void 0;
    },
    get ["data-invalid"]() {
      return this.invalid ? "" : void 0;
    },
    get ["data-readonly"]() {
      return this.readOnly ? "" : void 0;
    }
  });
  const [local, _, others] = splitProps(props, ["inputClass", "children", "ref", "tabIndex", "aria-label", "aria-labelledby", "aria-describedby", "onChange"], ["id", "name", "value", "checked", "defaultChecked", "required", "disabled", "invalid", "readOnly", "onFocus", "onBlur"]);
  const onChange = (event) => {
    if (state.readOnly || state.disabled) {
      event.preventDefault();
      return;
    }
    if (!state.isControlled) {
      const target = event.target;
      setState("_checked", target.checked);
    }
    callHandler(local.onChange, event);
  };
  const onFocus = (event) => {
    setState("isFocused", true);
    callHandler(formControlProps.onFocus, event);
  };
  const onBlur = (event) => {
    setState("isFocused", false);
    callHandler(formControlProps.onBlur, event);
  };
  const inputClasses = () => classNames(local.inputClass, visuallyHiddenStyles());
  const stateAccessor = () => state;
  const context = {
    state
  };
  return createComponent(SwitchPrimitiveContext.Provider, {
    value: context,
    get children() {
      return createComponent(hope.label, mergeProps({
        get ["for"]() {
          return state.id;
        },
        "data-group": true,
        get ["data-focus"]() {
          return state["data-focus"];
        },
        get ["data-checked"]() {
          return state["data-checked"];
        },
        get ["data-required"]() {
          return state["data-required"];
        },
        get ["data-disabled"]() {
          return state["data-disabled"];
        },
        get ["data-invalid"]() {
          return state["data-invalid"];
        },
        get ["data-readonly"]() {
          return state["data-readonly"];
        }
      }, others, {
        get children() {
          return [(() => {
            const _el$ = _tmpl$.cloneNode(true);
            _el$.addEventListener("blur", onBlur);
            _el$.addEventListener("focus", onFocus);
            _el$.addEventListener("change", onChange);
            const _ref$ = local.ref;
            typeof _ref$ === "function" ? _ref$(_el$) : local.ref = _el$;
            createRenderEffect((_p$) => {
              const _v$ = inputClasses(), _v$2 = local.tabIndex, _v$3 = state.value, _v$4 = state.id, _v$5 = state.name, _v$6 = state.checked, _v$7 = state.required, _v$8 = state.disabled, _v$9 = state.readOnly, _v$10 = state["aria-required"], _v$11 = state["aria-disabled"], _v$12 = state["aria-invalid"], _v$13 = state["aria-readonly"], _v$14 = local["aria-label"], _v$15 = local["aria-labelledby"], _v$16 = local["aria-describedby"];
              _v$ !== _p$._v$ && (_el$.className = _p$._v$ = _v$);
              _v$2 !== _p$._v$2 && setAttribute(_el$, "tabindex", _p$._v$2 = _v$2);
              _v$3 !== _p$._v$3 && (_el$.value = _p$._v$3 = _v$3);
              _v$4 !== _p$._v$4 && setAttribute(_el$, "id", _p$._v$4 = _v$4);
              _v$5 !== _p$._v$5 && setAttribute(_el$, "name", _p$._v$5 = _v$5);
              _v$6 !== _p$._v$6 && (_el$.checked = _p$._v$6 = _v$6);
              _v$7 !== _p$._v$7 && (_el$.required = _p$._v$7 = _v$7);
              _v$8 !== _p$._v$8 && (_el$.disabled = _p$._v$8 = _v$8);
              _v$9 !== _p$._v$9 && (_el$.readOnly = _p$._v$9 = _v$9);
              _v$10 !== _p$._v$10 && setAttribute(_el$, "aria-required", _p$._v$10 = _v$10);
              _v$11 !== _p$._v$11 && setAttribute(_el$, "aria-disabled", _p$._v$11 = _v$11);
              _v$12 !== _p$._v$12 && setAttribute(_el$, "aria-invalid", _p$._v$12 = _v$12);
              _v$13 !== _p$._v$13 && setAttribute(_el$, "aria-readonly", _p$._v$13 = _v$13);
              _v$14 !== _p$._v$14 && setAttribute(_el$, "aria-label", _p$._v$14 = _v$14);
              _v$15 !== _p$._v$15 && setAttribute(_el$, "aria-labelledby", _p$._v$15 = _v$15);
              _v$16 !== _p$._v$16 && setAttribute(_el$, "aria-describedby", _p$._v$16 = _v$16);
              return _p$;
            }, {
              _v$: void 0,
              _v$2: void 0,
              _v$3: void 0,
              _v$4: void 0,
              _v$5: void 0,
              _v$6: void 0,
              _v$7: void 0,
              _v$8: void 0,
              _v$9: void 0,
              _v$10: void 0,
              _v$11: void 0,
              _v$12: void 0,
              _v$13: void 0,
              _v$14: void 0,
              _v$15: void 0,
              _v$16: void 0
            });
            return _el$;
          })(), createComponent(Show, {
            get when() {
              return isFunction(local.children);
            },
            get fallback() {
              return local.children;
            },
            get children() {
              var _a;
              return (_a = local.children) == null ? void 0 : _a.call(local, {
                state: stateAccessor
              });
            }
          })];
        }
      }));
    }
  });
}
var SwitchPrimitiveContext = createContext();
function useSwitchPrimitivehContext() {
  const context = useContext(SwitchPrimitiveContext);
  if (!context) {
    throw new Error("[Hope UI]: useSwitchPrimitivehContext must be used within a `<SwitchPrimitive />` component");
  }
  return context;
}
var hopeSwitchClass = "hope-switch";
var hopeSwitchInputClass = "hope-checkbox__input";
var hopeSwitchControlClass = "hope-switch__control";
var hopeSwitchLabelClass = "hope-switch__label";
function Switch2(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const theme = useStyleConfig().Switch;
  const defaultProps = {
    variant: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.variant) != null ? _c : "filled",
    colorScheme: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.root) == null ? void 0 : _e.colorScheme) != null ? _f : "primary",
    size: (_i = (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.root) == null ? void 0 : _h.size) != null ? _i : "md",
    labelPlacement: (_l = (_k = (_j = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _j.root) == null ? void 0 : _k.labelPlacement) != null ? _l : "start"
  };
  const propsWitDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWitDefault, ["children", "class", "variant", "colorScheme", "size", "labelPlacement"]);
  const wrapperClasses = () => {
    return classNames(local.class, hopeSwitchClass, switchWrapperStyles({
      size: local.size,
      labelPlacement: local.labelPlacement
    }));
  };
  const controlClasses = () => {
    return classNames(hopeSwitchControlClass, switchControlStyles({
      variant: local.variant,
      colorScheme: local.colorScheme,
      size: local.size
    }));
  };
  const labelClasses = () => {
    return classNames(hopeSwitchLabelClass, switchLabelStyles());
  };
  return createComponent(SwitchPrimitive, mergeProps({
    get ["class"]() {
      return wrapperClasses();
    },
    inputClass: hopeSwitchInputClass,
    get __baseStyle() {
      var _a2;
      return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.root;
    }
  }, others, {
    children: ({
      state
    }) => [createComponent(hope.span, {
      get ["class"]() {
        return labelClasses();
      },
      get __baseStyle() {
        var _a2;
        return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.label;
      },
      get ["data-focus"]() {
        return state()["data-focus"];
      },
      get ["data-checked"]() {
        return state()["data-checked"];
      },
      get ["data-required"]() {
        return state()["data-required"];
      },
      get ["data-disabled"]() {
        return state()["data-disabled"];
      },
      get ["data-invalid"]() {
        return state()["data-invalid"];
      },
      get ["data-readonly"]() {
        return state()["data-readonly"];
      },
      get children() {
        return local.children;
      }
    }), createComponent(hope.span, {
      "aria-hidden": true,
      get ["class"]() {
        return controlClasses();
      },
      get __baseStyle() {
        var _a2;
        return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.control;
      },
      get ["data-focus"]() {
        return state()["data-focus"];
      },
      get ["data-checked"]() {
        return state()["data-checked"];
      },
      get ["data-required"]() {
        return state()["data-required"];
      },
      get ["data-disabled"]() {
        return state()["data-disabled"];
      },
      get ["data-invalid"]() {
        return state()["data-invalid"];
      },
      get ["data-readonly"]() {
        return state()["data-readonly"];
      }
    })]
  }));
}
Switch2.toString = () => createClassSelector(hopeSwitchClass);
function SwitchPrimitiveThumb(props) {
  const switchPrimitiveContext = useSwitchPrimitivehContext();
  return createComponent(hope.span, mergeProps({
    "aria-hidden": true,
    get ["data-focus"]() {
      return switchPrimitiveContext.state["data-focus"];
    },
    get ["data-checked"]() {
      return switchPrimitiveContext.state["data-checked"];
    },
    get ["data-required"]() {
      return switchPrimitiveContext.state["data-required"];
    },
    get ["data-disabled"]() {
      return switchPrimitiveContext.state["data-disabled"];
    },
    get ["data-invalid"]() {
      return switchPrimitiveContext.state["data-invalid"];
    },
    get ["data-readonly"]() {
      return switchPrimitiveContext.state["data-readonly"];
    }
  }, props));
}
var tableStyles = css({
  width: "100%",
  borderCollapse: "collapse",
  fontVariantNumeric: "lining-nums tabular-nums"
});
var tableCaptionStyles = css({
  px: "$6",
  py: "$4",
  color: "$neutral11",
  fontSize: "$sm",
  fontWeight: "$medium",
  lineHeight: "$5",
  textAlign: "center",
  variants: {
    dense: {
      true: {
        px: "$4",
        py: "$3",
        fontSize: "$xs",
        lineHeight: "$4"
      }
    },
    placement: {
      top: {
        captionSide: "top"
      },
      bottom: {
        captionSide: "bottom"
      }
    }
  }
});
function createStripedStyles(stripedRow) {
  return {
    "& td": {
      borderBottomWidth: 0
    },
    "& tr:last-of-type td": {
      borderBottomWidth: "1px"
    },
    [`& tr:nth-of-type(${stripedRow}) td`]: {
      backgroundColor: "$neutral3"
    }
  };
}
var tableBodyStyles = css({
  variants: {
    striped: {
      odd: createStripedStyles("odd"),
      even: createStripedStyles("even")
    },
    highlightOnHover: {
      true: {
        "& tr:hover td": {
          backgroundColor: "$neutral4"
        }
      }
    }
  },
  compoundVariants: [
    {
      striped: "odd",
      highlightOnHover: true,
      css: {
        "& tr:nth-of-type(odd):hover td": {
          backgroundColor: "$neutral4"
        }
      }
    },
    {
      striped: "even",
      highlightOnHover: true,
      css: {
        "& tr:nth-of-type(even):hover td": {
          backgroundColor: "$neutral4"
        }
      }
    }
  ]
});
var tableFootStyles = css({
  "& tr:last-of-type th": {
    borderBottomWidth: 0
  }
});
var tableColumnHeaderStyles = css({
  borderBottom: "1px solid $colors$neutral6",
  px: "$6",
  py: "$3",
  fontSize: "$xs",
  fontWeight: "$semibold",
  lineHeight: "$4",
  letterSpacing: "$wider",
  textAlign: "start",
  textTransform: "uppercase",
  variants: {
    dense: {
      true: {
        px: "$4",
        py: "$1_5"
      }
    },
    numeric: {
      true: {
        textAlign: "end"
      }
    }
  }
});
var tableCellStyles = css({
  borderBottom: "1px solid $colors$neutral6",
  px: "$6",
  py: "$4",
  fontSize: "$base",
  lineHeight: "$6",
  textAlign: "start",
  transition: "background-color 250ms",
  variants: {
    dense: {
      true: {
        px: "$4",
        py: "$2",
        fontSize: "$sm",
        lineHeight: "$5"
      }
    },
    numeric: {
      true: {
        textAlign: "end"
      }
    }
  }
});
var TableContext = createContext();
var hopeTableClass = "hope-table";
function Table(props) {
  const theme = useStyleConfig().Table;
  const [state] = createStore({
    get striped() {
      var _a, _b, _c;
      return (_c = props.striped) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.striped;
    },
    get dense() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.dense) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.dense) != null ? _d : false;
    },
    get highlightOnHover() {
      var _a, _b, _c, _d;
      return (_d = (_c = props.highlightOnHover) != null ? _c : (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.highlightOnHover) != null ? _d : false;
    }
  });
  const [local, others] = splitProps(props, ["class", "striped", "dense", "highlightOnHover"]);
  const classes = () => classNames(local.class, hopeTableClass, tableStyles(state));
  return createComponent(TableContext.Provider, {
    value: state,
    get children() {
      return createComponent(Box, mergeProps({
        as: "table",
        role: "table",
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a;
          return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.root;
        }
      }, others));
    }
  });
}
Table.toString = () => createClassSelector(hopeTableClass);
function useTableContext() {
  const context = useContext(TableContext);
  if (!context) {
    throw new Error("[Hope UI]: useTableContext must be used within a `<Table/>` component");
  }
  return context;
}
var hopeTableCaptionClass = "hope-table-caption";
function TableCaption(props) {
  var _a, _b, _c;
  const theme = useStyleConfig().Table;
  const tableContext = useTableContext();
  const defaultProps = {
    placement: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.caption) == null ? void 0 : _b.placement) != null ? _c : "bottom"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "placement"]);
  const classes = () => classNames(local.class, hopeTableCaptionClass, tableCaptionStyles({
    dense: tableContext.dense,
    placement: local.placement
  }));
  return createComponent(hope.caption, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a2;
      return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.caption;
    }
  }, others));
}
TableCaption.toString = () => createClassSelector(hopeTableCaptionClass);
var hopeTbodyClass = "hope-tbody";
function Tbody(props) {
  const theme = useStyleConfig().Table;
  const tableContext = useTableContext();
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeTbodyClass, tableBodyStyles({
    striped: tableContext.striped,
    highlightOnHover: tableContext.highlightOnHover
  }));
  return createComponent(Box, mergeProps({
    as: "tbody",
    role: "rowgroup",
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.tbody;
    }
  }, others));
}
Tbody.toString = () => createClassSelector(hopeTbodyClass);
var hopeTdClass = "hope-td";
function Td(props) {
  const theme = useStyleConfig().Table;
  const tableContext = useTableContext();
  const [local, others] = splitProps(props, ["class", "numeric"]);
  const classes = () => classNames(local.class, hopeTdClass, tableCellStyles({
    dense: tableContext.dense,
    numeric: local.numeric
  }));
  return createComponent(Box, mergeProps({
    as: "td",
    role: "cell",
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.td;
    }
  }, others));
}
Td.toString = () => createClassSelector(hopeTdClass);
var hopeTfootClass = "hope-tfoot";
function Tfoot(props) {
  const theme = useStyleConfig().Table;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeTfootClass, tableFootStyles());
  return createComponent(Box, mergeProps({
    as: "tfoot",
    role: "rowgroup",
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.tfoot;
    }
  }, others));
}
Tfoot.toString = () => createClassSelector(hopeTfootClass);
var hopeThClass = "hope-th";
function Th(props) {
  const theme = useStyleConfig().Table;
  const tableContext = useTableContext();
  const [local, others] = splitProps(props, ["class", "numeric"]);
  const classes = () => classNames(local.class, hopeThClass, tableColumnHeaderStyles({
    dense: tableContext.dense,
    numeric: local.numeric
  }));
  return createComponent(Box, mergeProps({
    as: "th",
    role: "columnheader",
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.th;
    }
  }, others));
}
Th.toString = () => createClassSelector(hopeThClass);
var hopeTheadClass = "hope-thead";
function Thead(props) {
  const theme = useStyleConfig().Table;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeTheadClass);
  return createComponent(Box, mergeProps({
    as: "thead",
    role: "rowgroup",
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.thead;
    }
  }, others));
}
Thead.toString = () => createClassSelector(hopeTheadClass);
var hopeTrClass = "hope-tr";
function Tr(props) {
  const theme = useStyleConfig().Table;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeTrClass);
  return createComponent(Box, mergeProps({
    as: "tr",
    role: "row",
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.tr;
    }
  }, others));
}
Tr.toString = () => createClassSelector(hopeTrClass);
var tabsStyles = css({
  variants: {
    orientation: {
      horizontal: {
        display: "block"
      },
      vertical: {
        display: "flex"
      }
    }
  }
});
var tabListStyles = css({
  display: "flex",
  color: "$neutral11",
  fontWeight: "$normal",
  variants: {
    variant: {
      underline: {
        borderWidth: 0,
        borderStyle: "solid",
        borderColor: "$neutral7"
      },
      outline: {
        borderStyle: "solid",
        borderColor: "$neutral7"
      },
      cards: {
        borderStyle: "solid",
        borderColor: "$neutral7"
      },
      pills: {
        gap: "$1_5"
      }
    },
    alignment: {
      start: {
        justifyContent: "flex-start"
      },
      end: {
        justifyContent: "flex-end"
      },
      center: {
        justifyContent: "center"
      },
      apart: {
        justifyContent: "space-between"
      }
    },
    orientation: {
      horizontal: {
        flexDirection: "row"
      },
      vertical: {
        flexDirection: "column"
      }
    }
  },
  compoundVariants: [
    {
      variant: "underline",
      orientation: "horizontal",
      css: {
        borderBottomWidth: "1px"
      }
    },
    {
      variant: "underline",
      orientation: "vertical",
      css: {
        borderInlineEndWidth: "1px"
      }
    },
    {
      variant: "outline",
      orientation: "horizontal",
      css: {
        mb: "-1px",
        borderBottomWidth: "1px"
      }
    },
    {
      variant: "outline",
      orientation: "vertical",
      css: {
        marginInlineEnd: "-1px",
        borderInlineEndWidth: "1px"
      }
    },
    {
      variant: "cards",
      orientation: "horizontal",
      css: {
        mb: "-1px",
        borderBottomWidth: "1px"
      }
    },
    {
      variant: "cards",
      orientation: "vertical",
      css: {
        marginInlineEnd: "-1px",
        borderInlineEndWidth: "1px"
      }
    }
  ]
});
function createSelectedColorVariant(color) {
  return {
    "&[aria-selected='true']": {
      color
    }
  };
}
function createPillsAndColorVariant(config2) {
  return {
    "&[aria-selected='true']": {
      color: config2.color,
      backgroundColor: config2.bgColor
    },
    "&[aria-selected='true']:hover": {
      backgroundColor: config2.bgColorHover
    }
  };
}
var tabStyles = css({
  appearance: "none",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  outline: "none",
  border: "$none",
  backgroundColor: "transparent",
  px: "$4",
  color: "inherit",
  fontWeight: "inherit",
  cursor: "pointer",
  transitionProperty: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
  transitionDuration: "250ms",
  "&:focus": {
    zIndex: 1,
    outline: "none",
    boxShadow: "$outline"
  },
  "&:disabled": {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  variants: {
    variant: {
      underline: {
        borderWidth: 0,
        borderStyle: "solid",
        borderColor: "transparent",
        "&[aria-selected='true']": {
          borderColor: "currentColor"
        },
        "&:active": {
          backgroundColor: "$neutral4"
        }
      },
      outline: {
        borderWidth: "1px",
        borderStyle: "solid",
        borderColor: "transparent",
        "&[aria-selected='true']": {
          borderColor: "inherit"
        }
      },
      cards: {
        borderWidth: "1px",
        borderStyle: "solid",
        borderColor: "inherit",
        backgroundColor: "$neutral3",
        "&[aria-selected='true']": {
          borderColor: "inherit",
          backgroundColor: "$loContrast"
        }
      },
      pills: {
        borderRadius: "$sm",
        "&:hover": {
          backgroundColor: "$neutral3"
        },
        "&:hover:disabled": {
          backgroundColor: "transparent"
        }
      }
    },
    colorScheme: {
      primary: {},
      accent: {},
      neutral: {},
      success: {},
      info: {},
      warning: {},
      danger: {}
    },
    size: {
      sm: {
        py: "$1",
        fontSize: "$sm"
      },
      md: {
        py: "$2",
        fontSize: "$base"
      },
      lg: {
        py: "$3",
        fontSize: "$lg"
      }
    },
    orientation: {
      horizontal: {},
      vertical: {}
    },
    fitted: {
      true: {
        flex: 1
      }
    }
  },
  compoundVariants: [
    {
      variant: "underline",
      colorScheme: "primary",
      css: createSelectedColorVariant("$primary11")
    },
    {
      variant: "underline",
      colorScheme: "accent",
      css: createSelectedColorVariant("$accent11")
    },
    {
      variant: "underline",
      colorScheme: "neutral",
      css: createSelectedColorVariant("$neutral12")
    },
    {
      variant: "underline",
      colorScheme: "success",
      css: createSelectedColorVariant("$success11")
    },
    {
      variant: "underline",
      colorScheme: "info",
      css: createSelectedColorVariant("$info11")
    },
    {
      variant: "underline",
      colorScheme: "warning",
      css: createSelectedColorVariant("$warning11")
    },
    {
      variant: "underline",
      colorScheme: "danger",
      css: createSelectedColorVariant("$danger11")
    },
    {
      variant: "outline",
      colorScheme: "primary",
      css: createSelectedColorVariant("$primary11")
    },
    {
      variant: "outline",
      colorScheme: "accent",
      css: createSelectedColorVariant("$accent11")
    },
    {
      variant: "outline",
      colorScheme: "neutral",
      css: createSelectedColorVariant("$neutral12")
    },
    {
      variant: "outline",
      colorScheme: "success",
      css: createSelectedColorVariant("$success11")
    },
    {
      variant: "outline",
      colorScheme: "info",
      css: createSelectedColorVariant("$info11")
    },
    {
      variant: "outline",
      colorScheme: "warning",
      css: createSelectedColorVariant("$warning11")
    },
    {
      variant: "outline",
      colorScheme: "danger",
      css: createSelectedColorVariant("$danger11")
    },
    {
      variant: "cards",
      colorScheme: "primary",
      css: createSelectedColorVariant("$primary11")
    },
    {
      variant: "cards",
      colorScheme: "accent",
      css: createSelectedColorVariant("$accent11")
    },
    {
      variant: "cards",
      colorScheme: "neutral",
      css: createSelectedColorVariant("$neutral12")
    },
    {
      variant: "cards",
      colorScheme: "success",
      css: createSelectedColorVariant("$success11")
    },
    {
      variant: "cards",
      colorScheme: "info",
      css: createSelectedColorVariant("$info11")
    },
    {
      variant: "cards",
      colorScheme: "warning",
      css: createSelectedColorVariant("$warning11")
    },
    {
      variant: "cards",
      colorScheme: "danger",
      css: createSelectedColorVariant("$danger11")
    },
    {
      variant: "pills",
      colorScheme: "primary",
      css: createPillsAndColorVariant({
        color: "$primary11",
        bgColor: "$primary3",
        bgColorHover: "$primary4"
      })
    },
    {
      variant: "pills",
      colorScheme: "accent",
      css: createPillsAndColorVariant({
        color: "$accent11",
        bgColor: "$accent3",
        bgColorHover: "$accent4"
      })
    },
    {
      variant: "pills",
      colorScheme: "neutral",
      css: createPillsAndColorVariant({
        color: "$neutral12",
        bgColor: "$neutral3",
        bgColorHover: "$neutral4"
      })
    },
    {
      variant: "pills",
      colorScheme: "success",
      css: createPillsAndColorVariant({
        color: "$success11",
        bgColor: "$success3",
        bgColorHover: "$success4"
      })
    },
    {
      variant: "pills",
      colorScheme: "info",
      css: createPillsAndColorVariant({
        color: "$info11",
        bgColor: "$info3",
        bgColorHover: "$info4"
      })
    },
    {
      variant: "pills",
      colorScheme: "warning",
      css: createPillsAndColorVariant({
        color: "$warning11",
        bgColor: "$warning3",
        bgColorHover: "$warning4"
      })
    },
    {
      variant: "pills",
      colorScheme: "danger",
      css: createPillsAndColorVariant({
        color: "$danger11",
        bgColor: "$danger3",
        bgColorHover: "$danger4"
      })
    },
    {
      variant: "underline",
      orientation: "horizontal",
      css: {
        borderBottomWidth: "2px",
        marginBottom: "-1px"
      }
    },
    {
      variant: "underline",
      orientation: "vertical",
      css: {
        borderInlineEndWidth: "2px",
        marginInlineEnd: "-1px"
      }
    },
    {
      variant: "outline",
      orientation: "horizontal",
      css: {
        mb: "-1px",
        borderTopRadius: "$sm",
        "&[aria-selected='true']": {
          borderBottomColor: "$loContrast"
        }
      }
    },
    {
      variant: "outline",
      orientation: "vertical",
      css: {
        marginInlineEnd: "-1px",
        borderStartRadius: "$radii$sm",
        "&[aria-selected='true']": {
          borderInlineEndColor: "$colors$loContrast"
        }
      }
    },
    {
      variant: "cards",
      orientation: "horizontal",
      css: {
        mb: "-1px",
        borderBottomWidth: "1px",
        "&:not(:last-of-type)": {
          marginInlineEnd: "-1px"
        },
        "&[aria-selected='true']": {
          borderTopColor: "currentColor",
          borderBottomColor: "transparent"
        }
      }
    },
    {
      variant: "cards",
      orientation: "vertical",
      css: {
        marginInlineEnd: "-1px",
        borderInlineEndWidth: "1px",
        "&:not(:last-of-type)": {
          mb: "-1px"
        },
        "&[aria-selected='true']": {
          borderInlineStartColor: "currentColor",
          borderInlineEndColor: "transparent"
        }
      }
    }
  ]
});
var tabPanelStyles = css({
  outline: "none",
  padding: "$4"
});
var hopeTabsClass = "hope-tabs";
function Tabs(props) {
  var _a;
  const defaultBaseId = `hope-tabs-${createUniqueId()}`;
  const theme = useStyleConfig().Tabs;
  const [tabs, setTabs] = createSignal([]);
  const [tabPanels, setTabPanels] = createSignal([]);
  const [state, setState] = createStore({
    _selectedIndex: (_a = props.defaultIndex) != null ? _a : 0,
    get isControlled() {
      return props.index !== void 0;
    },
    get selectedIndex() {
      return this.isControlled ? props.index : this._selectedIndex;
    },
    get baseId() {
      var _a2;
      return (_a2 = props.id) != null ? _a2 : defaultBaseId;
    },
    get orientation() {
      var _a2;
      return (_a2 = props.orientation) != null ? _a2 : "horizontal";
    },
    get keepAlive() {
      var _a2, _b, _c, _d;
      return (_d = (_c = props.keepAlive) != null ? _c : (_b = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.root) == null ? void 0 : _b.keepAlive) != null ? _d : false;
    },
    get alignment() {
      var _a2, _b, _c, _d;
      return (_d = (_c = props.alignment) != null ? _c : (_b = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.root) == null ? void 0 : _b.alignment) != null ? _d : "start";
    },
    get variant() {
      var _a2, _b, _c, _d;
      return (_d = (_c = props.variant) != null ? _c : (_b = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.root) == null ? void 0 : _b.variant) != null ? _d : "underline";
    },
    get colorScheme() {
      var _a2, _b, _c, _d;
      return (_d = (_c = props.colorScheme) != null ? _c : (_b = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.root) == null ? void 0 : _b.colorScheme) != null ? _d : "primary";
    },
    get size() {
      var _a2, _b, _c, _d;
      return (_d = (_c = props.size) != null ? _c : (_b = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.root) == null ? void 0 : _b.size) != null ? _d : "md";
    },
    get fitted() {
      var _a2, _b, _c, _d;
      return (_d = (_c = props.fitted) != null ? _c : (_b = (_a2 = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a2.root) == null ? void 0 : _b.fitted) != null ? _d : false;
    }
  });
  const [local, _, others] = splitProps(props, ["class", "onChange"], ["index", "defaultIndex", "keepAlive", "alignment", "orientation", "variant", "colorScheme", "size", "fitted"]);
  const reverseTabs = createMemo(() => tabs().slice().reverse());
  const setSelectedIndex = (index) => {
    var _a2;
    setState("_selectedIndex", index);
    (_a2 = local.onChange) == null ? void 0 : _a2.call(local, index);
  };
  const isSelectedIndex = (index) => {
    return index === state.selectedIndex;
  };
  const getTabId = (index) => {
    return `${state.baseId}--tab-${index}`;
  };
  const getTabPanelId = (index) => {
    return `${state.baseId}--tabpanel-${index}`;
  };
  const registerTab = (node) => {
    return setTabs((prev) => [...prev, node]).length - 1;
  };
  const registerTabPanel = (node) => {
    return setTabPanels((prev) => [...prev, node]).length - 1;
  };
  const focusNextTab = () => {
    const lastIndex = tabs().length - 1;
    let nextIndex = getNextIndex(state.selectedIndex, lastIndex, true);
    let nextTab = tabs()[nextIndex];
    while (nextTab.disabled) {
      nextIndex = getNextIndex(nextIndex, lastIndex, true);
      nextTab = tabs()[nextIndex];
    }
    nextTab.focus();
  };
  const focusPrevTab = () => {
    const lastIndex = tabs().length - 1;
    let prevIndex = getPrevIndex(state.selectedIndex, lastIndex, true);
    let prevTab = tabs()[prevIndex];
    while (prevTab.disabled) {
      prevIndex = getPrevIndex(prevIndex, lastIndex, true);
      prevTab = tabs()[prevIndex];
    }
    prevTab.focus();
  };
  const focusFirstTab = () => {
    var _a2;
    (_a2 = tabs().find((tab) => !tab.disabled)) == null ? void 0 : _a2.focus();
  };
  const focusLastTab = () => {
    var _a2;
    (_a2 = reverseTabs().find((tab) => !tab.disabled)) == null ? void 0 : _a2.focus();
  };
  const classes = () => {
    return classNames(local.class, hopeTabsClass, tabsStyles({
      orientation: state.orientation
    }));
  };
  const context = {
    state,
    setSelectedIndex,
    isSelectedIndex,
    getTabId,
    getTabPanelId,
    registerTab,
    registerTabPanel,
    focusPrevTab,
    focusNextTab,
    focusFirstTab,
    focusLastTab
  };
  return createComponent(TabsContext.Provider, {
    value: context,
    get children() {
      return createComponent(Box, mergeProps({
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a2;
          return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.root;
        }
      }, others));
    }
  });
}
Tabs.toString = () => createClassSelector(hopeTabsClass);
var TabsContext = createContext();
function useTabsContext() {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error("[Hope UI]: useTabsContext must be used within a `<Tabs />` component");
  }
  return context;
}
var hopeTabClass = "hope-tabs__tab";
function Tab(props) {
  const theme = useStyleConfig().Tabs;
  const tabsContext = useTabsContext();
  const [index, setIndex] = createSignal(-1);
  const [local, others] = splitProps(props, ["ref", "class", "disabled", "onClick", "onFocus"]);
  const isSelected = () => tabsContext.isSelectedIndex(index());
  const tabId = () => tabsContext.getTabId(index());
  const tabPanelId = () => tabsContext.getTabPanelId(index());
  const assignTabRef = (el) => {
    setIndex(tabsContext.registerTab(el));
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const onClick = (event) => {
    tabsContext.setSelectedIndex(index());
    callHandler(local.onClick, event);
  };
  const onFocus = (event) => {
    tabsContext.setSelectedIndex(index());
    callHandler(local.onFocus, event);
  };
  const classes = () => {
    return classNames(local.class, hopeTabClass, tabStyles({
      orientation: tabsContext.state.orientation,
      variant: tabsContext.state.variant,
      colorScheme: tabsContext.state.colorScheme,
      size: tabsContext.state.size,
      fitted: tabsContext.state.fitted
    }));
  };
  return createComponent(hope.button, mergeProps({
    ref: assignTabRef,
    role: "tab",
    type: "button",
    get id() {
      return tabId();
    },
    get tabIndex() {
      return isSelected() ? 0 : -1;
    },
    get disabled() {
      return local.disabled;
    },
    get ["aria-selected"]() {
      return isSelected();
    },
    get ["aria-controls"]() {
      return tabPanelId();
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.tab;
    },
    onClick,
    onFocus
  }, others));
}
Tab.toString = () => createClassSelector(hopeTabClass);
var hopeTabListClass = "hope-tabs__tablist";
function TabList(props) {
  const theme = useStyleConfig().Tabs;
  const tabsContext = useTabsContext();
  const [local, others] = splitProps(props, ["class", "onKeyDown"]);
  const isHorizontal = () => tabsContext.state.orientation === "horizontal";
  const isVertical = () => tabsContext.state.orientation === "vertical";
  const onArrowLeftKeyDown = () => isHorizontal() && tabsContext.focusPrevTab();
  const onArrowRightKeyDown = () => isHorizontal() && tabsContext.focusNextTab();
  const onArrowDownKeyDown = () => isVertical() && tabsContext.focusNextTab();
  const onArrowUpKeyDown = () => isVertical() && tabsContext.focusPrevTab();
  const keyMap = createMemo(() => ({
    ArrowLeft: onArrowLeftKeyDown,
    ArrowRight: onArrowRightKeyDown,
    ArrowDown: onArrowDownKeyDown,
    ArrowUp: onArrowUpKeyDown,
    Home: tabsContext.focusFirstTab,
    End: tabsContext.focusLastTab
  }));
  const onKeyDown = (event) => {
    callHandler(local.onKeyDown, event);
    const eventKey = normalizeEventKey(event);
    const action = keyMap()[eventKey];
    if (action) {
      event.preventDefault();
      callHandler(action, event);
    }
  };
  const classes = () => {
    return classNames(local.class, hopeTabListClass, tabListStyles({
      alignment: tabsContext.state.alignment,
      orientation: tabsContext.state.orientation,
      variant: tabsContext.state.variant
    }));
  };
  return createComponent(Box, mergeProps({
    role: "tablist",
    get ["aria-orientation"]() {
      return tabsContext.state.orientation;
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.tabList;
    },
    onKeyDown
  }, others));
}
TabList.toString = () => createClassSelector(hopeTabListClass);
var hopeTabPanelClass = "hope-tabs__tab-panel";
function TabPanel(props) {
  const theme = useStyleConfig().Tabs;
  const tabsContext = useTabsContext();
  const [index, setIndex] = createSignal(-1);
  const [local, others] = splitProps(props, ["ref", "class", "children"]);
  const isSelected = () => tabsContext.isSelectedIndex(index());
  const tabId = () => tabsContext.getTabId(index());
  const tabPanelId = () => tabsContext.getTabPanelId(index());
  const assignTabPanelRef = (el) => {
    setIndex(tabsContext.registerTabPanel(el));
    if (isFunction(local.ref)) {
      local.ref(el);
    } else {
      local.ref = el;
    }
  };
  const resolvedChildren = children(() => local.children);
  const classes = () => {
    return classNames(local.class, hopeTabPanelClass, tabPanelStyles());
  };
  return createComponent(Box, mergeProps({
    ref: assignTabPanelRef,
    role: "tabpanel",
    tabIndex: "0",
    get id() {
      return tabPanelId();
    },
    get ["aria-labelledby"]() {
      return tabId();
    },
    get hidden() {
      return !isSelected();
    },
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.tabPanel;
    }
  }, others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return isSelected();
        },
        get children() {
          return createComponent(Show, {
            get when() {
              return tabsContext.state.keepAlive;
            },
            get fallback() {
              return local.children;
            },
            get children() {
              return resolvedChildren();
            }
          });
        }
      });
    }
  }));
}
TabPanel.toString = () => createClassSelector(hopeTabPanelClass);
var tagRightIconStyles = css({
  marginInlineStart: "$2"
});
var tagLeftIconStyles = css({
  marginInlineEnd: "$2"
});
var tagLabelStyles = css({
  noOfLines: 1
});
var tagCloseButtonStyles = css({
  appearance: "none",
  position: "relative",
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  outline: "none",
  border: "1px solid transparent",
  borderRadius: "$full",
  backgroundColor: "transparent",
  padding: "0",
  lineHeight: "$none",
  textDecoration: "none",
  color: "inherit",
  cursor: "pointer",
  userSelect: "none",
  transition: "color 250ms, background-color 250ms, opacity 250ms, box-shadow 250ms",
  "&:focus": {
    outline: "none",
    boxShadow: "$outline"
  },
  "&:disabled": {
    border: "1px solid transparent",
    backgroundColor: "transparent",
    color: "$neutral3",
    cursor: "not-allowed"
  },
  variants: {
    size: {
      sm: {
        marginInlineStart: "0.35rem",
        marginInlineEnd: "-3px"
      },
      md: {
        marginInlineStart: "$1_5",
        marginInlineEnd: "calc(0.15rem * -1)"
      },
      lg: {
        marginInlineStart: "$1_5",
        marginInlineEnd: "calc($1 * -1)"
      }
    }
  }
});
function createTagSizeVariant(config2) {
  return {
    height: config2.height,
    py: 0,
    px: config2.paddingX,
    fontSize: config2.fontSize,
    lineHeight: config2.lineHeight,
    [`& .${tagCloseButtonStyles}`]: {
      boxSize: config2.closeButtonSize
    }
  };
}
function createTagSolidCompoundVariant(config2) {
  return {
    backgroundColor: config2.bgColor,
    color: config2.color,
    [`& .${tagCloseButtonStyles}:not(:disabled):hover`]: {
      backgroundColor: config2.closeButtonBgColorHover
    }
  };
}
function createTagSubtleCompoundVariant(config2) {
  return {
    backgroundColor: config2.bgColor,
    color: config2.color,
    [`& .${tagCloseButtonStyles}:not(:disabled):hover`]: {
      backgroundColor: config2.closeButtonBgColorHover
    }
  };
}
function createTagOutlineCompoundVariant(config2) {
  return {
    borderColor: config2.borderColor,
    color: config2.color,
    [`& .${tagCloseButtonStyles}:not(:disabled):hover`]: {
      backgroundColor: config2.closeButtonBgColorHover
    }
  };
}
function createTagDotAndSizeCompoundVariant(size22) {
  return {
    "&::before,  &::after": {
      boxSize: size22
    },
    "&::before": {
      marginRight: size22
    },
    "&::after": {
      marginLeft: size22
    }
  };
}
var tagStyles = css({
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "$full",
  fontWeight: "$medium",
  lineHeight: "$none",
  variants: {
    variant: {
      solid: {
        border: "1px solid transparent",
        color: "white"
      },
      subtle: {
        border: "1px solid transparent"
      },
      outline: {
        borderStyle: "solid",
        borderWidth: "1px",
        backgroundColor: "transparent"
      },
      dot: {
        border: "1px solid $neutral7",
        backgroundColor: "transparent",
        color: "$neutral12",
        "&::before,  &::after": {
          content: "''",
          borderRadius: "$full"
        },
        "&::before": {
          display: "block"
        },
        "&::after": {
          display: "none"
        },
        [`& .${tagCloseButtonStyles}:not(:disabled):hover`]: {
          backgroundColor: "$neutral4"
        },
        [`& .${tagCloseButtonStyles}:not(:disabled):active`]: {
          backgroundColor: "$neutral5"
        }
      }
    },
    colorScheme: {
      primary: {},
      accent: {},
      neutral: {},
      success: {},
      info: {},
      warning: {},
      danger: {}
    },
    size: {
      sm: createTagSizeVariant({
        height: "$5",
        paddingX: "$2",
        fontSize: "$xs",
        lineHeight: "$4",
        closeButtonSize: "$4"
      }),
      md: createTagSizeVariant({
        height: "$6",
        paddingX: "$2",
        fontSize: "$sm",
        lineHeight: "$5",
        closeButtonSize: "$5"
      }),
      lg: createTagSizeVariant({
        height: "$8",
        paddingX: "$3",
        fontSize: "$base",
        lineHeight: "$6",
        closeButtonSize: "$6"
      })
    },
    dotPlacement: {
      start: {},
      end: {}
    }
  },
  compoundVariants: [
    {
      variant: "solid",
      colorScheme: "primary",
      css: createTagSolidCompoundVariant({
        color: "white",
        bgColor: "$primary9",
        closeButtonBgColorHover: "$primary10"
      })
    },
    {
      variant: "solid",
      colorScheme: "accent",
      css: createTagSolidCompoundVariant({
        color: "white",
        bgColor: "$accent9",
        closeButtonBgColorHover: "$accent10"
      })
    },
    {
      variant: "solid",
      colorScheme: "neutral",
      css: createTagSolidCompoundVariant({
        color: "white",
        bgColor: "$neutral9",
        closeButtonBgColorHover: "$neutral11"
      })
    },
    {
      variant: "solid",
      colorScheme: "success",
      css: createTagSolidCompoundVariant({
        color: "white",
        bgColor: "$success9",
        closeButtonBgColorHover: "$success10"
      })
    },
    {
      variant: "solid",
      colorScheme: "info",
      css: createTagSolidCompoundVariant({
        color: "white",
        bgColor: "$info9",
        closeButtonBgColorHover: "$info10"
      })
    },
    {
      variant: "solid",
      colorScheme: "warning",
      css: createTagSolidCompoundVariant({
        color: "$blackAlpha12",
        bgColor: "$warning9",
        closeButtonBgColorHover: "$warning10"
      })
    },
    {
      variant: "solid",
      colorScheme: "danger",
      css: createTagSolidCompoundVariant({
        color: "white",
        bgColor: "$danger9",
        closeButtonBgColorHover: "$danger10"
      })
    },
    {
      variant: "subtle",
      colorScheme: "primary",
      css: createTagSubtleCompoundVariant({
        color: "$primary11",
        bgColor: "$primary4",
        closeButtonBgColorHover: "$primary6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "accent",
      css: createTagSubtleCompoundVariant({
        color: "$accent11",
        bgColor: "$accent4",
        closeButtonBgColorHover: "$accent6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "neutral",
      css: createTagSubtleCompoundVariant({
        color: "$neutral12",
        bgColor: "$neutral4",
        closeButtonBgColorHover: "$neutral7"
      })
    },
    {
      variant: "subtle",
      colorScheme: "success",
      css: createTagSubtleCompoundVariant({
        color: "$success11",
        bgColor: "$success4",
        closeButtonBgColorHover: "$success6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "info",
      css: createTagSubtleCompoundVariant({
        color: "$info11",
        bgColor: "$info4",
        closeButtonBgColorHover: "$info6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "warning",
      css: createTagSubtleCompoundVariant({
        color: "$warning11",
        bgColor: "$warning4",
        closeButtonBgColorHover: "$warning6"
      })
    },
    {
      variant: "subtle",
      colorScheme: "danger",
      css: createTagSubtleCompoundVariant({
        color: "$danger11",
        bgColor: "$danger4",
        closeButtonBgColorHover: "$danger6"
      })
    },
    {
      variant: "outline",
      colorScheme: "primary",
      css: createTagOutlineCompoundVariant({
        color: "$primary11",
        borderColor: "$primary7",
        closeButtonBgColorHover: "$primary4"
      })
    },
    {
      variant: "outline",
      colorScheme: "accent",
      css: createTagOutlineCompoundVariant({
        color: "$accent11",
        borderColor: "$accent7",
        closeButtonBgColorHover: "$accent4"
      })
    },
    {
      variant: "outline",
      colorScheme: "neutral",
      css: createTagOutlineCompoundVariant({
        color: "$neutral12",
        borderColor: "$neutral7",
        closeButtonBgColorHover: "$neutral4"
      })
    },
    {
      variant: "outline",
      colorScheme: "success",
      css: createTagOutlineCompoundVariant({
        color: "$success11",
        borderColor: "$success7",
        closeButtonBgColorHover: "$success4"
      })
    },
    {
      variant: "outline",
      colorScheme: "info",
      css: createTagOutlineCompoundVariant({
        color: "$info11",
        borderColor: "$info7",
        closeButtonBgColorHover: "$info4"
      })
    },
    {
      variant: "outline",
      colorScheme: "warning",
      css: createTagOutlineCompoundVariant({
        color: "$warning11",
        borderColor: "$warning7",
        closeButtonBgColorHover: "$warning4"
      })
    },
    {
      variant: "outline",
      colorScheme: "danger",
      css: createTagOutlineCompoundVariant({
        color: "$danger11",
        borderColor: "$danger7",
        closeButtonBgColorHover: "$danger4"
      })
    },
    {
      variant: "dot",
      colorScheme: "primary",
      css: {
        "&::before, &::after": {
          backgroundColor: "$primary9"
        }
      }
    },
    {
      variant: "dot",
      colorScheme: "accent",
      css: {
        "&::before, &::after": {
          backgroundColor: "$accent9"
        }
      }
    },
    {
      variant: "dot",
      colorScheme: "neutral",
      css: {
        "&::before, &::after": {
          backgroundColor: "$neutral9"
        }
      }
    },
    {
      variant: "dot",
      colorScheme: "success",
      css: {
        "&::before, &::after": {
          backgroundColor: "$success9"
        }
      }
    },
    {
      variant: "dot",
      colorScheme: "info",
      css: {
        "&::before, &::after": {
          backgroundColor: "$info9"
        }
      }
    },
    {
      variant: "dot",
      colorScheme: "warning",
      css: {
        "&::before, &::after": {
          backgroundColor: "$warning9"
        }
      }
    },
    {
      variant: "dot",
      colorScheme: "danger",
      css: {
        "&::before, &::after": {
          backgroundColor: "$danger9"
        }
      }
    },
    {
      variant: "dot",
      size: "sm",
      css: createTagDotAndSizeCompoundVariant("$1_5")
    },
    {
      variant: "dot",
      size: "md",
      css: createTagDotAndSizeCompoundVariant("$2")
    },
    {
      variant: "dot",
      size: "lg",
      css: createTagDotAndSizeCompoundVariant("$2_5")
    },
    {
      variant: "dot",
      dotPlacement: "start",
      css: {
        "&::before": {
          display: "block"
        },
        "&::after": {
          display: "none"
        }
      }
    },
    {
      variant: "dot",
      dotPlacement: "end",
      css: {
        "&::before": {
          display: "none"
        },
        "&::after": {
          display: "block"
        }
      }
    }
  ]
});
var hopeTagClass = "hope-tag";
var TagContext = createContext();
function Tag(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const theme = useStyleConfig().Tag;
  const defaultProps = {
    variant: (_c = (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.root) == null ? void 0 : _b.variant) != null ? _c : "subtle",
    colorScheme: (_f = (_e = (_d = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _d.root) == null ? void 0 : _e.colorScheme) != null ? _f : "neutral",
    size: (_i = (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.root) == null ? void 0 : _h.size) != null ? _i : "md"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, variantProps, others] = splitProps(propsWithDefault, ["class"], ["variant", "colorScheme", "size", "dotPlacement"]);
  const classes = () => classNames(local.class, hopeTagClass, tagStyles(variantProps));
  const tagSize = () => variantProps.size;
  const context = {
    size: tagSize
  };
  return createComponent(TagContext.Provider, {
    value: context,
    get children() {
      return createComponent(hope.span, mergeProps({
        get ["class"]() {
          return classes();
        },
        get __baseStyle() {
          var _a2;
          return (_a2 = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a2.root;
        }
      }, others));
    }
  });
}
Tag.toString = () => createClassSelector(hopeTagClass);
function useTagContext() {
  const context = useContext(TagContext);
  if (!context) {
    throw new Error("[Hope UI]: useTagContext must be used within a `<Tag />` component");
  }
  return context;
}
var hopeTagCloseButtonClass = "hope-tag-close-button";
function TagCloseButton(props) {
  const theme = useStyleConfig().Tag;
  const tagContext = useTagContext();
  const defaultProps = {
    type: "button",
    role: "button",
    "aria-label": "Close"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "children"]);
  const classes = () => classNames(local.class, hopeTagCloseButtonClass, tagCloseButtonStyles({
    size: tagContext.size()
  }));
  return createComponent(hope.button, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.closeButton;
    }
  }, others, {
    get children() {
      return createComponent(IconCloseSmall, {});
    }
  }));
}
TagCloseButton.toString = () => createClassSelector(hopeTagCloseButtonClass);
var hopeTagLeftIconClass = "hope-tag-left-icon";
function TagLeftIcon(props) {
  const theme = useStyleConfig().Tag;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeTagLeftIconClass, tagLeftIconStyles());
  return createComponent(Icon, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.icon;
    }
  }, others));
}
TagLeftIcon.toString = () => createClassSelector(hopeTagLeftIconClass);
var hopeTagRightIconClass = "hope-tag-right-icon";
function TagRightIcon(props) {
  const theme = useStyleConfig().Tag;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeTagRightIconClass, tagRightIconStyles());
  return createComponent(Icon, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.icon;
    }
  }, others));
}
TagRightIcon.toString = () => createClassSelector(hopeTagRightIconClass);
var hopeTagLabelClass = "hope-tag-label";
function TagLabel(props) {
  const theme = useStyleConfig().Tag;
  const [local, others] = splitProps(props, ["class"]);
  const classes = () => classNames(local.class, hopeTagLabelClass, tagLabelStyles());
  return createComponent(hope.span, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      var _a;
      return (_a = theme == null ? void 0 : theme.baseStyle) == null ? void 0 : _a.label;
    }
  }, others));
}
TagLabel.toString = () => createClassSelector(hopeTagLabelClass);
var hopeTextClass = "hope-text";
function Text(props) {
  var _a;
  const theme = useStyleConfig().Text;
  const defaultProps = {
    size: (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.size
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "size"]);
  const classes = () => classNames(local.class, hopeTextClass, textStyles({
    size: local.size
  }));
  return createComponent(hope.p, mergeProps({
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      return theme == null ? void 0 : theme.baseStyle;
    }
  }, others));
}
Text.toString = () => createClassSelector(hopeTextClass);
function createVariantAndSizeCompoundVariants(variant, paddingX) {
  return Object.entries({
    xs: paddingX != null ? paddingX : "$2",
    sm: paddingX != null ? paddingX : "$2_5",
    md: paddingX != null ? paddingX : "$3",
    lg: paddingX != null ? paddingX : "$4"
  }).map(([key, value]) => ({
    variant,
    size: key,
    css: { px: value }
  }));
}
var textareaStyles = css(baseInputResetStyles, {
  minHeight: "80px",
  py: "$2",
  compoundVariants: [
    ...createVariantAndSizeCompoundVariants("outline"),
    ...createVariantAndSizeCompoundVariants("filled"),
    ...createVariantAndSizeCompoundVariants("unstyled", 0)
  ]
});
var hopeTextareaClass = "hope-textarea";
function Textarea(props) {
  var _a, _b, _c, _d;
  const theme = useStyleConfig().Textarea;
  const defaultProps = {
    variant: (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.variant) != null ? _b : "outline",
    size: (_d = (_c = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _c.size) != null ? _d : "md"
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "variant", "size"]);
  const formControlProps = useFormControl(props);
  const classes = () => {
    return classNames(local.class, hopeTextareaClass, textareaStyles({
      variant: local.variant,
      size: local.size
    }));
  };
  return createComponent(Box, mergeProps({
    as: "textarea",
    get ["class"]() {
      return classes();
    },
    get __baseStyle() {
      return theme == null ? void 0 : theme.baseStyle;
    }
  }, formControlProps, others));
}
Textarea.toString = () => createClassSelector(hopeTextareaClass);
var hopeTooltipClass = "hope-tooltip";
var hopeTooltipArrowClass = "hope-tooltip__arrow";
function Tooltip(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const defaultId = `hope-tooltip-${createUniqueId()}`;
  const theme = useStyleConfig().Tooltip;
  const defaultProps = {
    id: defaultId,
    placement: (_b = (_a = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _a.placement) != null ? _b : "bottom",
    offset: (_d = (_c = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _c.offset) != null ? _d : 8,
    withArrow: (_f = (_e = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _e.withArrow) != null ? _f : false,
    arrowSize: (_h = (_g = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _g.arrowSize) != null ? _h : 8,
    arrowPadding: (_j = (_i = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _i.arrowPadding) != null ? _j : 8,
    openDelay: (_l = (_k = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _k.openDelay) != null ? _l : 0,
    closeDelay: (_n = (_m = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _m.closeDelay) != null ? _n : 0,
    closeOnClick: (_p = (_o = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _o.closeOnClick) != null ? _p : true,
    closeOnMouseDown: (_r = (_q = theme == null ? void 0 : theme.defaultProps) == null ? void 0 : _q.closeOnMouseDown) != null ? _r : false
  };
  const propsWithDefault = mergeProps(defaultProps, props);
  const [local, others] = splitProps(propsWithDefault, ["class", "children", "id", "label", "opened", "defaultOpened", "inline", "disabled", "placement", "offset", "withArrow", "arrowSize", "arrowPadding", "openDelay", "closeDelay", "closeOnClick", "closeOnMouseDown", "onOpen", "onClose"]);
  const [openedState, setOpenedState] = createSignal(!!local.defaultOpened);
  const [isPortalMounted, setIsPortalMounted] = createSignal(false);
  let tooltipElement;
  let arrowElement;
  let enterTimeoutId;
  let exitTimeoutId;
  const isControlled = () => local.opened !== void 0;
  const opened = () => isControlled() ? !!local.opened : openedState();
  const tooltipClasses = () => classNames(local.class, hopeTooltipClass, tooltipStyles());
  const arrowClasses = () => classNames(hopeTooltipArrowClass, tooltipArrowStyles());
  let cleanupTooltipAutoUpdate;
  const resolvedChildren = children(() => local.children);
  const trigger = createMemo(() => {
    let el = resolvedChildren();
    while (isFunction(el)) {
      el = el();
    }
    return el;
  });
  async function updateTooltipPosition() {
    var _a2, _b2, _c2;
    const triggerElement = trigger();
    if (!triggerElement || !tooltipElement) {
      return;
    }
    const middleware = [offset(local.offset)];
    if (local.inline) {
      middleware.push(inline());
    }
    middleware.push(flip());
    middleware.push(shift());
    if (local.withArrow && arrowElement) {
      middleware.push(arrow({
        element: arrowElement,
        padding: local.arrowPadding
      }));
    }
    middleware.push(hide());
    const {
      x: x2,
      y: y2,
      placement,
      middlewareData
    } = await computePosition2(triggerElement, tooltipElement, {
      placement: local.placement,
      middleware
    });
    if (!tooltipElement) {
      return;
    }
    const referenceHidden = (_a2 = middlewareData.hide) == null ? void 0 : _a2.referenceHidden;
    Object.assign(tooltipElement.style, {
      left: `${Math.round(x2)}px`,
      top: `${Math.round(y2)}px`,
      visibility: referenceHidden ? "hidden" : "visible"
    });
    if (!arrowElement) {
      return;
    }
    const arrowX = (_b2 = middlewareData.arrow) == null ? void 0 : _b2.x;
    const arrowY = (_c2 = middlewareData.arrow) == null ? void 0 : _c2.y;
    const staticSide = {
      top: "bottom",
      right: "left",
      bottom: "top",
      left: "right"
    }[placement.split("-")[0]];
    const arrowOffset = `${local.arrowSize ? Math.round(local.arrowSize / 2) * -1 : -4}px`;
    Object.assign(arrowElement.style, {
      left: arrowX != null ? `${Math.round(arrowX)}px` : "",
      top: arrowY != null ? `${Math.round(arrowY)}px` : "",
      right: "",
      bottom: "",
      [staticSide]: arrowOffset
    });
  }
  const onOpen = () => {
    var _a2;
    if (!isControlled()) {
      setOpenedState(true);
    }
    (_a2 = local.onOpen) == null ? void 0 : _a2.call(local);
    updateTooltipPosition();
  };
  const onClose = () => {
    var _a2;
    if (!isControlled()) {
      setOpenedState(false);
    }
    (_a2 = local.onClose) == null ? void 0 : _a2.call(local);
  };
  const openWithDelay = () => {
    if (!local.disabled) {
      enterTimeoutId = window.setTimeout(onOpen, local.openDelay);
    }
  };
  const closeWithDelay = () => {
    if (enterTimeoutId) {
      window.clearTimeout(enterTimeoutId);
    }
    exitTimeoutId = window.setTimeout(onClose, local.closeDelay);
  };
  const onClick = () => {
    if (local.closeOnClick) {
      closeWithDelay();
    }
  };
  const onMouseDown = () => {
    if (local.closeOnMouseDown) {
      closeWithDelay();
    }
  };
  const onKeyDown = (event) => {
    if (opened() && event.key === "Escape") {
      closeWithDelay();
    }
  };
  const addTriggerListeners = () => {
    const triggerElement = trigger();
    triggerElement.addEventListener("mouseenter", openWithDelay);
    triggerElement.addEventListener("focus", openWithDelay);
    triggerElement.addEventListener("click", onClick);
    triggerElement.addEventListener("mousedown", onMouseDown);
    triggerElement.addEventListener("mouseleave", closeWithDelay);
    triggerElement.addEventListener("blur", closeWithDelay);
  };
  const removeTriggerListeners = () => {
    const triggerElement = trigger();
    triggerElement.removeEventListener("mouseenter", openWithDelay);
    triggerElement.removeEventListener("focus", openWithDelay);
    triggerElement.removeEventListener("click", onClick);
    triggerElement.removeEventListener("mousedown", onMouseDown);
    triggerElement.removeEventListener("mouseleave", closeWithDelay);
    triggerElement.removeEventListener("blur", closeWithDelay);
  };
  const afterToolipEnterTransition = () => {
    if (isServer || !tooltipElement) {
      return;
    }
    document.addEventListener("keydown", onKeyDown);
    cleanupTooltipAutoUpdate = autoUpdate(trigger(), tooltipElement, updateTooltipPosition);
  };
  const afterToolipExitTransition = () => {
    document.removeEventListener("keydown", onKeyDown);
    cleanupTooltipAutoUpdate == null ? void 0 : cleanupTooltipAutoUpdate();
    setIsPortalMounted(false);
  };
  onMount(() => {
    addTriggerListeners();
  });
  onCleanup(() => {
    removeTriggerListeners();
    window.clearTimeout(enterTimeoutId);
    window.clearTimeout(exitTimeoutId);
  });
  createEffect(() => {
    if (opened()) {
      setIsPortalMounted(true);
      if (local.id) {
        trigger().setAttribute("aria-describedby", local.id);
      }
    } else {
      trigger().removeAttribute("aria-describedby");
    }
  });
  return [trigger, createComponent(Show, {
    get when() {
      return isPortalMounted();
    },
    get children() {
      return createComponent(Portal, {
        get children() {
          return createComponent(Transition, {
            get name() {
              return tooltipTransitionName.scale;
            },
            appear: true,
            onBeforeEnter: updateTooltipPosition,
            onAfterEnter: afterToolipEnterTransition,
            onAfterExit: afterToolipExitTransition,
            get children() {
              return createComponent(Show, {
                get when() {
                  return opened();
                },
                get children() {
                  return createComponent(Box, mergeProps({
                    ref(r$) {
                      const _ref$ = tooltipElement;
                      typeof _ref$ === "function" ? _ref$(r$) : tooltipElement = r$;
                    },
                    role: "tooltip",
                    get id() {
                      return local.id;
                    },
                    get ["class"]() {
                      return tooltipClasses();
                    },
                    get __baseStyle() {
                      return theme == null ? void 0 : theme.baseStyle;
                    }
                  }, others, {
                    get children() {
                      return [memo(() => local.label), createComponent(Show, {
                        get when() {
                          return local.withArrow;
                        },
                        get children() {
                          return createComponent(Box, {
                            ref(r$) {
                              const _ref$2 = arrowElement;
                              typeof _ref$2 === "function" ? _ref$2(r$) : arrowElement = r$;
                            },
                            get ["class"]() {
                              return arrowClasses();
                            },
                            get boxSize() {
                              return local.arrowSize;
                            }
                          });
                        }
                      })];
                    }
                  }));
                }
              });
            }
          });
        }
      });
    }
  })];
}
Tooltip.toString = () => createClassSelector(hopeTooltipClass);
function createDisclosure(props = {}) {
  const id = `disclosure-${createUniqueId()}`;
  const [isOpenState, setIsOpenState] = createSignal(props.defaultIsOpen || false);
  const isControlled = () => props.isOpen !== void 0;
  const isOpen = () => isControlled() ? !!props.isOpen : isOpenState();
  const onClose = () => {
    var _a;
    if (!isControlled()) {
      setIsOpenState(false);
    }
    (_a = props.onClose) == null ? void 0 : _a.call(props);
  };
  const onOpen = () => {
    var _a;
    if (!isControlled()) {
      setIsOpenState(true);
    }
    (_a = props.onOpen) == null ? void 0 : _a.call(props);
  };
  const onToggle = () => {
    isOpen() ? onClose() : onOpen();
  };
  const triggerProps = () => ({
    "aria-expanded": isOpen(),
    "aria-controls": id
  });
  const disclosureProps = () => ({
    id,
    hidden: !isOpen()
  });
  return {
    isControlled,
    isOpen,
    onOpen,
    onClose,
    onToggle,
    triggerProps,
    disclosureProps
  };
}
function useEvent(props) {
  let _once = false;
  const onEmit = (event) => {
    var _a;
    const { once } = props;
    if (once && _once) {
      return;
    }
    _once = true;
    (_a = props.handler) == null ? void 0 : _a.call(props, event);
  };
  const _active = (element, key, capture, passive) => {
    if (key && element && element.addEventListener) {
      element.addEventListener(key, onEmit, {
        capture,
        passive
      });
    }
  };
  const active = () => {
    const { element, eventName, capture, passive } = props;
    _active(element, eventName, capture, passive);
  };
  const _inactive = (element, key) => {
    if (key && element && element.removeEventListener) {
      element.removeEventListener(key, onEmit);
    }
  };
  const inactive = () => {
    const { element, eventName } = props;
    _inactive(element, eventName);
  };
  createEffect((prev) => {
    const { element, eventName, capture, passive } = props;
    if (prev) {
      _inactive(prev.element, prev.eventName);
    }
    _active(element, eventName, capture, passive);
    return {
      element,
      eventName
    };
  });
  onCleanup(() => {
    const { element, eventName } = props;
    _inactive(element, eventName);
  });
  return {
    active,
    inactive
  };
}
export {
  Accordion,
  AccordionButton,
  AccordionIcon,
  AccordionItem,
  AccordionPanel,
  Alert,
  AlertDescription,
  AlertIcon,
  AlertTitle,
  Anchor,
  AspectRatio,
  AsyncButton,
  Avatar,
  AvatarBadge,
  AvatarExcess,
  AvatarGroup,
  Badge,
  Box,
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbSeparator,
  Button,
  ButtonGroup,
  Center,
  Checkbox,
  CheckboxGroup,
  CheckboxPrimitive,
  CheckboxPrimitiveIndicator,
  CircularProgress,
  CircularProgressIndicator,
  CircularProgressLabel,
  CloseButton,
  Collapse,
  Container,
  Divider,
  Drawer,
  DrawerBody,
  DrawerCloseButton,
  DrawerContent,
  DrawerFooter,
  DrawerHeader,
  DrawerOverlay,
  Flex,
  FormControl,
  FormControlContext,
  FormErrorMessage,
  FormHelperText,
  FormLabel,
  Grid,
  GridItem,
  HStack,
  Heading,
  HopeContext,
  HopeProvider,
  Icon,
  IconButton,
  Image$1 as Image,
  Input,
  InputAddon,
  InputElement,
  InputGroup,
  InputLeftAddon,
  InputLeftElement,
  InputRightAddon,
  InputRightElement,
  Kbd,
  List,
  ListIcon,
  ListItem,
  Menu,
  MenuContent,
  MenuGroup,
  MenuItem,
  MenuLabel,
  MenuTrigger,
  Modal,
  ModalBody,
  ModalCloseButton,
  ModalContent,
  ModalFooter,
  ModalHeader,
  ModalOverlay,
  Notification,
  NotificationDescription,
  NotificationIcon,
  NotificationTitle,
  NotificationsProvider,
  OrderedList,
  Popover,
  PopoverAnchor,
  PopoverArrow,
  PopoverBody,
  PopoverCloseButton,
  PopoverContent,
  PopoverFooter,
  PopoverHeader,
  PopoverTrigger,
  Progress,
  ProgressIndicator,
  ProgressLabel,
  Radio,
  RadioGroup,
  Select,
  SelectContent,
  SelectIcon,
  SelectLabel,
  SelectListbox,
  SelectOptGroup,
  SelectOption,
  SelectOptionIndicator,
  SelectOptionText,
  SelectPlaceholder,
  SelectTag,
  SelectTagCloseButton,
  SelectTrigger,
  SelectValue,
  SimpleGrid,
  SimpleOption,
  SimpleSelect,
  Skeleton,
  SkeletonCircle,
  SkeletonText,
  Spacer,
  Spinner,
  Stack,
  Switch2 as Switch,
  SwitchPrimitive,
  SwitchPrimitiveThumb,
  Tab,
  TabList,
  TabPanel,
  Table,
  TableCaption,
  Tabs,
  Tag,
  TagCloseButton,
  TagLabel,
  TagLeftIcon,
  TagRightIcon,
  Tbody,
  Td,
  Text,
  Textarea,
  Tfoot,
  Th,
  Thead,
  Tooltip,
  Tr,
  UnorderedList,
  VStack,
  __DEV__,
  accordionButtonStyles,
  accordionIconStyles,
  accordionItemStyles,
  accordionPanelStyles,
  alertDescriptionStyles,
  alertIconStyles,
  alertStyles,
  alertTitleStyles,
  anchorStyles,
  aspectRatioStyles,
  avatarBadgeStyles,
  avatarExcessStyles,
  avatarGroupStyles,
  avatarImageStyles,
  avatarStyles,
  badgeStyles,
  baseDialogStyles,
  baseInputResetStyles,
  baseModalContainerStyles,
  baseTheme,
  breadcrumbItemStyles,
  breadcrumbLinkStyles,
  breadcrumbListStyles,
  breadcrumbSeparatorStyles,
  breadcrumbStyles,
  buttonGroupStyles,
  buttonIconSpinnerStyles,
  buttonIconStyles,
  buttonLoaderStyles,
  buttonStyles,
  callHandler,
  cast,
  centerStyles,
  chainHandlers,
  checkboxControlStyles,
  checkboxLabelStyles,
  checkboxWrapperStyles,
  circularProgressIndicatorContainerStyles,
  circularProgressIndicatorStyles,
  circularProgressLabelStyles,
  circularProgressStyles,
  circularProgressTrackStyles,
  classNames,
  closeButtonStyles,
  collapseStyles,
  colorModeClassNames,
  config,
  containerStyles,
  contains2 as contains,
  createClassSelector,
  createDisclosure,
  createIcon,
  createTheme,
  css,
  dividerStyles,
  drawerContainerStyles,
  drawerDialogStyles,
  drawerTransitionName,
  drawerTransitionStyles,
  formControlStyles,
  formErrorMessageStyles,
  formHelperTextStyles,
  formLabelStyles,
  getActiveElement,
  getColorModeClassName,
  getCssText,
  getDefaultColorMode,
  getNextIndex,
  getOwnerDocument,
  getPrevIndex,
  getRelatedTarget,
  globalCss,
  growAndShrink,
  hasTabIndex,
  headingStyles,
  hope,
  hopeButtonClass,
  hopeIconButtonClass,
  hopeIconClass,
  hopeSkeletonClass,
  iconStyles,
  inputAddonStyles,
  inputElementStyles,
  inputGroupStyles,
  inputStyles,
  isArray,
  isChildrenFunction,
  isContentEditable,
  isDisabled,
  isElement2 as isElement,
  isFocusable3 as isFocusable,
  isFunction,
  isHTMLElement2 as isHTMLElement,
  isHidden3 as isHidden,
  isNull,
  isNumber,
  isObject,
  isScrollable,
  isString,
  isUndefined,
  isValidEvent,
  kbdStyles,
  keyframes,
  listIconStyles,
  listStyles,
  maintainScrollVisibility,
  mapKeys,
  menuContentStyles,
  menuGroupStyles,
  menuItemCommandStyles,
  menuItemIconWrapperStyles,
  menuItemStyles,
  menuItemTextStyles,
  menuLabelStyles,
  menuTransitionName,
  menuTransitionStyles,
  menuTriggerStyles,
  mockBody,
  modalBodyStyles,
  modalCloseButtonStyles,
  modalContainerStyles,
  modalDialogStyles,
  modalFooterStyles,
  modalHeaderStyles,
  modalOverlayStyles,
  modalTransitionName,
  modalTransitionStyles,
  noop,
  normalizeEventKey,
  notificationDescriptionStyles,
  notificationIconStyles,
  notificationListStyles,
  notificationLoaderStyles,
  notificationService,
  notificationStyles,
  notificationTitleStyles,
  notificationTransitionName,
  notificationTransitionStyles,
  popoverArrowStyles,
  popoverBodyStyles,
  popoverCloseButtonStyles,
  popoverContentStyles,
  popoverFooterStyles,
  popoverHeaderStyles,
  popoverTransitionName,
  popoverTransitionStyles,
  progressIndicatorStyles,
  progressLabelStyles,
  progressStyles,
  radioControlStyles,
  radioLabelStyles,
  radioWrapperStyles,
  range,
  requiredIndicatorStyles,
  saveColorModeToLocalStorage,
  selectContentStyles,
  selectIconStyles,
  selectLabelStyles,
  selectListboxStyles,
  selectMultiValueStyles,
  selectOptGroupStyles,
  selectOptionIndicatorStyles,
  selectOptionStyles,
  selectOptionTextStyles,
  selectPlaceholderStyles,
  selectSingleValueStyles,
  selectTagCloseButtonStyles,
  selectTagStyles,
  selectTransitionName,
  selectTransitionStyles,
  selectTriggerStyles,
  skeletonStyles,
  spacerStyles,
  spinnerStyles,
  stackStyles,
  switchControlStyles,
  switchLabelStyles,
  switchWrapperStyles,
  syncBodyColorModeClassName,
  tabListStyles,
  tabPanelStyles,
  tabStyles,
  tableBodyStyles,
  tableCaptionStyles,
  tableCellStyles,
  tableColumnHeaderStyles,
  tableFootStyles,
  tableStyles,
  tabsStyles,
  tagCloseButtonStyles,
  tagLabelStyles,
  tagLeftIconStyles,
  tagRightIconStyles,
  tagStyles,
  textStyles,
  textareaStyles,
  toggleControlLabelStyles,
  toggleControlStyles,
  toggleWrapperStyles,
  tooltipArrowStyles,
  tooltipStyles,
  tooltipTransitionName,
  tooltipTransitionStyles,
  useAccordionContext,
  useAccordionItemContext,
  useAlertContext,
  useAvatarGroupContext,
  useBreadcrumbContext,
  useButtonGroupContext,
  useCheckboxGroupContext,
  useCheckboxPrimitiveContext,
  useCircularProgressContext,
  useClickOutside,
  useColorMode,
  useColorModeValue,
  useDrawerContext,
  useEvent,
  useFormControlContext,
  useInputGroupContext,
  useMenuContext,
  useMenuGroupContext,
  useModalContext,
  useNotificationContext,
  usePopoverContext,
  useProgressContext,
  useRadioContext,
  useRadioGroupContext,
  useSelectContext,
  useSelectOptGroupContext,
  useSelectOptionContext,
  useStyleConfig,
  useSwitchPrimitivehContext,
  useTableContext,
  useTabsContext,
  useTagContext,
  useTheme,
  valueToPercent
};
/*!
* focus-trap 6.7.3
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
/*!
* tabbable 5.3.3
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
//# sourceMappingURL=@hope-ui_solid.js.map
